
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b40  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000014  20000000  00000b40  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020014  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020014  2**0
                  CONTENTS
  4 .bss          000001ac  20000014  00000b54  00020014  2**2
                  ALLOC
  5 .stack        00008000  200001c0  00000d00  00020014  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020014  2**0
                  CONTENTS, READONLY
  7 .comment      00000033  00000000  00000000  00020042  2**0
                  CONTENTS, READONLY
  8 .debug_info   00011e3a  00000000  00000000  00020075  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00002285  00000000  00000000  00031eaf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    0000373c  00000000  00000000  00034134  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00000558  00000000  00000000  00037870  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 000007e0  00000000  00000000  00037dc8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  000081d3  00000000  00000000  000385a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0000bce3  00000000  00000000  0004077b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00101cf3  00000000  00000000  0004c45e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00000c0c  00000000  00000000  0014e154  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
   0:	c0 81 00 20 cd 06 00 00 c9 06 00 00 c9 06 00 00     ... ............
  10:	c9 06 00 00 c9 06 00 00 c9 06 00 00 00 00 00 00     ................
	...
  2c:	d1 04 00 00 c9 06 00 00 00 00 00 00 01 05 00 00     ................
  3c:	65 05 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     e...............
  4c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  5c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  6c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  7c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  8c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  9c:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  ac:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  bc:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  cc:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
  dc:	c9 06 00 00 c9 06 00 00 c9 06 00 00 00 00 00 00     ................
	...
  f4:	25 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     %...............
 104:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 114:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 124:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 134:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 144:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 154:	c9 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
 178:	61 04 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     a...............
 188:	c9 06 00 00 c9 06 00 00 00 00 00 00 c9 06 00 00     ................
 198:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1a8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1b8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1c8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1d8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1e8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 1f8:	c9 06 00 00 c9 06 00 00 c9 06 00 00 00 00 00 00     ................
 208:	00 00 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 218:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 228:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 238:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 248:	c9 06 00 00 c9 06 00 00 c9 06 00 00 c9 06 00 00     ................
 258:	c9 06 00 00 c9 06 00 00 00 00 00 00                 ............

00000264 <deregister_tm_clones>:
 264:	4803      	ldr	r0, [pc, #12]	; (274 <deregister_tm_clones+0x10>)
 266:	4b04      	ldr	r3, [pc, #16]	; (278 <deregister_tm_clones+0x14>)
 268:	4283      	cmp	r3, r0
 26a:	d002      	beq.n	272 <deregister_tm_clones+0xe>
 26c:	4b03      	ldr	r3, [pc, #12]	; (27c <deregister_tm_clones+0x18>)
 26e:	b103      	cbz	r3, 272 <deregister_tm_clones+0xe>
 270:	4718      	bx	r3
 272:	4770      	bx	lr
 274:	00000b40 	.word	0x00000b40
 278:	00000b40 	.word	0x00000b40
 27c:	00000000 	.word	0x00000000

00000280 <register_tm_clones>:
 280:	4805      	ldr	r0, [pc, #20]	; (298 <register_tm_clones+0x18>)
 282:	4906      	ldr	r1, [pc, #24]	; (29c <register_tm_clones+0x1c>)
 284:	1a0b      	subs	r3, r1, r0
 286:	0fd9      	lsrs	r1, r3, #31
 288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
 28c:	1049      	asrs	r1, r1, #1
 28e:	d002      	beq.n	296 <register_tm_clones+0x16>
 290:	4b03      	ldr	r3, [pc, #12]	; (2a0 <register_tm_clones+0x20>)
 292:	b103      	cbz	r3, 296 <register_tm_clones+0x16>
 294:	4718      	bx	r3
 296:	4770      	bx	lr
 298:	00000b40 	.word	0x00000b40
 29c:	00000b40 	.word	0x00000b40
 2a0:	00000000 	.word	0x00000000

000002a4 <__do_global_dtors_aux>:
 2a4:	b510      	push	{r4, lr}
 2a6:	4c06      	ldr	r4, [pc, #24]	; (2c0 <__do_global_dtors_aux+0x1c>)
 2a8:	7823      	ldrb	r3, [r4, #0]
 2aa:	b943      	cbnz	r3, 2be <__do_global_dtors_aux+0x1a>
 2ac:	f7ff ffda 	bl	264 <deregister_tm_clones>
 2b0:	4b04      	ldr	r3, [pc, #16]	; (2c4 <__do_global_dtors_aux+0x20>)
 2b2:	b113      	cbz	r3, 2ba <__do_global_dtors_aux+0x16>
 2b4:	4804      	ldr	r0, [pc, #16]	; (2c8 <__do_global_dtors_aux+0x24>)
 2b6:	f3af 8000 	nop.w
 2ba:	2301      	movs	r3, #1
 2bc:	7023      	strb	r3, [r4, #0]
 2be:	bd10      	pop	{r4, pc}
 2c0:	20000014 	.word	0x20000014
 2c4:	00000000 	.word	0x00000000
 2c8:	00000b40 	.word	0x00000b40

000002cc <frame_dummy>:
 2cc:	b508      	push	{r3, lr}
 2ce:	4b04      	ldr	r3, [pc, #16]	; (2e0 <frame_dummy+0x14>)
 2d0:	b11b      	cbz	r3, 2da <frame_dummy+0xe>
 2d2:	4904      	ldr	r1, [pc, #16]	; (2e4 <frame_dummy+0x18>)
 2d4:	4804      	ldr	r0, [pc, #16]	; (2e8 <frame_dummy+0x1c>)
 2d6:	f3af 8000 	nop.w
 2da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 2de:	e7cf      	b.n	280 <register_tm_clones>
 2e0:	00000000 	.word	0x00000000
 2e4:	20000018 	.word	0x20000018
 2e8:	00000b40 	.word	0x00000b40

000002ec <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
 2ec:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
 2ee:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 2f0:	689a      	ldr	r2, [r3, #8]
 2f2:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 2f4:	689a      	ldr	r2, [r3, #8]
 2f6:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
 2f8:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
 2fa:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
 2fc:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
 2fe:	3301      	adds	r3, #1
 300:	6003      	str	r3, [r0, #0]
}
 302:	4770      	bx	lr

00000304 <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 304:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
 308:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 30a:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 30c:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
 30e:	6859      	ldr	r1, [r3, #4]
 310:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 312:	bf08      	it	eq
 314:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 316:	2200      	movs	r2, #0
 318:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
 31a:	681a      	ldr	r2, [r3, #0]
 31c:	3a01      	subs	r2, #1
 31e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 320:	6818      	ldr	r0, [r3, #0]
}
 322:	4770      	bx	lr

00000324 <can_tx_done>:
 */
static void can_tx_done(struct _can_async_device *dev)
{
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.tx_done) {
 324:	69c3      	ldr	r3, [r0, #28]
 326:	b103      	cbz	r3, 32a <can_tx_done+0x6>
		descr->cb.tx_done(descr);
 328:	4718      	bx	r3
	}
}
 32a:	4770      	bx	lr

0000032c <can_rx_done>:
 */
static void can_rx_done(struct _can_async_device *dev)
{
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.rx_done) {
 32c:	6a03      	ldr	r3, [r0, #32]
 32e:	b103      	cbz	r3, 332 <can_rx_done+0x6>
		descr->cb.rx_done(descr);
 330:	4718      	bx	r3
	}
}
 332:	4770      	bx	lr

00000334 <can_irq_handler>:
 */
static void can_irq_handler(struct _can_async_device *dev, enum can_async_interrupt_type type)
{
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.irq_handler) {
 334:	6a43      	ldr	r3, [r0, #36]	; 0x24
 336:	b103      	cbz	r3, 33a <can_irq_handler+0x6>
		descr->cb.irq_handler(descr, type);
 338:	4718      	bx	r3
	}
}
 33a:	4770      	bx	lr

0000033c <can_async_init>:
{
 33c:	b538      	push	{r3, r4, r5, lr}
 33e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
 340:	4604      	mov	r4, r0
 342:	b110      	cbz	r0, 34a <can_async_init+0xe>
 344:	1e08      	subs	r0, r1, #0
 346:	bf18      	it	ne
 348:	2001      	movne	r0, #1
 34a:	4908      	ldr	r1, [pc, #32]	; (36c <can_async_init+0x30>)
 34c:	4b08      	ldr	r3, [pc, #32]	; (370 <can_async_init+0x34>)
 34e:	2241      	movs	r2, #65	; 0x41
 350:	4798      	blx	r3
	rc = _can_async_init(&descr->dev, hw);
 352:	4b08      	ldr	r3, [pc, #32]	; (374 <can_async_init+0x38>)
 354:	4629      	mov	r1, r5
 356:	4620      	mov	r0, r4
 358:	4798      	blx	r3
	if (rc) {
 35a:	b928      	cbnz	r0, 368 <can_async_init+0x2c>
	descr->dev.cb.tx_done     = can_tx_done;
 35c:	4b06      	ldr	r3, [pc, #24]	; (378 <can_async_init+0x3c>)
 35e:	6063      	str	r3, [r4, #4]
	descr->dev.cb.rx_done     = can_rx_done;
 360:	4b06      	ldr	r3, [pc, #24]	; (37c <can_async_init+0x40>)
 362:	60a3      	str	r3, [r4, #8]
	descr->dev.cb.irq_handler = can_irq_handler;
 364:	4b06      	ldr	r3, [pc, #24]	; (380 <can_async_init+0x44>)
 366:	60e3      	str	r3, [r4, #12]
}
 368:	bd38      	pop	{r3, r4, r5, pc}
 36a:	bf00      	nop
 36c:	00000b04 	.word	0x00000b04
 370:	000005f5 	.word	0x000005f5
 374:	00000385 	.word	0x00000385
 378:	00000325 	.word	0x00000325
 37c:	0000032d 	.word	0x0000032d
 380:	00000335 	.word	0x00000335

00000384 <_can_async_init>:
}

static inline void hri_can_set_CCCR_INIT_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_INIT;
 384:	698b      	ldr	r3, [r1, #24]
 386:	f043 0301 	orr.w	r3, r3, #1

/**
 * \brief Initialize CAN.
 */
int32_t _can_async_init(struct _can_async_device *const dev, void *const hw)
{
 38a:	b530      	push	{r4, r5, lr}
	dev->hw = hw;
 38c:	6001      	str	r1, [r0, #0]
 38e:	618b      	str	r3, [r1, #24]
}

static inline bool hri_can_get_CCCR_INIT_bit(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Can *)hw)->CCCR.reg;
 390:	698b      	ldr	r3, [r1, #24]
	hri_can_set_CCCR_INIT_bit(dev->hw);
	while (hri_can_get_CCCR_INIT_bit(dev->hw) == 0)
 392:	07db      	lsls	r3, r3, #31
 394:	d5fc      	bpl.n	390 <_can_async_init+0xc>
}

static inline void hri_can_set_CCCR_CCE_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_CCE;
 396:	698b      	ldr	r3, [r1, #24]
		;
	hri_can_set_CCCR_CCE_bit(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (hw == CAN0) {
 398:	f1b1 4f84 	cmp.w	r1, #1107296256	; 0x42000000
 39c:	f043 0302 	orr.w	r3, r3, #2
 3a0:	618b      	str	r3, [r1, #24]
 3a2:	d146      	bne.n	432 <_can_async_init+0xae>
		_can0_dev    = dev;
 3a4:	4b2a      	ldr	r3, [pc, #168]	; (450 <_can_async_init+0xcc>)
		dev->context = (void *)&_can0_context;
 3a6:	4c2b      	ldr	r4, [pc, #172]	; (454 <_can_async_init+0xd0>)
 3a8:	6184      	str	r4, [r0, #24]
		_can0_dev    = dev;
 3aa:	461a      	mov	r2, r3
}

static inline void hri_can_set_CCCR_reg(const void *const hw, hri_can_cccr_reg_t mask)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= mask;
 3ac:	698c      	ldr	r4, [r1, #24]
 3ae:	f842 0b04 	str.w	r0, [r2], #4
}

static inline void hri_can_write_NBTP_reg(const void *const hw, hri_can_nbtp_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->NBTP.reg = data;
 3b2:	4d29      	ldr	r5, [pc, #164]	; (458 <_can_async_init+0xd4>)
	((Can *)hw)->CCCR.reg |= mask;
 3b4:	618c      	str	r4, [r1, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN0_CCCR_REG);
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN0_MRCFG_REG);
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN0_BTP_REG);
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN0_DBTP_REG);
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN0_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can0_rx_fifo));
 3b6:	b292      	uxth	r2, r2
	((Can *)hw)->MRCFG.reg = data;
 3b8:	2400      	movs	r4, #0
 3ba:	608c      	str	r4, [r1, #8]
 3bc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Can *)hw)->NBTP.reg = data;
 3c0:	61cd      	str	r5, [r1, #28]
	((Can *)hw)->DBTP.reg = data;
 3c2:	f640 2533 	movw	r5, #2611	; 0xa33
 3c6:	60cd      	str	r5, [r1, #12]
}

static inline void hri_can_write_RXF0C_reg(const void *const hw, hri_can_rxf0c_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXF0C.reg = data;
 3c8:	f8c1 20a0 	str.w	r2, [r1, #160]	; 0xa0
		hri_can_write_RXESC_reg(dev->hw, CONF_CAN0_RXESC_REG);
		hri_can_write_TXESC_reg(dev->hw, CONF_CAN0_TXESC_REG);
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN0_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can0_tx_fifo));
 3cc:	f103 0224 	add.w	r2, r3, #36	; 0x24
 3d0:	b292      	uxth	r2, r2
 3d2:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
}

static inline void hri_can_write_RXESC_reg(const void *const hw, hri_can_rxesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXESC.reg = data;
 3d6:	f8c1 40bc 	str.w	r4, [r1, #188]	; 0xbc
}

static inline void hri_can_write_TXESC_reg(const void *const hw, hri_can_txesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXESC.reg = data;
 3da:	f8c1 40c8 	str.w	r4, [r1, #200]	; 0xc8
	((Can *)hw)->TXBC.reg = data;
 3de:	f8c1 20c0 	str.w	r2, [r1, #192]	; 0xc0
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN0_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can0_tx_event_fifo));
 3e2:	f103 0244 	add.w	r2, r3, #68	; 0x44
 3e6:	b292      	uxth	r2, r2
 3e8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
}

static inline void hri_can_write_TXEFC_reg(const void *const hw, hri_can_txefc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXEFC.reg = data;
 3ec:	f8c1 20f0 	str.w	r2, [r1, #240]	; 0xf0
	((Can *)hw)->GFC.reg = data;
 3f0:	2228      	movs	r2, #40	; 0x28
 3f2:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
		hri_can_write_GFC_reg(dev->hw, CONF_CAN0_GFC_REG);
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN0_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can0_rx_std_filter));
 3f6:	f103 0254 	add.w	r2, r3, #84	; 0x54
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN0_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can0_rx_ext_filter));
 3fa:	335c      	adds	r3, #92	; 0x5c
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN0_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can0_rx_std_filter));
 3fc:	b292      	uxth	r2, r2
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN0_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can0_rx_ext_filter));
 3fe:	b29b      	uxth	r3, r3
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN0_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can0_rx_std_filter));
 400:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN0_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can0_rx_ext_filter));
 404:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Can *)hw)->SIDFC.reg = data;
 408:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
	((Can *)hw)->XIDFC.reg = data;
 40c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 410:	4b12      	ldr	r3, [pc, #72]	; (45c <_can_async_init+0xd8>)
	((Can *)hw)->XIDAM.reg = data;
 412:	f8c1 4090 	str.w	r4, [r1, #144]	; 0x90
 416:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 41a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 41e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 422:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 426:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 42a:	609a      	str	r2, [r3, #8]
		hri_can_write_XIDAM_reg(dev->hw, CONF_CAN0_XIDAM_REG);

		NVIC_DisableIRQ(CAN0_IRQn);
		NVIC_ClearPendingIRQ(CAN0_IRQn);
		NVIC_EnableIRQ(CAN0_IRQn);
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
 42c:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->ILE.reg = data;
 42e:	2201      	movs	r2, #1
 430:	65da      	str	r2, [r3, #92]	; 0x5c
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

	/* Disable CCE to prevent Configuration Change */
	hri_can_clear_CCCR_CCE_bit(dev->hw);
 432:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_CCE;
 434:	699a      	ldr	r2, [r3, #24]
 436:	f022 0202 	bic.w	r2, r2, #2
 43a:	619a      	str	r2, [r3, #24]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
 43c:	699a      	ldr	r2, [r3, #24]
 43e:	f022 0201 	bic.w	r2, r2, #1
 442:	619a      	str	r2, [r3, #24]
	tmp = ((Can *)hw)->CCCR.reg;
 444:	6998      	ldr	r0, [r3, #24]
	hri_can_clear_CCCR_INIT_bit(dev->hw);
	while (hri_can_get_CCCR_INIT_bit(dev->hw)) {
 446:	f010 0001 	ands.w	r0, r0, #1
 44a:	d1fb      	bne.n	444 <_can_async_init+0xc0>
	};

	return ERR_NONE;
}
 44c:	bd30      	pop	{r4, r5, pc}
 44e:	bf00      	nop
 450:	20000030 	.word	0x20000030
 454:	20000000 	.word	0x20000000
 458:	06020a07 	.word	0x06020a07
 45c:	e000e100 	.word	0xe000e100

00000460 <CAN0_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN0_Handler(void)
{
 460:	b538      	push	{r3, r4, r5, lr}
	struct _can_async_device *dev = _can0_dev;
 462:	4b17      	ldr	r3, [pc, #92]	; (4c0 <CAN0_Handler+0x60>)
 464:	681c      	ldr	r4, [r3, #0]
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
 466:	6823      	ldr	r3, [r4, #0]
	return ((Can *)hw)->IR.reg;
 468:	6d1d      	ldr	r5, [r3, #80]	; 0x50

	if (ir & CAN_IR_RF0N) {
 46a:	07e8      	lsls	r0, r5, #31
 46c:	d502      	bpl.n	474 <CAN0_Handler+0x14>
		dev->cb.rx_done(dev);
 46e:	68a3      	ldr	r3, [r4, #8]
 470:	4620      	mov	r0, r4
 472:	4798      	blx	r3
	}

	if (ir & CAN_IR_TC) {
 474:	05aa      	lsls	r2, r5, #22
 476:	d502      	bpl.n	47e <CAN0_Handler+0x1e>
		dev->cb.tx_done(dev);
 478:	6863      	ldr	r3, [r4, #4]
 47a:	4620      	mov	r0, r4
 47c:	4798      	blx	r3
	}

	if (ir & CAN_IR_BO) {
 47e:	01ab      	lsls	r3, r5, #6
 480:	d503      	bpl.n	48a <CAN0_Handler+0x2a>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
 482:	68e3      	ldr	r3, [r4, #12]
 484:	2103      	movs	r1, #3
 486:	4620      	mov	r0, r4
 488:	4798      	blx	r3
	}

	if (ir & CAN_IR_EW) {
 48a:	01e8      	lsls	r0, r5, #7
 48c:	d503      	bpl.n	496 <CAN0_Handler+0x36>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
 48e:	68e3      	ldr	r3, [r4, #12]
 490:	2100      	movs	r1, #0
 492:	4620      	mov	r0, r4
 494:	4798      	blx	r3
	}

	if (ir & CAN_IR_EP) {
 496:	022a      	lsls	r2, r5, #8
 498:	d509      	bpl.n	4ae <CAN0_Handler+0x4e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
 49a:	6822      	ldr	r2, [r4, #0]
 49c:	68e3      	ldr	r3, [r4, #12]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
 49e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 4a0:	f012 0f20 	tst.w	r2, #32
 4a4:	bf14      	ite	ne
 4a6:	2102      	movne	r1, #2
 4a8:	2101      	moveq	r1, #1
 4aa:	4620      	mov	r0, r4
 4ac:	4798      	blx	r3
	}

	if (ir & CAN_IR_RF0L) {
 4ae:	072b      	lsls	r3, r5, #28
 4b0:	d503      	bpl.n	4ba <CAN0_Handler+0x5a>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
 4b2:	68e3      	ldr	r3, [r4, #12]
 4b4:	2104      	movs	r1, #4
 4b6:	4620      	mov	r0, r4
 4b8:	4798      	blx	r3
	}

	hri_can_write_IR_reg(dev->hw, ir);
 4ba:	6823      	ldr	r3, [r4, #0]
	((Can *)hw)->IR.reg = data;
 4bc:	651d      	str	r5, [r3, #80]	; 0x50
}
 4be:	bd38      	pop	{r3, r4, r5, pc}
 4c0:	20000030 	.word	0x20000030
	...

000004d0 <SVCall_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler(void)
{
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
 4d0:	4b07      	ldr	r3, [pc, #28]	; (4f0 <pxCurrentTCBConst2>)
 4d2:	6819      	ldr	r1, [r3, #0]
 4d4:	6808      	ldr	r0, [r1, #0]
 4d6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4da:	f380 8809 	msr	PSP, r0
 4de:	f3bf 8f6f 	isb	sy
 4e2:	f04f 0000 	mov.w	r0, #0
 4e6:	f380 8811 	msr	BASEPRI, r0
 4ea:	4770      	bx	lr
 4ec:	f3af 8000 	nop.w

000004f0 <pxCurrentTCBConst2>:
 4f0:	2000013c 	.word	0x2000013c
	...

00000500 <PendSV_Handler>:

void xPortPendSVHandler(void)
{
	/* This is a naked function. */

	__asm volatile(
 500:	f3ef 8009 	mrs	r0, PSP
 504:	f3bf 8f6f 	isb	sy
 508:	4b15      	ldr	r3, [pc, #84]	; (560 <pxCurrentTCBConst>)
 50a:	681a      	ldr	r2, [r3, #0]
 50c:	f01e 0f10 	tst.w	lr, #16
 510:	bf08      	it	eq
 512:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 516:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 51a:	6010      	str	r0, [r2, #0]
 51c:	e92d 0009 	stmdb	sp!, {r0, r3}
 520:	f04f 0080 	mov.w	r0, #128	; 0x80
 524:	f380 8811 	msr	BASEPRI, r0
 528:	f3bf 8f4f 	dsb	sy
 52c:	f3bf 8f6f 	isb	sy
 530:	f000 f9a4 	bl	87c <vTaskSwitchContext>
 534:	f04f 0000 	mov.w	r0, #0
 538:	f380 8811 	msr	BASEPRI, r0
 53c:	bc09      	pop	{r0, r3}
 53e:	6819      	ldr	r1, [r3, #0]
 540:	6808      	ldr	r0, [r1, #0]
 542:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 546:	f01e 0f10 	tst.w	lr, #16
 54a:	bf08      	it	eq
 54c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 550:	f380 8809 	msr	PSP, r0
 554:	f3bf 8f6f 	isb	sy
 558:	4770      	bx	lr
 55a:	bf00      	nop
 55c:	f3af 8000 	nop.w

00000560 <pxCurrentTCBConst>:
 560:	2000013c 	.word	0x2000013c

00000564 <SysTick_Handler>:
	    "pxCurrentTCBConst: .word pxCurrentTCB	\n" ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY));
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler(void)
{
 564:	b508      	push	{r3, lr}

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
 566:	f04f 0380 	mov.w	r3, #128	; 0x80
 56a:	f383 8811 	msr	BASEPRI, r3
 56e:	f3bf 8f6f 	isb	sy
 572:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE) {
 576:	4b06      	ldr	r3, [pc, #24]	; (590 <SysTick_Handler+0x2c>)
 578:	4798      	blx	r3
 57a:	b128      	cbz	r0, 588 <SysTick_Handler+0x24>
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 57c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 580:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 584:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
 588:	2300      	movs	r3, #0
 58a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 58e:	bd08      	pop	{r3, pc}
 590:	00000781 	.word	0x00000781

00000594 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
 594:	4a09      	ldr	r2, [pc, #36]	; (5bc <_init_chip+0x28>)
 596:	8813      	ldrh	r3, [r2, #0]

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 598:	b510      	push	{r4, lr}
 59a:	b29b      	uxth	r3, r3
 59c:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
 59e:	4b08      	ldr	r3, [pc, #32]	; (5c0 <_init_chip+0x2c>)
 5a0:	4798      	blx	r3
	_oscctrl_init_sources();
 5a2:	4b08      	ldr	r3, [pc, #32]	; (5c4 <_init_chip+0x30>)
 5a4:	4798      	blx	r3
	_mclk_init();
 5a6:	4b08      	ldr	r3, [pc, #32]	; (5c8 <_init_chip+0x34>)
 5a8:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
 5aa:	4b08      	ldr	r3, [pc, #32]	; (5cc <_init_chip+0x38>)
 5ac:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
 5ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 5b2:	4b07      	ldr	r3, [pc, #28]	; (5d0 <_init_chip+0x3c>)
 5b4:	f640 70ff 	movw	r0, #4095	; 0xfff
 5b8:	4718      	bx	r3
 5ba:	bf00      	nop
 5bc:	41004000 	.word	0x41004000
 5c0:	0000065d 	.word	0x0000065d
 5c4:	000005fd 	.word	0x000005fd
 5c8:	00000619 	.word	0x00000619
 5cc:	00000615 	.word	0x00000615
 5d0:	000005d5 	.word	0x000005d5

000005d4 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 5d4:	07c3      	lsls	r3, r0, #31
 5d6:	d507      	bpl.n	5e8 <_gclk_init_generators_by_fref+0x14>
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
 5d8:	4b04      	ldr	r3, [pc, #16]	; (5ec <_gclk_init_generators_by_fref+0x18>)
 5da:	4a05      	ldr	r2, [pc, #20]	; (5f0 <_gclk_init_generators_by_fref+0x1c>)
 5dc:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
 5de:	f643 72fd 	movw	r2, #16381	; 0x3ffd
 5e2:	6859      	ldr	r1, [r3, #4]
 5e4:	4211      	tst	r1, r2
 5e6:	d1fc      	bne.n	5e2 <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
 5e8:	4770      	bx	lr
 5ea:	bf00      	nop
 5ec:	40001c00 	.word	0x40001c00
 5f0:	00010101 	.word	0x00010101

000005f4 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
 5f4:	b900      	cbnz	r0, 5f8 <assert+0x4>
		__asm("BKPT #0");
 5f6:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
 5f8:	4770      	bx	lr
	...

000005fc <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
 5fc:	4b03      	ldr	r3, [pc, #12]	; (60c <_oscctrl_init_sources+0x10>)
 5fe:	4a04      	ldr	r2, [pc, #16]	; (610 <_oscctrl_init_sources+0x14>)
 600:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
 602:	691a      	ldr	r2, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
 604:	0792      	lsls	r2, r2, #30
 606:	d5fc      	bpl.n	602 <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
 608:	4770      	bx	lr
 60a:	bf00      	nop
 60c:	40001000 	.word	0x40001000
 610:	03002606 	.word	0x03002606

00000614 <_oscctrl_init_referenced_generators>:
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
 614:	4770      	bx	lr
	...

00000618 <_mclk_init>:
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
 618:	4b01      	ldr	r3, [pc, #4]	; (620 <_mclk_init+0x8>)
 61a:	2201      	movs	r2, #1
 61c:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
 61e:	4770      	bx	lr
 620:	40000800 	.word	0x40000800

00000624 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
 624:	4a0b      	ldr	r2, [pc, #44]	; (654 <RAMECC_Handler+0x30>)
 626:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
 628:	b082      	sub	sp, #8
 62a:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
 62c:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
 62e:	9b01      	ldr	r3, [sp, #4]
 630:	0799      	lsls	r1, r3, #30
 632:	d505      	bpl.n	640 <RAMECC_Handler+0x1c>
 634:	4b08      	ldr	r3, [pc, #32]	; (658 <RAMECC_Handler+0x34>)
 636:	681b      	ldr	r3, [r3, #0]
 638:	b113      	cbz	r3, 640 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
 63a:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
 63c:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
 63e:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
 640:	9b01      	ldr	r3, [sp, #4]
 642:	07db      	lsls	r3, r3, #31
 644:	d504      	bpl.n	650 <RAMECC_Handler+0x2c>
 646:	4b04      	ldr	r3, [pc, #16]	; (658 <RAMECC_Handler+0x34>)
 648:	685b      	ldr	r3, [r3, #4]
 64a:	b10b      	cbz	r3, 650 <RAMECC_Handler+0x2c>
 64c:	4a01      	ldr	r2, [pc, #4]	; (654 <RAMECC_Handler+0x30>)
 64e:	e7f4      	b.n	63a <RAMECC_Handler+0x16>
}
 650:	b002      	add	sp, #8
 652:	4770      	bx	lr
 654:	41020000 	.word	0x41020000
 658:	2000009c 	.word	0x2000009c

0000065c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
 65c:	4b03      	ldr	r3, [pc, #12]	; (66c <_osc32kctrl_init_sources+0x10>)
 65e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
 660:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
 664:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
 666:	2201      	movs	r2, #1
 668:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
 66a:	4770      	bx	lr
 66c:	40001400 	.word	0x40001400

00000670 <CAN_0_init>:
}

static inline void hri_mclk_set_AHBMASK_CAN0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN0;
 670:	4a06      	ldr	r2, [pc, #24]	; (68c <CAN_0_init+0x1c>)
 */
void CAN_0_init(void)
{
	hri_mclk_set_AHBMASK_CAN0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN0_GCLK_ID, CONF_GCLK_CAN0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	can_async_init(&CAN_0, CAN0);
 672:	4807      	ldr	r0, [pc, #28]	; (690 <CAN_0_init+0x20>)
 674:	6913      	ldr	r3, [r2, #16]
 676:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 67a:	6113      	str	r3, [r2, #16]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
 67c:	4b05      	ldr	r3, [pc, #20]	; (694 <CAN_0_init+0x24>)
 67e:	2240      	movs	r2, #64	; 0x40
 680:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
 684:	f04f 4184 	mov.w	r1, #1107296256	; 0x42000000
 688:	4b03      	ldr	r3, [pc, #12]	; (698 <CAN_0_init+0x28>)
 68a:	4718      	bx	r3
 68c:	40000800 	.word	0x40000800
 690:	200000ac 	.word	0x200000ac
 694:	40001c00 	.word	0x40001c00
 698:	0000033d 	.word	0x0000033d

0000069c <system_init>:
	CAN_0_PORT_init();
}

void system_init(void)
{
 69c:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
 69e:	4b03      	ldr	r3, [pc, #12]	; (6ac <system_init+0x10>)
 6a0:	4798      	blx	r3
	init_mcu();

	CAN_0_init();
}
 6a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	CAN_0_init();
 6a6:	4b02      	ldr	r3, [pc, #8]	; (6b0 <system_init+0x14>)
 6a8:	4718      	bx	r3
 6aa:	bf00      	nop
 6ac:	00000595 	.word	0x00000595
 6b0:	00000671 	.word	0x00000671

000006b4 <main>:
#include <atmel_start.h>

int main(void)
{
 6b4:	b508      	push	{r3, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 6b6:	4b01      	ldr	r3, [pc, #4]	; (6bc <main+0x8>)
 6b8:	4798      	blx	r3

	/* Replace with your application code */
	while (1) {
 6ba:	e7fe      	b.n	6ba <main+0x6>
 6bc:	000006c1 	.word	0x000006c1

000006c0 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
 6c0:	4b00      	ldr	r3, [pc, #0]	; (6c4 <atmel_start_init+0x4>)
 6c2:	4718      	bx	r3
 6c4:	0000069d 	.word	0x0000069d

000006c8 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
 6c8:	e7fe      	b.n	6c8 <Dummy_Handler>
	...

000006cc <Reset_Handler>:
	if (pSrc != pDest) {
 6cc:	4918      	ldr	r1, [pc, #96]	; (730 <Reset_Handler+0x64>)
 6ce:	4819      	ldr	r0, [pc, #100]	; (734 <Reset_Handler+0x68>)
 6d0:	4281      	cmp	r1, r0
{
 6d2:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
 6d4:	d00a      	beq.n	6ec <Reset_Handler+0x20>
			*pDest++ = *pSrc++;
 6d6:	4b18      	ldr	r3, [pc, #96]	; (738 <Reset_Handler+0x6c>)
 6d8:	1cda      	adds	r2, r3, #3
 6da:	1a12      	subs	r2, r2, r0
 6dc:	f022 0203 	bic.w	r2, r2, #3
 6e0:	1ec4      	subs	r4, r0, #3
 6e2:	42a3      	cmp	r3, r4
 6e4:	bf38      	it	cc
 6e6:	2200      	movcc	r2, #0
 6e8:	4b14      	ldr	r3, [pc, #80]	; (73c <Reset_Handler+0x70>)
 6ea:	4798      	blx	r3
		*pDest++ = 0;
 6ec:	4b14      	ldr	r3, [pc, #80]	; (740 <Reset_Handler+0x74>)
 6ee:	4815      	ldr	r0, [pc, #84]	; (744 <Reset_Handler+0x78>)
 6f0:	1cda      	adds	r2, r3, #3
 6f2:	1a12      	subs	r2, r2, r0
 6f4:	1ec1      	subs	r1, r0, #3
 6f6:	f022 0203 	bic.w	r2, r2, #3
 6fa:	4299      	cmp	r1, r3
 6fc:	bf88      	it	hi
 6fe:	2200      	movhi	r2, #0
 700:	4b11      	ldr	r3, [pc, #68]	; (748 <Reset_Handler+0x7c>)
 702:	2100      	movs	r1, #0
 704:	4798      	blx	r3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
 706:	4a11      	ldr	r2, [pc, #68]	; (74c <Reset_Handler+0x80>)
 708:	4b11      	ldr	r3, [pc, #68]	; (750 <Reset_Handler+0x84>)
 70a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 70e:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
 710:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 714:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 718:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
 71c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 720:	f3bf 8f6f 	isb	sy
	__libc_init_array();
 724:	4b0b      	ldr	r3, [pc, #44]	; (754 <Reset_Handler+0x88>)
 726:	4798      	blx	r3
	main();
 728:	4b0b      	ldr	r3, [pc, #44]	; (758 <Reset_Handler+0x8c>)
 72a:	4798      	blx	r3
	while (1)
 72c:	e7fe      	b.n	72c <Reset_Handler+0x60>
 72e:	bf00      	nop
 730:	00000b40 	.word	0x00000b40
 734:	20000000 	.word	0x20000000
 738:	20000014 	.word	0x20000014
 73c:	0000092d 	.word	0x0000092d
 740:	200001c0 	.word	0x200001c0
 744:	20000014 	.word	0x20000014
 748:	00000a61 	.word	0x00000a61
 74c:	00000000 	.word	0x00000000
 750:	e000ed00 	.word	0xe000ed00
 754:	000008e5 	.word	0x000008e5
 758:	000006b5 	.word	0x000006b5

0000075c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
 75c:	4b07      	ldr	r3, [pc, #28]	; (77c <prvResetNextTaskUnblockTime+0x20>)
 75e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 762:	6812      	ldr	r2, [r2, #0]
 764:	b922      	cbnz	r2, 770 <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 766:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
 76a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	}
}
 76e:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
 770:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 774:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
 776:	68d2      	ldr	r2, [r2, #12]
 778:	6852      	ldr	r2, [r2, #4]
 77a:	e7f6      	b.n	76a <prvResetNextTaskUnblockTime+0xe>
 77c:	200000d4 	.word	0x200000d4

00000780 <xTaskIncrementTick>:
{
 780:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
 784:	4c39      	ldr	r4, [pc, #228]	; (86c <xTaskIncrementTick+0xec>)
 786:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 78a:	2b00      	cmp	r3, #0
 78c:	d166      	bne.n	85c <xTaskIncrementTick+0xdc>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
 78e:	6e67      	ldr	r7, [r4, #100]	; 0x64
 790:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
 792:	6667      	str	r7, [r4, #100]	; 0x64
		if (xConstTickCount
 794:	b9df      	cbnz	r7, 7ce <xTaskIncrementTick+0x4e>
			taskSWITCH_DELAYED_LISTS();
 796:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 79a:	681b      	ldr	r3, [r3, #0]
 79c:	b143      	cbz	r3, 7b0 <xTaskIncrementTick+0x30>
	__asm volatile("	mov %0, %1												\n"
 79e:	f04f 0380 	mov.w	r3, #128	; 0x80
 7a2:	f383 8811 	msr	BASEPRI, r3
 7a6:	f3bf 8f6f 	isb	sy
 7aa:	f3bf 8f4f 	dsb	sy
 7ae:	e7fe      	b.n	7ae <xTaskIncrementTick+0x2e>
 7b0:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 7b4:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 7b8:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
 7bc:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 7c0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 7c4:	3301      	adds	r3, #1
 7c6:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 7ca:	4b29      	ldr	r3, [pc, #164]	; (870 <xTaskIncrementTick+0xf0>)
 7cc:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
 7ce:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 7d2:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
 7d4:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
 7d8:	d90f      	bls.n	7fa <xTaskIncrementTick+0x7a>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
 7da:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 7dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 7de:	2214      	movs	r2, #20
 7e0:	4353      	muls	r3, r2
 7e2:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
 7e4:	2b02      	cmp	r3, #2
 7e6:	bf28      	it	cs
 7e8:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
 7ea:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
			xSwitchRequired = pdTRUE;
 7ee:	2b00      	cmp	r3, #0
}
 7f0:	bf0c      	ite	eq
 7f2:	4628      	moveq	r0, r5
 7f4:	2001      	movne	r0, #1
 7f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
 7fa:	f8df 8078 	ldr.w	r8, [pc, #120]	; 874 <xTaskIncrementTick+0xf4>
					prvAddTaskToReadyList(pxTCB);
 7fe:	f8df 9078 	ldr.w	r9, [pc, #120]	; 878 <xTaskIncrementTick+0xf8>
 802:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
 806:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 80a:	681b      	ldr	r3, [r3, #0]
 80c:	b923      	cbnz	r3, 818 <xTaskIncrementTick+0x98>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
 812:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
						break;
 816:	e7e0      	b.n	7da <xTaskIncrementTick+0x5a>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
 818:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 81c:	68db      	ldr	r3, [r3, #12]
 81e:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
 820:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
 822:	429f      	cmp	r7, r3
 824:	d3f5      	bcc.n	812 <xTaskIncrementTick+0x92>
					(void)uxListRemove(&(pxTCB->xStateListItem));
 826:	f106 0b04 	add.w	fp, r6, #4
 82a:	4658      	mov	r0, fp
 82c:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
 82e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 830:	b113      	cbz	r3, 838 <xTaskIncrementTick+0xb8>
						(void)uxListRemove(&(pxTCB->xEventListItem));
 832:	f106 0018 	add.w	r0, r6, #24
 836:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
 838:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 83a:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 83e:	4298      	cmp	r0, r3
 840:	bf88      	it	hi
 842:	f8c4 00d4 	strhi.w	r0, [r4, #212]	; 0xd4
 846:	4659      	mov	r1, fp
 848:	fb0a 4000 	mla	r0, sl, r0, r4
 84c:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
 84e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 850:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 852:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 854:	429a      	cmp	r2, r3
 856:	bf28      	it	cs
 858:	2501      	movcs	r5, #1
 85a:	e7d4      	b.n	806 <xTaskIncrementTick+0x86>
		++uxPendedTicks;
 85c:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 860:	3301      	adds	r3, #1
 862:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
 866:	2500      	movs	r5, #0
 868:	e7bf      	b.n	7ea <xTaskIncrementTick+0x6a>
 86a:	bf00      	nop
 86c:	200000d4 	.word	0x200000d4
 870:	0000075d 	.word	0x0000075d
 874:	00000305 	.word	0x00000305
 878:	000002ed 	.word	0x000002ed

0000087c <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
 87c:	4b18      	ldr	r3, [pc, #96]	; (8e0 <vTaskSwitchContext+0x64>)
 87e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
{
 882:	b530      	push	{r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
 884:	b11a      	cbz	r2, 88e <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 886:	2201      	movs	r2, #1
 888:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
}
 88c:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
 88e:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
 892:	f8d3 10d4 	ldr.w	r1, [r3, #212]	; 0xd4
 896:	2514      	movs	r5, #20
 898:	fb05 f201 	mul.w	r2, r5, r1
 89c:	1898      	adds	r0, r3, r2
 89e:	589c      	ldr	r4, [r3, r2]
 8a0:	b18c      	cbz	r4, 8c6 <vTaskSwitchContext+0x4a>
 8a2:	6844      	ldr	r4, [r0, #4]
 8a4:	3208      	adds	r2, #8
 8a6:	6864      	ldr	r4, [r4, #4]
 8a8:	6044      	str	r4, [r0, #4]
 8aa:	441a      	add	r2, r3
 8ac:	4294      	cmp	r4, r2
 8ae:	bf04      	itt	eq
 8b0:	6862      	ldreq	r2, [r4, #4]
 8b2:	6042      	streq	r2, [r0, #4]
 8b4:	2214      	movs	r2, #20
 8b6:	fb02 3201 	mla	r2, r2, r1, r3
 8ba:	6852      	ldr	r2, [r2, #4]
 8bc:	68d2      	ldr	r2, [r2, #12]
 8be:	669a      	str	r2, [r3, #104]	; 0x68
 8c0:	f8c3 10d4 	str.w	r1, [r3, #212]	; 0xd4
}
 8c4:	e7e2      	b.n	88c <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8c6:	b941      	cbnz	r1, 8da <vTaskSwitchContext+0x5e>
 8c8:	f04f 0380 	mov.w	r3, #128	; 0x80
 8cc:	f383 8811 	msr	BASEPRI, r3
 8d0:	f3bf 8f6f 	isb	sy
 8d4:	f3bf 8f4f 	dsb	sy
 8d8:	e7fe      	b.n	8d8 <vTaskSwitchContext+0x5c>
 8da:	3901      	subs	r1, #1
 8dc:	e7dc      	b.n	898 <vTaskSwitchContext+0x1c>
 8de:	bf00      	nop
 8e0:	200000d4 	.word	0x200000d4

000008e4 <__libc_init_array>:
 8e4:	b570      	push	{r4, r5, r6, lr}
 8e6:	4e0d      	ldr	r6, [pc, #52]	; (91c <__libc_init_array+0x38>)
 8e8:	4d0d      	ldr	r5, [pc, #52]	; (920 <__libc_init_array+0x3c>)
 8ea:	1b76      	subs	r6, r6, r5
 8ec:	10b6      	asrs	r6, r6, #2
 8ee:	d006      	beq.n	8fe <__libc_init_array+0x1a>
 8f0:	2400      	movs	r4, #0
 8f2:	f855 3b04 	ldr.w	r3, [r5], #4
 8f6:	3401      	adds	r4, #1
 8f8:	4798      	blx	r3
 8fa:	42a6      	cmp	r6, r4
 8fc:	d1f9      	bne.n	8f2 <__libc_init_array+0xe>
 8fe:	4e09      	ldr	r6, [pc, #36]	; (924 <__libc_init_array+0x40>)
 900:	4d09      	ldr	r5, [pc, #36]	; (928 <__libc_init_array+0x44>)
 902:	1b76      	subs	r6, r6, r5
 904:	f000 f90c 	bl	b20 <_init>
 908:	10b6      	asrs	r6, r6, #2
 90a:	d006      	beq.n	91a <__libc_init_array+0x36>
 90c:	2400      	movs	r4, #0
 90e:	f855 3b04 	ldr.w	r3, [r5], #4
 912:	3401      	adds	r4, #1
 914:	4798      	blx	r3
 916:	42a6      	cmp	r6, r4
 918:	d1f9      	bne.n	90e <__libc_init_array+0x2a>
 91a:	bd70      	pop	{r4, r5, r6, pc}
 91c:	00000b2c 	.word	0x00000b2c
 920:	00000b2c 	.word	0x00000b2c
 924:	00000b30 	.word	0x00000b30
 928:	00000b2c 	.word	0x00000b2c

0000092c <memcpy>:
 92c:	4684      	mov	ip, r0
 92e:	ea41 0300 	orr.w	r3, r1, r0
 932:	f013 0303 	ands.w	r3, r3, #3
 936:	d16d      	bne.n	a14 <memcpy+0xe8>
 938:	3a40      	subs	r2, #64	; 0x40
 93a:	d341      	bcc.n	9c0 <memcpy+0x94>
 93c:	f851 3b04 	ldr.w	r3, [r1], #4
 940:	f840 3b04 	str.w	r3, [r0], #4
 944:	f851 3b04 	ldr.w	r3, [r1], #4
 948:	f840 3b04 	str.w	r3, [r0], #4
 94c:	f851 3b04 	ldr.w	r3, [r1], #4
 950:	f840 3b04 	str.w	r3, [r0], #4
 954:	f851 3b04 	ldr.w	r3, [r1], #4
 958:	f840 3b04 	str.w	r3, [r0], #4
 95c:	f851 3b04 	ldr.w	r3, [r1], #4
 960:	f840 3b04 	str.w	r3, [r0], #4
 964:	f851 3b04 	ldr.w	r3, [r1], #4
 968:	f840 3b04 	str.w	r3, [r0], #4
 96c:	f851 3b04 	ldr.w	r3, [r1], #4
 970:	f840 3b04 	str.w	r3, [r0], #4
 974:	f851 3b04 	ldr.w	r3, [r1], #4
 978:	f840 3b04 	str.w	r3, [r0], #4
 97c:	f851 3b04 	ldr.w	r3, [r1], #4
 980:	f840 3b04 	str.w	r3, [r0], #4
 984:	f851 3b04 	ldr.w	r3, [r1], #4
 988:	f840 3b04 	str.w	r3, [r0], #4
 98c:	f851 3b04 	ldr.w	r3, [r1], #4
 990:	f840 3b04 	str.w	r3, [r0], #4
 994:	f851 3b04 	ldr.w	r3, [r1], #4
 998:	f840 3b04 	str.w	r3, [r0], #4
 99c:	f851 3b04 	ldr.w	r3, [r1], #4
 9a0:	f840 3b04 	str.w	r3, [r0], #4
 9a4:	f851 3b04 	ldr.w	r3, [r1], #4
 9a8:	f840 3b04 	str.w	r3, [r0], #4
 9ac:	f851 3b04 	ldr.w	r3, [r1], #4
 9b0:	f840 3b04 	str.w	r3, [r0], #4
 9b4:	f851 3b04 	ldr.w	r3, [r1], #4
 9b8:	f840 3b04 	str.w	r3, [r0], #4
 9bc:	3a40      	subs	r2, #64	; 0x40
 9be:	d2bd      	bcs.n	93c <memcpy+0x10>
 9c0:	3230      	adds	r2, #48	; 0x30
 9c2:	d311      	bcc.n	9e8 <memcpy+0xbc>
 9c4:	f851 3b04 	ldr.w	r3, [r1], #4
 9c8:	f840 3b04 	str.w	r3, [r0], #4
 9cc:	f851 3b04 	ldr.w	r3, [r1], #4
 9d0:	f840 3b04 	str.w	r3, [r0], #4
 9d4:	f851 3b04 	ldr.w	r3, [r1], #4
 9d8:	f840 3b04 	str.w	r3, [r0], #4
 9dc:	f851 3b04 	ldr.w	r3, [r1], #4
 9e0:	f840 3b04 	str.w	r3, [r0], #4
 9e4:	3a10      	subs	r2, #16
 9e6:	d2ed      	bcs.n	9c4 <memcpy+0x98>
 9e8:	320c      	adds	r2, #12
 9ea:	d305      	bcc.n	9f8 <memcpy+0xcc>
 9ec:	f851 3b04 	ldr.w	r3, [r1], #4
 9f0:	f840 3b04 	str.w	r3, [r0], #4
 9f4:	3a04      	subs	r2, #4
 9f6:	d2f9      	bcs.n	9ec <memcpy+0xc0>
 9f8:	3204      	adds	r2, #4
 9fa:	d008      	beq.n	a0e <memcpy+0xe2>
 9fc:	07d2      	lsls	r2, r2, #31
 9fe:	bf1c      	itt	ne
 a00:	f811 3b01 	ldrbne.w	r3, [r1], #1
 a04:	f800 3b01 	strbne.w	r3, [r0], #1
 a08:	d301      	bcc.n	a0e <memcpy+0xe2>
 a0a:	880b      	ldrh	r3, [r1, #0]
 a0c:	8003      	strh	r3, [r0, #0]
 a0e:	4660      	mov	r0, ip
 a10:	4770      	bx	lr
 a12:	bf00      	nop
 a14:	2a08      	cmp	r2, #8
 a16:	d313      	bcc.n	a40 <memcpy+0x114>
 a18:	078b      	lsls	r3, r1, #30
 a1a:	d08d      	beq.n	938 <memcpy+0xc>
 a1c:	f010 0303 	ands.w	r3, r0, #3
 a20:	d08a      	beq.n	938 <memcpy+0xc>
 a22:	f1c3 0304 	rsb	r3, r3, #4
 a26:	1ad2      	subs	r2, r2, r3
 a28:	07db      	lsls	r3, r3, #31
 a2a:	bf1c      	itt	ne
 a2c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 a30:	f800 3b01 	strbne.w	r3, [r0], #1
 a34:	d380      	bcc.n	938 <memcpy+0xc>
 a36:	f831 3b02 	ldrh.w	r3, [r1], #2
 a3a:	f820 3b02 	strh.w	r3, [r0], #2
 a3e:	e77b      	b.n	938 <memcpy+0xc>
 a40:	3a04      	subs	r2, #4
 a42:	d3d9      	bcc.n	9f8 <memcpy+0xcc>
 a44:	3a01      	subs	r2, #1
 a46:	f811 3b01 	ldrb.w	r3, [r1], #1
 a4a:	f800 3b01 	strb.w	r3, [r0], #1
 a4e:	d2f9      	bcs.n	a44 <memcpy+0x118>
 a50:	780b      	ldrb	r3, [r1, #0]
 a52:	7003      	strb	r3, [r0, #0]
 a54:	784b      	ldrb	r3, [r1, #1]
 a56:	7043      	strb	r3, [r0, #1]
 a58:	788b      	ldrb	r3, [r1, #2]
 a5a:	7083      	strb	r3, [r0, #2]
 a5c:	4660      	mov	r0, ip
 a5e:	4770      	bx	lr

00000a60 <memset>:
 a60:	0783      	lsls	r3, r0, #30
 a62:	b530      	push	{r4, r5, lr}
 a64:	d048      	beq.n	af8 <memset+0x98>
 a66:	1e54      	subs	r4, r2, #1
 a68:	2a00      	cmp	r2, #0
 a6a:	d03f      	beq.n	aec <memset+0x8c>
 a6c:	b2ca      	uxtb	r2, r1
 a6e:	4603      	mov	r3, r0
 a70:	e001      	b.n	a76 <memset+0x16>
 a72:	3c01      	subs	r4, #1
 a74:	d33a      	bcc.n	aec <memset+0x8c>
 a76:	f803 2b01 	strb.w	r2, [r3], #1
 a7a:	079d      	lsls	r5, r3, #30
 a7c:	d1f9      	bne.n	a72 <memset+0x12>
 a7e:	2c03      	cmp	r4, #3
 a80:	d92d      	bls.n	ade <memset+0x7e>
 a82:	b2cd      	uxtb	r5, r1
 a84:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 a88:	2c0f      	cmp	r4, #15
 a8a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 a8e:	d936      	bls.n	afe <memset+0x9e>
 a90:	f1a4 0210 	sub.w	r2, r4, #16
 a94:	f022 0c0f 	bic.w	ip, r2, #15
 a98:	f103 0e20 	add.w	lr, r3, #32
 a9c:	44e6      	add	lr, ip
 a9e:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 aa2:	f103 0210 	add.w	r2, r3, #16
 aa6:	e942 5504 	strd	r5, r5, [r2, #-16]
 aaa:	e942 5502 	strd	r5, r5, [r2, #-8]
 aae:	3210      	adds	r2, #16
 ab0:	4572      	cmp	r2, lr
 ab2:	d1f8      	bne.n	aa6 <memset+0x46>
 ab4:	f10c 0201 	add.w	r2, ip, #1
 ab8:	f014 0f0c 	tst.w	r4, #12
 abc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 ac0:	f004 0c0f 	and.w	ip, r4, #15
 ac4:	d013      	beq.n	aee <memset+0x8e>
 ac6:	f1ac 0304 	sub.w	r3, ip, #4
 aca:	f023 0303 	bic.w	r3, r3, #3
 ace:	3304      	adds	r3, #4
 ad0:	4413      	add	r3, r2
 ad2:	f842 5b04 	str.w	r5, [r2], #4
 ad6:	4293      	cmp	r3, r2
 ad8:	d1fb      	bne.n	ad2 <memset+0x72>
 ada:	f00c 0403 	and.w	r4, ip, #3
 ade:	b12c      	cbz	r4, aec <memset+0x8c>
 ae0:	b2ca      	uxtb	r2, r1
 ae2:	441c      	add	r4, r3
 ae4:	f803 2b01 	strb.w	r2, [r3], #1
 ae8:	429c      	cmp	r4, r3
 aea:	d1fb      	bne.n	ae4 <memset+0x84>
 aec:	bd30      	pop	{r4, r5, pc}
 aee:	4664      	mov	r4, ip
 af0:	4613      	mov	r3, r2
 af2:	2c00      	cmp	r4, #0
 af4:	d1f4      	bne.n	ae0 <memset+0x80>
 af6:	e7f9      	b.n	aec <memset+0x8c>
 af8:	4603      	mov	r3, r0
 afa:	4614      	mov	r4, r2
 afc:	e7bf      	b.n	a7e <memset+0x1e>
 afe:	461a      	mov	r2, r3
 b00:	46a4      	mov	ip, r4
 b02:	e7e0      	b.n	ac6 <memset+0x66>
 b04:	682f2e2e 	.word	0x682f2e2e
 b08:	732f6c61 	.word	0x732f6c61
 b0c:	682f6372 	.word	0x682f6372
 b10:	635f6c61 	.word	0x635f6c61
 b14:	615f6e61 	.word	0x615f6e61
 b18:	636e7973 	.word	0x636e7973
 b1c:	0000632e 	.word	0x0000632e

00000b20 <_init>:
 b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b22:	bf00      	nop
 b24:	bcf8      	pop	{r3, r4, r5, r6, r7}
 b26:	bc08      	pop	{r3}
 b28:	469e      	mov	lr, r3
 b2a:	4770      	bx	lr

00000b2c <__frame_dummy_init_array_entry>:
 b2c:	02cd 0000                                   ....

00000b30 <_fini>:
 b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b32:	bf00      	nop
 b34:	bcf8      	pop	{r3, r4, r5, r6, r7}
 b36:	bc08      	pop	{r3}
 b38:	469e      	mov	lr, r3
 b3a:	4770      	bx	lr

00000b3c <__do_global_dtors_aux_fini_array_entry>:
 b3c:	02a5 0000                                   ....

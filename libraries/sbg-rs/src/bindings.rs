/* automatically generated by rust-bindgen 0.63.0 */

pub const SBG_CONFIG_UNALIGNED_ACCESS_AUTH: u32 = 0;
pub const SBG_CONFIG_BIG_ENDIAN: u32 = 0;
pub const SBG_CONFIG_ENABLE_LOG_ERROR: u32 = 1;
pub const SBG_CONFIG_ENABLE_LOG_WARNING: u32 = 1;
pub const SBG_CONFIG_ENABLE_LOG_INFO: u32 = 1;
pub const SBG_CONFIG_ENABLE_LOG_DEBUG: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __error_t_defined: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 65536;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const _MATH_ERRHANDLING_ERRNO: u32 = 1;
pub const _MATH_ERRHANDLING_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const _CLOCKS_PER_SEC_: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const CLK_TCK: u32 = 100;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SBG_DISABLE: u32 = 0;
pub const SBG_ENABLE: u32 = 1;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const SBG_CONFIG_WARN_ABOUT_DEPRECATED_TYPES: u32 = 1;
pub const SBG_PI: f64 = 3.141592653589793;
pub const SBG_PI_F: f64 = 3.141592653589793;
pub const SBG_MIN_INT_24: i32 = -8388608;
pub const SBG_MAX_INT_24: u32 = 8388607;
pub const SBG_MAX_UINT_24: u32 = 16777215;
pub const SBG_MIN_INT_40: i64 = -549755813888;
pub const SBG_MAX_INT_40: u64 = 549755813887;
pub const SBG_MAX_UINT_40: u64 = 1099511627775;
pub const SBG_MIN_INT_48: i64 = -140737488355328;
pub const SBG_MAX_INT_48: u64 = 140737488355327;
pub const SBG_MAX_UINT_48: u64 = 281474976710655;
pub const SBG_MIN_INT_56: i64 = -36028797018963968;
pub const SBG_MAX_INT_56: u64 = 36028797018963967;
pub const SBG_MAX_UINT_56: u64 = 72057594037927935;
pub const SBG_DEBUG_LOG_CATEGORY: &[u8; 5usize] = b"None\0";
pub const SBG_IF_NAME_MAX_SIZE: u32 = 48;
pub const SBG_IF_TYPE_UNKNOW: u32 = 0;
pub const SBG_IF_TYPE_SERIAL: u32 = 1;
pub const SBG_IF_TYPE_ETH_UDP: u32 = 2;
pub const SBG_IF_TYPE_ETH_TCP_IP: u32 = 3;
pub const SBG_IF_TYPE_FILE: u32 = 4;
pub const SBG_IF_TYPE_LAST_RESERVED: u32 = 999;
pub const SBG_NETWORK_IPV4_STRING_SIZE: u32 = 16;
pub const SBG_ECOM_MAX_BUFFER_SIZE: u32 = 4096;
pub const SBG_ECOM_MAX_PAYLOAD_SIZE: u32 = 4086;
pub const SBG_ECOM_MAX_EXTENDED_PAYLOAD_SIZE: u32 = 4081;
pub const SBG_ECOM_SYNC_1: u32 = 255;
pub const SBG_ECOM_SYNC_2: u32 = 90;
pub const SBG_ECOM_ETX: u32 = 51;
pub const SBG_ECOM_RX_TIME_OUT: u32 = 450;
pub const SBG_ECOM_AIR_DATA_TIME_IS_DELAY: u32 = 1;
pub const SBG_ECOM_AIR_DATA_PRESSURE_ABS_VALID: u32 = 2;
pub const SBG_ECOM_AIR_DATA_ALTITUDE_VALID: u32 = 4;
pub const SBG_ECOM_AIR_DATA_PRESSURE_DIFF_VALID: u32 = 8;
pub const SBG_ECOM_AIR_DATA_AIRPSEED_VALID: u32 = 16;
pub const SBG_ECOM_AIR_DATA_TEMPERATURE_VALID: u32 = 32;
pub const SBG_ECOM_DEPTH_TIME_IS_DELAY: u32 = 1;
pub const SBG_ECOM_DEPTH_PRESSURE_ABS_VALID: u32 = 2;
pub const SBG_ECOM_DEPTH_ALTITUDE_VALID: u32 = 4;
pub const SBG_ECOM_LOG_DIAG_MAX_STRING_SIZE: u32 = 4080;
pub const SBG_ECOM_DVL_VELOCITY_VALID: u32 = 1;
pub const SBG_ECOM_DVL_TIME_SYNC: u32 = 2;
pub const SBG_ECOM_SOLUTION_MODE_SHIFT: u32 = 0;
pub const SBG_ECOM_SOLUTION_MODE_MASK: u32 = 15;
pub const SBG_ECOM_SOL_ATTITUDE_VALID: u32 = 16;
pub const SBG_ECOM_SOL_HEADING_VALID: u32 = 32;
pub const SBG_ECOM_SOL_VELOCITY_VALID: u32 = 64;
pub const SBG_ECOM_SOL_POSITION_VALID: u32 = 128;
pub const SBG_ECOM_SOL_VERT_REF_USED: u32 = 256;
pub const SBG_ECOM_SOL_MAG_REF_USED: u32 = 512;
pub const SBG_ECOM_SOL_GPS1_VEL_USED: u32 = 1024;
pub const SBG_ECOM_SOL_GPS1_POS_USED: u32 = 2048;
pub const SBG_ECOM_SOL_GPS1_HDT_USED: u32 = 8192;
pub const SBG_ECOM_SOL_GPS2_VEL_USED: u32 = 16384;
pub const SBG_ECOM_SOL_GPS2_POS_USED: u32 = 32768;
pub const SBG_ECOM_SOL_GPS2_HDT_USED: u32 = 131072;
pub const SBG_ECOM_SOL_ODO_USED: u32 = 262144;
pub const SBG_ECOM_SOL_DVL_BT_USED: u32 = 524288;
pub const SBG_ECOM_SOL_DVL_WT_USED: u32 = 1048576;
pub const SBG_ECOM_SOL_USER_POS_USED: u32 = 2097152;
pub const SBG_ECOM_SOL_USER_VEL_USED: u32 = 4194304;
pub const SBG_ECOM_SOL_USER_HEADING_USED: u32 = 8388608;
pub const SBG_ECOM_SOL_USBL_USED: u32 = 16777216;
pub const SBG_ECOM_SOL_AIR_DATA_USED: u32 = 33554432;
pub const SBG_ECOM_SOL_ZUPT_USED: u32 = 67108864;
pub const SBG_ECOM_SOL_ALIGN_VALID: u32 = 134217728;
pub const SBG_ECOM_SOL_DEPTH_USED: u32 = 268435456;
pub const SBG_ECOM_EVENT_OVERFLOW: u32 = 1;
pub const SBG_ECOM_EVENT_OFFSET_0_VALID: u32 = 2;
pub const SBG_ECOM_EVENT_OFFSET_1_VALID: u32 = 4;
pub const SBG_ECOM_EVENT_OFFSET_2_VALID: u32 = 8;
pub const SBG_ECOM_EVENT_OFFSET_3_VALID: u32 = 16;
pub const SBG_ECOM_RAW_DATA_MAX_BUFFER_SIZE: u32 = 4086;
pub const SBG_ECOM_GPS_VEL_STATUS_SHIFT: u32 = 0;
pub const SBG_ECOM_GPS_VEL_STATUS_MASK: u32 = 63;
pub const SBG_ECOM_GPS_VEL_TYPE_SHIFT: u32 = 6;
pub const SBG_ECOM_GPS_VEL_TYPE_MASK: u32 = 63;
pub const SBG_ECOM_GPS_POS_STATUS_SHIFT: u32 = 0;
pub const SBG_ECOM_GPS_POS_STATUS_MASK: u32 = 63;
pub const SBG_ECOM_GPS_POS_TYPE_SHIFT: u32 = 6;
pub const SBG_ECOM_GPS_POS_TYPE_MASK: u32 = 63;
pub const SBG_ECOM_GPS_POS_GPS_L1_USED: u32 = 4096;
pub const SBG_ECOM_GPS_POS_GPS_L2_USED: u32 = 8192;
pub const SBG_ECOM_GPS_POS_GPS_L5_USED: u32 = 16384;
pub const SBG_ECOM_GPS_POS_GLO_L1_USED: u32 = 32768;
pub const SBG_ECOM_GPS_POS_GLO_L2_USED: u32 = 65536;
pub const SBG_ECOM_GPS_POS_GLO_L3_USED: u32 = 131072;
pub const SBG_ECOM_GPS_POS_GAL_E1_USED: u32 = 262144;
pub const SBG_ECOM_GPS_POS_GAL_E5A_USED: u32 = 524288;
pub const SBG_ECOM_GPS_POS_GAL_E5B_USED: u32 = 1048576;
pub const SBG_ECOM_GPS_POS_GAL_E5ALT_USED: u32 = 2097152;
pub const SBG_ECOM_GPS_POS_GAL_E6_USED: u32 = 4194304;
pub const SBG_ECOM_GPS_POS_BDS_B1_USED: u32 = 8388608;
pub const SBG_ECOM_GPS_POS_BDS_B2_USED: u32 = 16777216;
pub const SBG_ECOM_GPS_POS_BDS_B3_USED: u32 = 33554432;
pub const SBG_ECOM_GPS_POS_QZSS_L1_USED: u32 = 67108864;
pub const SBG_ECOM_GPS_POS_QZSS_L2_USED: u32 = 134217728;
pub const SBG_ECOM_GPS_POS_QZSS_L5_USED: u32 = 268435456;
pub const SBG_ECOM_GPS_HDT_STATUS_SHIFT: u32 = 0;
pub const SBG_ECOM_GPS_HDT_STATUS_MASK: u32 = 63;
pub const SBG_ECOM_GPS_HDT_BASELINE_VALID: u32 = 64;
pub const SBG_ECOM_IMU_COM_OK: u32 = 1;
pub const SBG_ECOM_IMU_STATUS_BIT: u32 = 2;
pub const SBG_ECOM_IMU_ACCEL_X_BIT: u32 = 4;
pub const SBG_ECOM_IMU_ACCEL_Y_BIT: u32 = 8;
pub const SBG_ECOM_IMU_ACCEL_Z_BIT: u32 = 16;
pub const SBG_ECOM_IMU_GYRO_X_BIT: u32 = 32;
pub const SBG_ECOM_IMU_GYRO_Y_BIT: u32 = 64;
pub const SBG_ECOM_IMU_GYRO_Z_BIT: u32 = 128;
pub const SBG_ECOM_IMU_ACCELS_IN_RANGE: u32 = 256;
pub const SBG_ECOM_IMU_GYROS_IN_RANGE: u32 = 512;
pub const SBG_ECOM_MAG_MAG_X_BIT: u32 = 1;
pub const SBG_ECOM_MAG_MAG_Y_BIT: u32 = 2;
pub const SBG_ECOM_MAG_MAG_Z_BIT: u32 = 4;
pub const SBG_ECOM_MAG_ACCEL_X_BIT: u32 = 8;
pub const SBG_ECOM_MAG_ACCEL_Y_BIT: u32 = 16;
pub const SBG_ECOM_MAG_ACCEL_Z_BIT: u32 = 32;
pub const SBG_ECOM_MAG_MAGS_IN_RANGE: u32 = 64;
pub const SBG_ECOM_MAG_ACCELS_IN_RANGE: u32 = 128;
pub const SBG_ECOM_MAG_CALIBRATION_OK: u32 = 256;
pub const SBG_ECOM_ODO_REAL_MEAS: u32 = 1;
pub const SBG_ECOM_ODO_TIME_SYNC: u32 = 2;
pub const SBG_ECOM_SAT_MAX_NR_SATELLITES: u32 = 64;
pub const SBG_ECOM_SAT_MAX_NR_SIGNALS: u32 = 8;
pub const SBG_ECOM_HEAVE_VALID: u32 = 1;
pub const SBG_ECOM_HEAVE_VEL_AIDED: u32 = 2;
pub const SBG_ECOM_HEAVE_SURGE_SWAY_INCLUDED: u32 = 4;
pub const SBG_ECOM_HEAVE_PERIOD_INCLUDED: u32 = 8;
pub const SBG_ECOM_HEAVE_PERIOD_VALID: u32 = 16;
pub const SBG_ECOM_HEAVE_SWELL_MODE: u32 = 32;
pub const SBG_ECOM_GENERAL_MAIN_POWER_OK: u32 = 1;
pub const SBG_ECOM_GENERAL_IMU_POWER_OK: u32 = 2;
pub const SBG_ECOM_GENERAL_GPS_POWER_OK: u32 = 4;
pub const SBG_ECOM_GENERAL_SETTINGS_OK: u32 = 8;
pub const SBG_ECOM_GENERAL_TEMPERATURE_OK: u32 = 16;
pub const SBG_ECOM_GENERAL_DATALOGGER_OK: u32 = 32;
pub const SBG_ECOM_GENERAL_CPU_OK: u32 = 64;
pub const SBG_ECOM_CAN_STATUS_SHIFT: u32 = 28;
pub const SBG_ECOM_CAN_STATUS_MASK: u32 = 7;
pub const SBG_ECOM_PORTA_VALID: u32 = 1;
pub const SBG_ECOM_PORTB_VALID: u32 = 2;
pub const SBG_ECOM_PORTC_VALID: u32 = 4;
pub const SBG_ECOM_PORTD_VALID: u32 = 8;
pub const SBG_ECOM_PORTE_VALID: u32 = 16;
pub const SBG_ECOM_PORTA_RX_OK: u32 = 32;
pub const SBG_ECOM_PORTA_TX_OK: u32 = 64;
pub const SBG_ECOM_PORTB_RX_OK: u32 = 128;
pub const SBG_ECOM_PORTB_TX_OK: u32 = 256;
pub const SBG_ECOM_PORTC_RX_OK: u32 = 512;
pub const SBG_ECOM_PORTC_TX_OK: u32 = 1024;
pub const SBG_ECOM_PORTD_RX_OK: u32 = 2048;
pub const SBG_ECOM_PORTD_TX_OK: u32 = 4096;
pub const SBG_ECOM_PORTE_RX_OK: u32 = 8192;
pub const SBG_ECOM_PORTE_TX_OK: u32 = 16384;
pub const SBG_ECOM_ETH0_VALID: u32 = 32768;
pub const SBG_ECOM_ETH1_VALID: u32 = 65536;
pub const SBG_ECOM_ETH2_VALID: u32 = 131072;
pub const SBG_ECOM_ETH3_VALID: u32 = 262144;
pub const SBG_ECOM_ETH4_VALID: u32 = 524288;
pub const SBG_ECOM_CAN_VALID: u32 = 33554432;
pub const SBG_ECOM_CAN_RX_OK: u32 = 67108864;
pub const SBG_ECOM_CAN_TX_OK: u32 = 134217728;
pub const SBG_ECOM_COM2_ETH0_RX_OK: u32 = 1;
pub const SBG_ECOM_COM2_ETH0_TX_OK: u32 = 2;
pub const SBG_ECOM_COM2_ETH1_RX_OK: u32 = 4;
pub const SBG_ECOM_COM2_ETH1_TX_OK: u32 = 8;
pub const SBG_ECOM_COM2_ETH2_RX_OK: u32 = 16;
pub const SBG_ECOM_COM2_ETH2_TX_OK: u32 = 32;
pub const SBG_ECOM_COM2_ETH3_RX_OK: u32 = 64;
pub const SBG_ECOM_COM2_ETH3_TX_OK: u32 = 128;
pub const SBG_ECOM_COM2_ETH4_RX_OK: u32 = 256;
pub const SBG_ECOM_COM2_ETH4_TX_OK: u32 = 512;
pub const SBG_ECOM_AIDING_GPS1_POS_RECV: u32 = 1;
pub const SBG_ECOM_AIDING_GPS1_VEL_RECV: u32 = 2;
pub const SBG_ECOM_AIDING_GPS1_HDT_RECV: u32 = 4;
pub const SBG_ECOM_AIDING_GPS1_UTC_RECV: u32 = 8;
pub const SBG_ECOM_AIDING_GPS2_POS_RECV: u32 = 16;
pub const SBG_ECOM_AIDING_GPS2_VEL_RECV: u32 = 32;
pub const SBG_ECOM_AIDING_GPS2_HDT_RECV: u32 = 64;
pub const SBG_ECOM_AIDING_GPS2_UTC_RECV: u32 = 128;
pub const SBG_ECOM_AIDING_MAG_RECV: u32 = 256;
pub const SBG_ECOM_AIDING_ODO_RECV: u32 = 512;
pub const SBG_ECOM_AIDING_DVL_RECV: u32 = 1024;
pub const SBG_ECOM_AIDING_USBL_RECV: u32 = 2048;
pub const SBG_ECOM_AIDING_DEPTH_RECV: u32 = 4096;
pub const SBG_ECOM_AIDING_AIR_DATA_RECV: u32 = 8192;
pub const SBG_ECOM_AIDING_USER_POS_RECV: u32 = 16384;
pub const SBG_ECOM_AIDING_USER_VEL_RECV: u32 = 32768;
pub const SBG_ECOM_AIDING_USER_HEADING_RECV: u32 = 65536;
pub const SBG_ECOM_USBL_TIME_SYNC: u32 = 1;
pub const SBG_ECOM_USBL_POSITION_VALID: u32 = 2;
pub const SBG_ECOM_USBL_DEPTH_VALID: u32 = 4;
pub const SBG_ECOM_CLOCK_STATUS_SHIFT: u32 = 1;
pub const SBG_ECOM_CLOCK_STATUS_MASK: u32 = 15;
pub const SBG_ECOM_CLOCK_UTC_STATUS_SHIFT: u32 = 6;
pub const SBG_ECOM_CLOCK_UTC_STATUS_MASK: u32 = 15;
pub const SBG_ECOM_CLOCK_STABLE_INPUT: u32 = 1;
pub const SBG_ECOM_CLOCK_UTC_SYNC: u32 = 32;
pub const SBG_ECOM_DEFAULT_CMD_TIME_OUT: u32 = 500;
pub const SBG_ECOM_SENSOR_FEATURE_IMU: u32 = 1;
pub const SBG_ECOM_SENSOR_FEATURE_AHRS: u32 = 2;
pub const SBG_ECOM_SENSOR_FEATURE_NAVIGATION: u32 = 4;
pub const SBG_ECOM_SENSOR_FEATURE_SHIP_MOTION: u32 = 8;
pub const SBG_ECOM_GNSS_SIGNAL_GPS_L1: u32 = 1;
pub const SBG_ECOM_GNSS_SIGNAL_GPS_L2: u32 = 2;
pub const SBG_ECOM_GNSS_SIGNAL_GPS_L5: u32 = 4;
pub const SBG_ECOM_GNSS_SIGNAL_GLONASS_L1: u32 = 8;
pub const SBG_ECOM_GNSS_SIGNAL_GLONASS_L2: u32 = 16;
pub const SBG_ECOM_GNSS_SIGNAL_BEIDOU_B1: u32 = 32;
pub const SBG_ECOM_GNSS_SIGNAL_BEIDOU_B2: u32 = 64;
pub const SBG_ECOM_GNSS_SIGNAL_BEIDOU_B3: u32 = 128;
pub const SBG_ECOM_GNSS_SIGNAL_GALILEO_E1: u32 = 256;
pub const SBG_ECOM_GNSS_SIGNAL_GALILEO_E5: u32 = 512;
pub const SBG_ECOM_GNSS_SIGNAL_GALILEO_E6: u32 = 1024;
pub const SBG_ECOM_GNSS_SIGNAL_QZSS: u32 = 2048;
pub const SBG_ECOM_GNSS_SIGNAL_SBAS: u32 = 4096;
pub const SBG_ECOM_GNSS_SIGNAL_L_BAND: u32 = 8192;
pub const SBG_ECOM_GNSS_FEATURE_DUAL_ANT: u32 = 1;
pub const SBG_ECOM_GNSS_FEATURE_RTK_LIMITED: u32 = 2;
pub const SBG_ECOM_GNSS_FEATURE_RTK: u32 = 4;
pub const SBG_ECOM_GNSS_FEATURE_PPP: u32 = 8;
pub const SBG_ECOM_GNSS_FEATURE_RAW_DATA: u32 = 16;
pub const SBG_ECOM_GNSS_FEATURE_RAIM: u32 = 32;
pub const SBG_ECOM_GNSS_FEATURE_HIGH_SPEED: u32 = 64;
pub const SBG_ECOM_INFO_PRODUCT_CODE_LENGTH: u32 = 32;
pub const SBG_ECOM_MAG_CALIB_NOT_ENOUGH_POINTS: u32 = 1;
pub const SBG_ECOM_MAG_CALIB_TOO_MUCH_DISTORTIONS: u32 = 2;
pub const SBG_ECOM_MAG_CALIB_X_MOTION_ISSUE: u32 = 4;
pub const SBG_ECOM_MAG_CALIB_Y_MOTION_ISSUE: u32 = 8;
pub const SBG_ECOM_MAG_CALIB_Z_MOTION_ISSUE: u32 = 16;
pub const SBG_ECOM_MAG_CALIB_ALIGNMENT_ISSUE: u32 = 32;
pub const SBG_E_COM_VERSION_MAJOR: u32 = 3;
pub const SBG_E_COM_VERSION_MINOR: u32 = 2;
pub const SBG_E_COM_VERSION_REV: u32 = 4011;
extern "C" {
    pub fn __assert(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
pub type error_t = ::core::ffi::c_int;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type wint_t = ::core::ffi::c_int;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _unspecified_locale_info: ::core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::core::ffi::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::core::ffi::c_uint,
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::core::ffi::c_uchar; 30usize],
    pub _nmalloc: [::core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __errno() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub static _sys_errlist: [*const ::core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::core::ffi::c_int;
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn finitel(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isinff(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isnanf(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isinf(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn isnan(arg1: f64) -> ::core::ffi::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __isinfd(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __isnanf(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __isnand(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __signbitf(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __signbitd(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::core::ffi::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::core::ffi::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::core::ffi::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut ::core::ffi::c_int;
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::core::ffi::c_char, arg2: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::core::ffi::c_char,
        resolved_path: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn l64a(__input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::core::ffi::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
        arg4: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::core::mem::MaybeUninit<itimerspec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::core::ffi::c_uchar;
pub type u_short = ::core::ffi::c_ushort;
pub type u_int = ::core::ffi::c_uint;
pub type u_long = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type ulong = ::core::ffi::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type daddr_t = ::core::ffi::c_long;
pub type caddr_t = *mut ::core::ffi::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::core::mem::MaybeUninit<sched_param> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::core::ffi::c_int,
    pub contentionscope: ::core::ffi::c_int,
    pub inheritsched: ::core::ffi::c_int,
    pub schedpolicy: ::core::ffi::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stackaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stacksize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).contentionscope) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inheritsched) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).schedpolicy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).schedparam) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detachstate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub recursive: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recursive) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::core::ffi::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::core::ffi::c_int,
    pub init_executed: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_once_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_executed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::core::ffi::c_long,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::core::ffi::c_char,
        _new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::core::mem::MaybeUninit<tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::core::ffi::c_char,
        _maxsize: usize,
        _fmt: *const ::core::ffi::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::core::ffi::c_long;
}
extern "C" {
    pub static mut _daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::core::ffi::c_char; 2usize];
}
#[doc = "< The operation was successfully executed."]
pub const _SbgErrorCode_SBG_NO_ERROR: _SbgErrorCode = 0;
#[doc = "< We have a generic error."]
pub const _SbgErrorCode_SBG_ERROR: _SbgErrorCode = 1;
#[doc = "< A pointer is null."]
pub const _SbgErrorCode_SBG_NULL_POINTER: _SbgErrorCode = 2;
#[doc = "< The received frame has an invalid CRC."]
pub const _SbgErrorCode_SBG_INVALID_CRC: _SbgErrorCode = 3;
#[doc = "< The received frame is invalid <br> */\n/*!<\tWe have received an unexpected frame (not the cmd we are waiting for or with an invalid data size.<br> */\n/*!<\tThis could be caused by a desync between questions and answers.<br> */\n/*!<\tYou should flush the serial port to fix this."]
pub const _SbgErrorCode_SBG_INVALID_FRAME: _SbgErrorCode = 4;
#[doc = "< We have started to receive a frame but not the end."]
pub const _SbgErrorCode_SBG_TIME_OUT: _SbgErrorCode = 5;
#[doc = "< All bytes hasn't been written."]
pub const _SbgErrorCode_SBG_WRITE_ERROR: _SbgErrorCode = 6;
#[doc = "< All bytes hasn't been read."]
pub const _SbgErrorCode_SBG_READ_ERROR: _SbgErrorCode = 7;
#[doc = "< A buffer is too small to contain so much data."]
pub const _SbgErrorCode_SBG_BUFFER_OVERFLOW: _SbgErrorCode = 8;
#[doc = "< An invalid parameter has been found."]
pub const _SbgErrorCode_SBG_INVALID_PARAMETER: _SbgErrorCode = 9;
#[doc = "< A device isn't ready (Rx isn't ready for example)."]
pub const _SbgErrorCode_SBG_NOT_READY: _SbgErrorCode = 10;
#[doc = "< Failed to allocate a buffer."]
pub const _SbgErrorCode_SBG_MALLOC_FAILED: _SbgErrorCode = 11;
#[doc = "< Not enough points were available to perform magnetometers calibration."]
pub const _SbgErrorCode_SGB_CALIB_MAG_NOT_ENOUGH_POINTS: _SbgErrorCode = 12;
#[doc = "< The calibration procedure could not be properly executed due to insufficient precision."]
pub const _SbgErrorCode_SBG_CALIB_MAG_INVALID_TAKE: _SbgErrorCode = 13;
#[doc = "< Saturation were detected when attempt to calibrate magnetos."]
pub const _SbgErrorCode_SBG_CALIB_MAG_SATURATION: _SbgErrorCode = 14;
#[doc = "< 2D calibration procedure could not be performed."]
pub const _SbgErrorCode_SBG_CALIB_MAG_POINTS_NOT_IN_A_PLANE: _SbgErrorCode = 15;
#[doc = "< A device couldn't be founded or opened PC only error code"]
pub const _SbgErrorCode_SBG_DEVICE_NOT_FOUND: _SbgErrorCode = 16;
#[doc = "< An operation was canceled.  PC only error code"]
pub const _SbgErrorCode_SBG_OPERATION_CANCELLED: _SbgErrorCode = 17;
#[doc = "< We have received a frame that isn't a continuous one. PC only error code"]
pub const _SbgErrorCode_SBG_NOT_CONTINUOUS_FRAME: _SbgErrorCode = 18;
#[doc = "< Hence valid; the command cannot be executed because of hardware incompatibility"]
pub const _SbgErrorCode_SBG_INCOMPATIBLE_HARDWARE: _SbgErrorCode = 19;
#[doc = "< Incompatible version"]
pub const _SbgErrorCode_SBG_INVALID_VERSION: _SbgErrorCode = 20;
#[doc = "\tGeneric errors definitions for SBG Systems projects."]
pub type _SbgErrorCode = ::core::ffi::c_uint;
#[doc = "\tGeneric errors definitions for SBG Systems projects."]
pub use self::_SbgErrorCode as SbgErrorCode;
pub type uint8 = ::core::ffi::c_uchar;
pub type uint16 = ::core::ffi::c_ushort;
pub type uint32 = ::core::ffi::c_uint;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type int8 = ::core::ffi::c_schar;
pub type int16 = ::core::ffi::c_short;
pub type int32 = ::core::ffi::c_int;
pub type int64 = ::core::ffi::c_longlong;
pub type sbgIpAddress = u32;
#[doc = " Used to get a uint32_t from a uint8_t array."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8PtrToUint32Ptr {
    #[doc = "< Set the address used to access the uint32_t."]
    pub m_pointerUint8: *mut u8,
    #[doc = "< Store the unint32 value."]
    pub m_pointerUint32: *mut u32,
}
#[test]
fn bindgen_test_layout__Uint8PtrToUint32Ptr() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8PtrToUint32Ptr> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8PtrToUint32Ptr>(),
        4usize,
        concat!("Size of: ", stringify!(_Uint8PtrToUint32Ptr))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8PtrToUint32Ptr>(),
        4usize,
        concat!("Alignment of ", stringify!(_Uint8PtrToUint32Ptr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_pointerUint8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8PtrToUint32Ptr),
            "::",
            stringify!(m_pointerUint8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_pointerUint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8PtrToUint32Ptr),
            "::",
            stringify!(m_pointerUint32)
        )
    );
}
#[doc = " Used to get a uint32_t from a uint8_t array."]
pub type Uint8PtrToUint32Ptr = _Uint8PtrToUint32Ptr;
#[doc = " Union used to convert a buffer or 2 unit8 two's complement values to a int16_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToInt16 {
    pub value: i16,
    pub buffer: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__Uint8ToInt16() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToInt16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToInt16>(),
        2usize,
        concat!("Size of: ", stringify!(_Uint8ToInt16))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToInt16>(),
        2usize,
        concat!("Alignment of ", stringify!(_Uint8ToInt16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt16),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt16),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 2 unit8 two's complement values to a int16_t"]
pub type Uint8ToInt16 = _Uint8ToInt16;
#[doc = " Union used to convert a buffer or 2 unit8 values to a uint16_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToUint16 {
    pub value: u16,
    pub buffer: [u8; 2usize],
}
#[test]
fn bindgen_test_layout__Uint8ToUint16() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToUint16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToUint16>(),
        2usize,
        concat!("Size of: ", stringify!(_Uint8ToUint16))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToUint16>(),
        2usize,
        concat!("Alignment of ", stringify!(_Uint8ToUint16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint16),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint16),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 2 unit8 values to a uint16_t"]
pub type Uint8ToUint16 = _Uint8ToUint16;
#[doc = " Union used to convert a buffer or 4 unit8 two's complement values to a int32_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToInt32 {
    pub value: i32,
    pub buffer: [u8; 4usize],
}
#[test]
fn bindgen_test_layout__Uint8ToInt32() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToInt32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToInt32>(),
        4usize,
        concat!("Size of: ", stringify!(_Uint8ToInt32))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToInt32>(),
        4usize,
        concat!("Alignment of ", stringify!(_Uint8ToInt32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt32),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt32),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 4 unit8 two's complement values to a int32_t"]
pub type Uint8ToInt32 = _Uint8ToInt32;
#[doc = " Union used to convert a buffer or 4 unit8 values to a uint32_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToUint32 {
    pub value: u32,
    pub buffer: [u8; 4usize],
}
#[test]
fn bindgen_test_layout__Uint8ToUint32() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToUint32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToUint32>(),
        4usize,
        concat!("Size of: ", stringify!(_Uint8ToUint32))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToUint32>(),
        4usize,
        concat!("Alignment of ", stringify!(_Uint8ToUint32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint32),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint32),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 4 unit8 values to a uint32_t"]
pub type Uint8ToUint32 = _Uint8ToUint32;
#[doc = " Union used to convert a buffer or 8 unit8 two's complement values to a int64_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToInt64 {
    pub value: i64,
    pub buffer: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__Uint8ToInt64() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToInt64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToInt64>(),
        8usize,
        concat!("Size of: ", stringify!(_Uint8ToInt64))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_Uint8ToInt64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt64),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToInt64),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 8 unit8 two's complement values to a int64_t"]
pub type Uint8ToInt64 = _Uint8ToInt64;
#[doc = " Union used to convert a buffer or 8 unit8 values to a uint64_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Uint8ToUint64 {
    pub value: u64,
    pub buffer: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__Uint8ToUint64() {
    const UNINIT: ::core::mem::MaybeUninit<_Uint8ToUint64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Uint8ToUint64>(),
        8usize,
        concat!("Size of: ", stringify!(_Uint8ToUint64))
    );
    assert_eq!(
        ::core::mem::align_of::<_Uint8ToUint64>(),
        8usize,
        concat!("Alignment of ", stringify!(_Uint8ToUint64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint64),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Uint8ToUint64),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " Union used to convert a buffer or 8 unit8 values to a uint64_t"]
pub type Uint8ToUint64 = _Uint8ToUint64;
#[doc = " Union that allows type punning (access to a floating point number bits)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FloatNint {
    pub valF: f32,
    pub valI: i32,
    pub valU: u32,
}
#[test]
fn bindgen_test_layout__FloatNint() {
    const UNINIT: ::core::mem::MaybeUninit<_FloatNint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FloatNint>(),
        4usize,
        concat!("Size of: ", stringify!(_FloatNint))
    );
    assert_eq!(
        ::core::mem::align_of::<_FloatNint>(),
        4usize,
        concat!("Alignment of ", stringify!(_FloatNint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valF) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FloatNint),
            "::",
            stringify!(valF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FloatNint),
            "::",
            stringify!(valI)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valU) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FloatNint),
            "::",
            stringify!(valU)
        )
    );
}
#[doc = " Union that allows type punning (access to a floating point number bits)"]
pub type FloatNint = _FloatNint;
#[doc = " Union that allows type punning (access to a double number bits)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DoubleNint {
    pub valF: f64,
    pub valU: u64,
    pub valI: i64,
}
#[test]
fn bindgen_test_layout__DoubleNint() {
    const UNINIT: ::core::mem::MaybeUninit<_DoubleNint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DoubleNint>(),
        8usize,
        concat!("Size of: ", stringify!(_DoubleNint))
    );
    assert_eq!(
        ::core::mem::align_of::<_DoubleNint>(),
        8usize,
        concat!("Alignment of ", stringify!(_DoubleNint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valF) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DoubleNint),
            "::",
            stringify!(valF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valU) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DoubleNint),
            "::",
            stringify!(valU)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DoubleNint),
            "::",
            stringify!(valI)
        )
    );
}
#[doc = " Union that allows type punning (access to a double number bits)"]
pub type DoubleNint = _DoubleNint;
#[doc = " Structure that splits a 64bits"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Split64 {
    pub high: u32,
    pub low: u32,
}
#[test]
fn bindgen_test_layout__Split64() {
    const UNINIT: ::core::mem::MaybeUninit<_Split64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Split64>(),
        8usize,
        concat!("Size of: ", stringify!(_Split64))
    );
    assert_eq!(
        ::core::mem::align_of::<_Split64>(),
        4usize,
        concat!("Alignment of ", stringify!(_Split64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Split64),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Split64),
            "::",
            stringify!(low)
        )
    );
}
#[doc = " Structure that splits a 64bits"]
pub type Split64 = _Split64;
#[doc = " Set of 3 int32_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgVector3i {
    pub v: [i32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgVector3i() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgVector3i> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgVector3i>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgVector3i))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgVector3i>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgVector3i))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgVector3i),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " Set of 3 int32_t"]
pub type SbgVector3i = _SbgVector3i;
#[doc = " Set of 3 int64_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgVector3ll {
    pub v: [i64; 3usize],
}
#[test]
fn bindgen_test_layout__SbgVector3ll() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgVector3ll> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgVector3ll>(),
        24usize,
        concat!("Size of: ", stringify!(_SbgVector3ll))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgVector3ll>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgVector3ll))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgVector3ll),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " Set of 3 int64_t"]
pub type SbgVector3ll = _SbgVector3ll;
#[doc = "< The message to log is an error."]
pub const _SbgDebugLogType_SBG_DEBUG_LOG_TYPE_ERROR: _SbgDebugLogType = 0;
#[doc = "< The message to log is a warning."]
pub const _SbgDebugLogType_SBG_DEBUG_LOG_TYPE_WARNING: _SbgDebugLogType = 1;
#[doc = "< The message to log is an information."]
pub const _SbgDebugLogType_SBG_DEBUG_LOG_TYPE_INFO: _SbgDebugLogType = 2;
#[doc = "< The message to log is a debug information."]
pub const _SbgDebugLogType_SBG_DEBUG_LOG_TYPE_DEBUG: _SbgDebugLogType = 3;
#[doc = "\tEnum that identify the type of error / warning that has been thrown."]
pub type _SbgDebugLogType = ::core::ffi::c_uint;
#[doc = "\tEnum that identify the type of error / warning that has been thrown."]
pub use self::_SbgDebugLogType as SbgDebugLogType;
extern "C" {
    #[doc = " Produce a text dump of a buffer.\n\n \\param[in]\tpPrefix\t\t\t\t\t\tPrefix string before each line.\n \\param[in]\tpBuffer\t\t\t\t\t\tData buffer, may be NULL.\n \\param[in]\tsize\t\t\t\t\t\tData size, in bytes."]
    pub fn sbgDebugHexDump(
        pPrefix: *const ::core::ffi::c_char,
        pBuffer: *const ::core::ffi::c_void,
        size: usize,
    );
}
#[doc = " Type for logging functions.\n\n \\param[in]\tpFileName\t\t\t\t\tFile name where the error occurred.\n \\param[in]\tpFunctionName\t\t\t\tFunction name where the error occurred.\n \\param[in]\tline\t\t\t\t\t\tLine number where the error occurred.\n \\param[in]\tpCategory\t\t\t\t\tCategory for this log or \"None\" if no category has been specified.\n \\param[in]\tlogType\t\t\t\t\t\tDefine if we have an error, a warning, an info or a debug log.\n \\param[in]\terrorCode\t\t\t\t\tThe error code associated with the message.\n \\param[in]\tpMessage\t\t\t\t\tThe message to log."]
pub type SbgCommonLibOnLogFunc = ::core::option::Option<
    unsafe extern "C" fn(
        pFileName: *const ::core::ffi::c_char,
        pFunctionName: *const ::core::ffi::c_char,
        line: u32,
        pCategory: *const ::core::ffi::c_char,
        logType: SbgDebugLogType,
        errorCode: SbgErrorCode,
        pMessage: *const ::core::ffi::c_char,
    ),
>;
extern "C" {
    #[doc = " Get the current time.\n\n \\return\t\t\t\t\t\t\t\t\tThe current time, in ms."]
    pub fn sbgGetTime() -> u32;
}
extern "C" {
    #[doc = " Sleep.\n\n \\param[in]\tms\t\t\t\t\t\t\tTime to wait, in ms."]
    pub fn sbgSleep(ms: u32);
}
extern "C" {
    #[doc = " Set the log function.\n\n Some platforms may not provide the ability to set a user-provided log function, in which\n case this function does nothing.\n\n \\param[in]\tlogCallback\t\t\t\t\tLog function."]
    pub fn sbgCommonLibSetLogCallback(logCallback: SbgCommonLibOnLogFunc);
}
extern "C" {
    #[doc = " Log a message.\n\n \\param[in]\tpFileName\t\t\t\t\tFile name where the error occurred.\n \\param[in]\tpFunctionName\t\t\t\tFunction name where the error occurred.\n \\param[in]\tline\t\t\t\t\t\tLine number where the error occurred.\n \\param[in]\tpCategory\t\t\t\t\tCategory for this log or \"None\" if no category has been specified.\n \\param[in]\tlogType\t\t\t\t\t\tDefine if we have an error, a warning, an info or a debug log.\n \\param[in]\terrorCode\t\t\t\t\tThe error code associated with the message.\n \\param[in]\tpFormat\t\t\t\t\t\tThe error message that will be used with the variable list of arguments."]
    pub fn sbgPlatformDebugLogMsg(
        pFileName: *const ::core::ffi::c_char,
        pFunctionName: *const ::core::ffi::c_char,
        line: u32,
        pCategory: *const ::core::ffi::c_char,
        logType: SbgDebugLogType,
        errorCode: SbgErrorCode,
        pFormat: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Retreive the current sbgCommonLib encoded version.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tThe current sbgCommonLib version"]
    pub fn sbgCommonLibGetVersion() -> u32;
}
extern "C" {
    #[doc = "\tTell if the library is compiled in debug mode or not\n\t\\return\t\t\t\t\t\tTrue if it's compiled in debug, False otherwise"]
    pub fn sbgCommonLibIsDebug() -> bool;
}
pub type SbgCrc32 = u32;
pub type SbgCrc16 = u16;
extern "C" {
    #[doc = "\tInitialize the 32 bit CRC computation system.\n\t\\param[in]\tpInstance\t\t\t\tPointer on an allocated but non initialized Crc32 object."]
    pub fn sbgCrc32Initialize(pInstance: *mut SbgCrc32);
}
extern "C" {
    #[doc = "\tCompute a 32 bit CRC using an Ethernet polynome.\n\tWarning: the buffer size should be at least 4 bytes long.\n\t\\param[in]\tpInstance\t\t\t\tRead only pointer on a valid Crc32 object.\n\t\\param[in]\tpData\t\t\t\t\tRead only pointer on the data buffer to compute CRC on.\n\t\\param[in]\tdataSize\t\t\t\tData size in bytes of the buffer, has to be greater or equals to 4."]
    pub fn sbgCrc32Update(
        pInstance: *mut SbgCrc32,
        pData: *const ::core::ffi::c_void,
        dataSize: usize,
    );
}
extern "C" {
    #[doc = "\tCompute a 32 Bit CRC using an Ethernet polynome.\n\tWarning: the buffer size should be at least 4 bytes long.\n\t\\param[in]\tpData\t\t\t\t\tRead only pointer on the data buffer to compute CRC on.\n\t\\param[in]\tdataSize\t\t\t\tData size in bytes of the buffer, has to be greater or equals to 4.\n\t\\return\t\t\t\t\t\t\t\tThe computed CRC."]
    pub fn sbgCrc32Compute(pData: *const ::core::ffi::c_void, dataSize: usize) -> u32;
}
extern "C" {
    #[doc = "\tInitialize the 16 bit CRC computation system.\n\t\\param[in]\tpInstance\t\t\t\tPointer on an allocated but non initialized Crc16 object."]
    pub fn sbgCrc16Initialize(pInstance: *mut SbgCrc16);
}
extern "C" {
    #[doc = "\tCompute a 16 bit CRC using an the polynome 0x8408.\n\t\\param[in]\tpInstance\t\t\t\tRead only pointer on a valid Crc16 object.\n\t\\param[in]\tpData\t\t\t\t\tRead only pointer on the data buffer to compute CRC on.\n\t\\param[in]\tdataSize\t\t\t\tData size in bytes of the buffer."]
    pub fn sbgCrc16Update(
        pInstance: *mut SbgCrc16,
        pData: *const ::core::ffi::c_void,
        dataSize: usize,
    );
}
extern "C" {
    #[doc = "\tCompute a 32 Bit CRC using an the polynome 0x8408.\n\t\\param[in]\tpData\t\t\t\t\tRead only pointer on the data buffer to compute CRC on.\n\t\\param[in]\tdataSize\t\t\t\tData size in bytes of the buffer.\n\t\\return\t\t\t\t\t\t\t\tThe computed CRC."]
    pub fn sbgCrc16Compute(pData: *const ::core::ffi::c_void, dataSize: usize) -> u16;
}
#[doc = " Interface definition that stores methods used to communicate on the interface.\n\n The interface class is designed to allow custom user implementations. The type member stores\n a type identifier allowing the identification of the underlying type, including custom\n implementations. Standard interfaces provided by this library use types from 1 up to\n and including SBG_IF_TYPE_LAST_RESERVED. Greater values are intended to identify custom\n types that are normally specific to the project using this library. The value 0 identifies\n an unknown interface type, usually indicating that the interface was not correctly initialized."]
pub type SbgInterface = _SbgInterface;
#[doc = " Handle that stores the internal interface handle (ie Serial or Ethernet)"]
pub type SbgInterfaceHandle = *mut ::core::ffi::c_void;
#[doc = " Method to implement that close and destroy an interface.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the interface has been closed successfully."]
pub type SbgInterfaceDestroyFunc =
    ::core::option::Option<unsafe extern "C" fn(pInterface: *mut SbgInterface) -> SbgErrorCode>;
#[doc = " Method to implement to write a buffer to an interface.\n\n This method should return an error only if all bytes were not written successfully.\n If you try to write zero byte, the method shouldn't return any error.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\param[in]\tpBuffer\t\t\t\t\t\t\t\t\tPointer on an allocated buffer that contains the data to write\n \\param[in]\tbytesToWrite\t\t\t\t\t\t\tNumber of bytes we would like to write (can be zero).\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if exactly bytesToWrite have been written successfully."]
pub type SbgInterfaceWriteFunc = ::core::option::Option<
    unsafe extern "C" fn(
        pInterface: *mut SbgInterface,
        pBuffer: *const ::core::ffi::c_void,
        bytesToWrite: usize,
    ) -> SbgErrorCode,
>;
#[doc = " Method to implement to read data from an interface.\n\n This method returns an error only if there is a 'low level' error on the interface.\n If no byte is read at all or less bytes than bytesToRead, this method returns SBG_NO_ERROR.\n You have to check pReadBytes field to know the number of bytes actually read.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\param[in]\tpBuffer\t\t\t\t\t\t\t\t\tPointer on an allocated buffer that can hold at least bytesToRead bytes of data.\n \\param[out]\tpReadBytes\t\t\t\t\t\t\t\tReturns the number of bytes actually read (can be zero and up to bytesToRead).\n \\param[in]\tbytesToRead\t\t\t\t\t\t\t\tMaximum number of bytes to try to read on the interface.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if zero or some bytes have been read successfully."]
pub type SbgInterfaceReadFunc = ::core::option::Option<
    unsafe extern "C" fn(
        pInterface: *mut SbgInterface,
        pBuffer: *mut ::core::ffi::c_void,
        pReadBytes: *mut usize,
        bytesToRead: usize,
    ) -> SbgErrorCode,
>;
#[doc = " Make an interface flush pending input and/or output data.\n\n If flags include SBG_IF_FLUSH_INPUT, all pending input data is discarded.\n If flags include SBG_IF_FLUSH_OUTPUT, the function blocks until all output data has been written out.\n\n WARNING: The method has no action if not applicable for a type of interface\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\param[in]\tflags\t\t\t\t\t\t\t\t\tCombination of the SBG_IF_FLUSH_INPUT and SBG_IF_FLUSH_OUTPUT flags.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
pub type SbgInterfaceFlushFunc = ::core::option::Option<
    unsafe extern "C" fn(pInterface: *mut SbgInterface, flags: u32) -> SbgErrorCode,
>;
#[doc = " Change an interface input and output speed in bps (bit per second)\n\n This method will try to change the speed immediately even if there are\n pending bytes in the send buffer.\n\n If you would like to make sure that all bytes in the Tx buffer have been\n sent before changing the speed, please flush the interface before.\n\n WARNING: The method has no action if not applicable for a type of interface\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\param[in]\tspeed\t\t\t\t\t\t\t\t\tThe new interface speed to set in bps.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
pub type SbgInterfaceSetSpeed = ::core::option::Option<
    unsafe extern "C" fn(pInterface: *mut SbgInterface, speed: u32) -> SbgErrorCode,
>;
#[doc = " Returns the current interface baud rate in bps (bit per second)\n\n WARNING: The method will returns zero if not applicable for a type of interface\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tThe current interface baud rate in bps or zero if not applicable."]
pub type SbgInterfaceGetSpeed =
    ::core::option::Option<unsafe extern "C" fn(pInterface: *const SbgInterface) -> u32>;
#[doc = " Compute and return the delay needed by the interface to transmit / receive X number of bytes.\n\n WARNING: The method will returns zero if not applicable for a type of interface.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance.\n \\param[in]\tnumBytes\t\t\t\t\t\t\t\tThe number of bytes to transmit / receive to evaluate the needed delay.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tThe expected delay in us needed to transmit / receive the specified number of bytes or 0 if not applicable."]
pub type SbgInterfaceGetDelayFunc = ::core::option::Option<
    unsafe extern "C" fn(pInterface: *const SbgInterface, numBytes: usize) -> u32,
>;
#[doc = " Interface definition that stores methods used to communicate on the interface.\n\n The interface class is designed to allow custom user implementations. The type member stores\n a type identifier allowing the identification of the underlying type, including custom\n implementations. Standard interfaces provided by this library use types from 1 up to\n and including SBG_IF_TYPE_LAST_RESERVED. Greater values are intended to identify custom\n types that are normally specific to the project using this library. The value 0 identifies\n an unknown interface type, usually indicating that the interface was not correctly initialized."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgInterface {
    #[doc = "< Internal interface handle used to access the media."]
    pub handle: SbgInterfaceHandle,
    #[doc = "< Opaque interface type."]
    pub type_: u32,
    #[doc = "< The interface name as passed during the creation"]
    pub name: [::core::ffi::c_char; 48usize],
    #[doc = "< Optional method used to destroy an interface."]
    pub pDestroyFunc: SbgInterfaceDestroyFunc,
    #[doc = "< Optional method used to write some data to this interface."]
    pub pWriteFunc: SbgInterfaceWriteFunc,
    #[doc = "< Optional method used to read some data to this interface."]
    pub pReadFunc: SbgInterfaceReadFunc,
    #[doc = "< Optional method used to make this interface flush all pending data."]
    pub pFlushFunc: SbgInterfaceFlushFunc,
    #[doc = "< Optional method used to set the interface speed in bps."]
    pub pSetSpeedFunc: SbgInterfaceSetSpeed,
    #[doc = "< Optional method used to retrieve the interface speed in bps."]
    pub pGetSpeedFunc: SbgInterfaceGetSpeed,
    #[doc = "< Optional method used to compute an expected delay to transmit/receive X bytes"]
    pub pDelayFunc: SbgInterfaceGetDelayFunc,
}
#[test]
fn bindgen_test_layout__SbgInterface() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgInterface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgInterface>(),
        84usize,
        concat!("Size of: ", stringify!(_SbgInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pDestroyFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pDestroyFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pWriteFunc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pWriteFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pReadFunc) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pReadFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pFlushFunc) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pFlushFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSetSpeedFunc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pSetSpeedFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pGetSpeedFunc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pGetSpeedFunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pDelayFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgInterface),
            "::",
            stringify!(pDelayFunc)
        )
    );
}
extern "C" {
    #[doc = " Initialize an interface instance to zero.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tThe interface instance."]
    pub fn sbgInterfaceZeroInit(pInterface: *mut SbgInterface);
}
extern "C" {
    #[doc = " Close and destroy the interface gracefully.\n\n This method will call the specialized interface destructor if any.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tThe interface instance.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the interface has been destroyed successfully."]
    pub fn sbgInterfaceDestroy(pInterface: *mut SbgInterface) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Returns the interface as string.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance\n \\return\t\t\t\t\t\t\t\t\t\t\t\tThe interface type."]
    pub fn sbgInterfaceTypeGetAsString(
        pInterface: *const SbgInterface,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Define the interface name as a NULL terminated C string.\n\n This method make sure that the provided string will always fit within\n the allocated name buffer.\n\n If the interface name you would like to set is too long, only the end\n of the string will be kept.\n\n \\param[in]\tpInterface\t\t\t\t\t\t\t\tInterface instance\n \\param[in]\tpName\t\t\t\t\t\t\t\t\tThe interface name to set as a NULL terminated C string"]
    pub fn sbgInterfaceNameSet(pInterface: *mut SbgInterface, pName: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = "\tInitialize a serial interface for read and write operations.\n\n\t\\param[in]\tpInterface\t\t\t\t\t\tPointer on an allocated interface instance to initialize.\n\t\\param[in]\tdeviceName\t\t\t\t\t\tSerial interface location (COM21 , /dev/ttys0, depending on platform).\n\t\\param[in]\tbaudRate\t\t\t\t\t\tSerial interface baud rate in bps.\n\t\\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the interface has been created."]
    pub fn sbgInterfaceSerialCreate(
        pInterface: *mut SbgInterface,
        deviceName: *const ::core::ffi::c_char,
        baudRate: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tOpen a file as an interface for read only operations.\n\n\t\\param[in]\tpInterface\t\t\t\t\t\tPointer on an allocated interface instance to initialize.\n\t\\param[in]\tfilePath\t\t\t\t\t\tFile path to open.\n\t\\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the interface has been created."]
    pub fn sbgInterfaceFileOpen(
        pInterface: *mut SbgInterface,
        filePath: *const ::core::ffi::c_char,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tOpen a file as an interface for write only operations.\n\n\t\\param[in]\tpInterface\t\t\t\t\t\tPointer on an allocated interface instance to initialize.\n\t\\param[in]\tfilePath\t\t\t\t\t\tFile path to open.\n\t\\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the interface has been created."]
    pub fn sbgInterfaceFileWriteOpen(
        pInterface: *mut SbgInterface,
        filePath: *const ::core::ffi::c_char,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tReturns the file size in bytes.\n\n\t\\param[in]\tpInterface\t\t\t\t\t\tValid handle on an initialized interface.\n\t\\return\t\t\t\t\t\t\t\t\t\tThe file size in bytes."]
    pub fn sbgInterfaceFileGetSize(pInterface: *mut SbgInterface) -> usize;
}
extern "C" {
    #[doc = "\tReturns the current cursor position in the file in bytes.\n\n\t\\param[in]\tpInterface\t\t\t\t\t\tValid handle on an initialized interface.\n\t\\return\t\t\t\t\t\t\t\t\t\tThe current cursor position in bytes."]
    pub fn sbgInterfaceFileGetCursor(pInterface: *const SbgInterface) -> usize;
}
#[doc = " Defines the ECom transfer states"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgSplitBuffer {
    #[doc = "< Pointer on the buffer that needs to be split"]
    pub pLinkedBuffer: *mut u8,
    #[doc = "< Size of the original buffer"]
    pub linkedBufferSize: usize,
    #[doc = "< The size of the sub buffers"]
    pub subBufferSize: usize,
    #[doc = "< The number of sub buffers in this split buffer"]
    pub subBufferNbr: usize,
}
#[test]
fn bindgen_test_layout__SbgSplitBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgSplitBuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgSplitBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(_SbgSplitBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgSplitBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgSplitBuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pLinkedBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgSplitBuffer),
            "::",
            stringify!(pLinkedBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkedBufferSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgSplitBuffer),
            "::",
            stringify!(linkedBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subBufferSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgSplitBuffer),
            "::",
            stringify!(subBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subBufferNbr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgSplitBuffer),
            "::",
            stringify!(subBufferNbr)
        )
    );
}
#[doc = " Defines the ECom transfer states"]
pub type SbgSplitBuffer = _SbgSplitBuffer;
#[doc = "< This stream buffer can perform read operations."]
pub const _SbgSBMode_SB_MODE_READ: _SbgSBMode = 0;
#[doc = "< This stream buffer can perform write operations."]
pub const _SbgSBMode_SB_MODE_WRITE: _SbgSBMode = 1;
#[doc = " Stream buffer modes."]
pub type _SbgSBMode = ::core::ffi::c_uint;
#[doc = " Stream buffer modes."]
pub use self::_SbgSBMode as SbgSBMode;
#[doc = "< The offset is referenced to the begining of the stream."]
pub const _SbgSBSeekOrigin_SB_SEEK_SET: _SbgSBSeekOrigin = 0;
#[doc = "< The offset is referenced to the current cursor position and increment the current cursor."]
pub const _SbgSBSeekOrigin_SB_SEEK_CUR_INC: _SbgSBSeekOrigin = 1;
#[doc = "< The offset is referenced to the current cursor position and decrement the current cursor."]
pub const _SbgSBSeekOrigin_SB_SEEK_CUR_DEC: _SbgSBSeekOrigin = 2;
#[doc = "< The offset is referenced to the end of the stream."]
pub const _SbgSBSeekOrigin_SB_SEEK_END: _SbgSBSeekOrigin = 3;
#[doc = " Enum used to define all seek modes"]
pub type _SbgSBSeekOrigin = ::core::ffi::c_uint;
#[doc = " Enum used to define all seek modes"]
pub use self::_SbgSBSeekOrigin as SbgSBSeekOrigin;
#[doc = " Defines a stream buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgStreamBuffer {
    #[doc = "< Defines the stream buffer modes (read/write)."]
    pub modes: SbgSBMode,
    #[doc = "< Size in bytes of the linked buffer."]
    pub bufferSize: usize,
    #[doc = "< Pointer to the buffer linked with this stream."]
    pub pBufferPtr: *mut u8,
    #[doc = "< Current pointer within the buffer."]
    pub pCurrentPtr: *mut u8,
    #[doc = "< Current error code on stream buffer."]
    pub errorCode: SbgErrorCode,
}
#[test]
fn bindgen_test_layout__SbgStreamBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgStreamBuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgStreamBuffer>(),
        20usize,
        concat!("Size of: ", stringify!(_SbgStreamBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgStreamBuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgStreamBuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgStreamBuffer),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgStreamBuffer),
            "::",
            stringify!(bufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBufferPtr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgStreamBuffer),
            "::",
            stringify!(pBufferPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pCurrentPtr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgStreamBuffer),
            "::",
            stringify!(pCurrentPtr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgStreamBuffer),
            "::",
            stringify!(errorCode)
        )
    );
}
#[doc = " Defines a stream buffer."]
pub type SbgStreamBuffer = _SbgStreamBuffer;
extern "C" {
    #[doc = " Convert an ip to a string of the form A.B.C.D\n \\param[in]\tipAddr\t\t\t\t\t\tIP address to convert to a string.\n \\param[out]\tpBuffer\t\t\t\t\t\tPointer on an allocated buffer than can hold ip address as a string.\n \\param[in]\tmaxSize\t\t\t\t\t\tMaximum number of chars that can be stored in pBuffer including the NULL char."]
    pub fn sbgNetworkIpToString(
        ipAddr: sbgIpAddress,
        pBuffer: *mut ::core::ffi::c_char,
        maxSize: usize,
    );
}
extern "C" {
    #[doc = " Convert an ip address stored in a string of the form A.B.C.D to an sbgIpAddress object.\n \\param[in]\tpBuffer\t\t\t\t\t\tIP address as a string of the form A.B.C.D\n \\return\t\t\t\t\t\t\t\t\tIP address parsed from the string or 0.0.0.0 if the IP is invalid."]
    pub fn sbgNetworkIpFromString(pBuffer: *const ::core::ffi::c_char) -> sbgIpAddress;
}
extern "C" {
    #[doc = " Check if an IpV4 netmask is valid, the mask should be contiguous (1111 followed by 0)\n \\param[in]\tnetmask\t\t\t\t\t\t\tThe netmask stored in an uint32_t (host endianness).\n \\return\t\t\t\t\t\t\t\t\t\ttrue if the netmask is valid ie contiguous."]
    pub fn sbgIpNetMaskValid(netmask: sbgIpAddress) -> bool;
}
pub const _SbgECanMessageId_SBG_ECAN_MSG_STATUS_01: _SbgECanMessageId = 256;
pub const _SbgECanMessageId_SBG_ECAN_MSG_STATUS_02: _SbgECanMessageId = 257;
pub const _SbgECanMessageId_SBG_ECAN_MSG_STATUS_03: _SbgECanMessageId = 258;
pub const _SbgECanMessageId_SBG_ECAN_MSG_UTC_0: _SbgECanMessageId = 272;
pub const _SbgECanMessageId_SBG_ECAN_MSG_UTC_1: _SbgECanMessageId = 273;
pub const _SbgECanMessageId_SBG_ECAN_MSG_IMU_INFO: _SbgECanMessageId = 288;
pub const _SbgECanMessageId_SBG_ECAN_MSG_IMU_ACCEL: _SbgECanMessageId = 289;
pub const _SbgECanMessageId_SBG_ECAN_MSG_IMU_GYRO: _SbgECanMessageId = 290;
pub const _SbgECanMessageId_SBG_ECAN_MSG_IMU_DELTA_VEL: _SbgECanMessageId = 291;
pub const _SbgECanMessageId_SBG_ECAN_MSG_IMU_DELTA_ANGLE: _SbgECanMessageId = 292;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_INFO: _SbgECanMessageId = 304;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_QUAT: _SbgECanMessageId = 305;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_EULER: _SbgECanMessageId = 306;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_ORIENTATION_ACC: _SbgECanMessageId = 307;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_POS: _SbgECanMessageId = 308;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_ALTITUDE: _SbgECanMessageId = 309;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_POS_ACC: _SbgECanMessageId = 310;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_VEL_NED: _SbgECanMessageId = 311;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_VEL_NED_ACC: _SbgECanMessageId = 312;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EKF_VEL_BODY: _SbgECanMessageId = 313;
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_INFO: _SbgECanMessageId = 320;
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_0: _SbgECanMessageId = 321;
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_1: _SbgECanMessageId = 325;
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_2: _SbgECanMessageId = 329;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_HP_INFO: _SbgECanMessageId = 330;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_HP_0: _SbgECanMessageId = 331;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_HP_1: _SbgECanMessageId = 332;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_SHIP_MOTION_HP_2: _SbgECanMessageId = 333;
pub const _SbgECanMessageId_SBG_ECAN_MSG_MAG_0: _SbgECanMessageId = 336;
pub const _SbgECanMessageId_SBG_ECAN_MSG_MAG_1: _SbgECanMessageId = 337;
pub const _SbgECanMessageId_SBG_ECAN_MSG_MAG_2: _SbgECanMessageId = 338;
pub const _SbgECanMessageId_SBG_ECAN_MSG_ODO_INFO: _SbgECanMessageId = 352;
pub const _SbgECanMessageId_SBG_ECAN_MSG_ODO_VEL: _SbgECanMessageId = 353;
pub const _SbgECanMessageId_SBG_ECAN_MSG_AIR_DATA_INFO: _SbgECanMessageId = 354;
pub const _SbgECanMessageId_SBG_ECAN_MSG_AIR_DATA_ALTITUDE: _SbgECanMessageId = 355;
pub const _SbgECanMessageId_SBG_ECAN_MSG_AIR_DATA_AIRSPEED: _SbgECanMessageId = 356;
pub const _SbgECanMessageId_SBG_ECAN_MSG_DEPTH_INFO: _SbgECanMessageId = 358;
pub const _SbgECanMessageId_SBG_ECAN_MSG_DEPTH_ALTITUDE: _SbgECanMessageId = 359;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_VEL_INFO: _SbgECanMessageId = 368;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_VEL: _SbgECanMessageId = 369;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_VEL_ACC: _SbgECanMessageId = 370;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_VEL_COURSE: _SbgECanMessageId = 371;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_POS_INFO: _SbgECanMessageId = 372;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_POS: _SbgECanMessageId = 373;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_POS_ALT: _SbgECanMessageId = 374;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_POS_ACC: _SbgECanMessageId = 375;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_HDT_INFO: _SbgECanMessageId = 376;
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS1_HDT: _SbgECanMessageId = 377;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_VEL_INFO: _SbgECanMessageId = 384;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_VEL: _SbgECanMessageId = 385;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_VEL_ACC: _SbgECanMessageId = 386;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_VEL_COURSE: _SbgECanMessageId = 387;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_POS_INFO: _SbgECanMessageId = 388;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_POS: _SbgECanMessageId = 389;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_POS_ALT: _SbgECanMessageId = 390;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_POS_ACC: _SbgECanMessageId = 391;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_HDT_INFO: _SbgECanMessageId = 392;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_GPS2_HDT: _SbgECanMessageId = 393;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_INFO_A: _SbgECanMessageId = 512;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_TIME_A: _SbgECanMessageId = 513;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_INFO_B: _SbgECanMessageId = 514;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_TIME_B: _SbgECanMessageId = 515;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_INFO_C: _SbgECanMessageId = 516;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_TIME_C: _SbgECanMessageId = 517;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_INFO_D: _SbgECanMessageId = 518;
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_TIME_D: _SbgECanMessageId = 519;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_INFO_E: _SbgECanMessageId = 520;
#[doc = "< Only for Ekinox, Apogee, Navsight & Quanta"]
pub const _SbgECanMessageId_SBG_ECAN_MSG_EVENT_TIME_E: _SbgECanMessageId = 521;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_DATINF: _SbgECanMessageId = 528;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_ACCS: _SbgECanMessageId = 529;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_OMGS: _SbgECanMessageId = 530;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_NRPY: _SbgECanMessageId = 531;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_VEL: _SbgECanMessageId = 532;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_TIME: _SbgECanMessageId = 533;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_GPS_INF: _SbgECanMessageId = 534;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_GPS_COG: _SbgECanMessageId = 535;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_ADDINF: _SbgECanMessageId = 536;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_POS1: _SbgECanMessageId = 537;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_POS2: _SbgECanMessageId = 538;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_SAT_INF: _SbgECanMessageId = 539;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_IACCS: _SbgECanMessageId = 540;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_IOMG: _SbgECanMessageId = 541;
pub const _SbgECanMessageId_SBG_ECAN_MSG_CASS_RR: _SbgECanMessageId = 542;
pub const _SbgECanMessageId_SBG_ECAN_MSG_AUTO_TRACK_SLIP_CURV: _SbgECanMessageId = 544;
#[doc = " Enum containing the list of messages that can be output on the can interface."]
pub type _SbgECanMessageId = ::core::ffi::c_uint;
#[doc = " Enum containing the list of messages that can be output on the can interface."]
pub use self::_SbgECanMessageId as SbgECanMessageId;
#[doc = "< Class that contains sbgECom protocol input/output log messages."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_ECOM_0: _SbgEComClass = 0;
#[doc = "< Class that contains special sbgECom output messages that handle high frequency output."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_ECOM_1: _SbgEComClass = 1;
#[doc = "< Class that contains NMEA (and NMEA like) output logs. <br>\nNote: This class is only used for identification purpose and does not contain any sbgECom message."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_NMEA_0: _SbgEComClass = 2;
#[doc = "< Class that contains proprietary NMEA (and NMEA like) output logs. <br>\nNote: This class is only used for identification purpose and does not contain any sbgECom message."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_NMEA_1: _SbgEComClass = 3;
#[doc = "< Class that contains third party output logs.\nNote: This class is only used for identification purpose and does not contain any sbgECom message."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_THIRD_PARTY_0: _SbgEComClass = 4;
#[doc = "< Class that contains sbgECom protocol commands."]
pub const _SbgEComClass_SBG_ECOM_CLASS_LOG_CMD_0: _SbgEComClass = 16;
#[doc = " Enum that defines all the message classes available.\n\n Keep in mind that message classes are encoded on 7 bits."]
pub type _SbgEComClass = ::core::ffi::c_uint;
#[doc = " Enum that defines all the message classes available.\n\n Keep in mind that message classes are encoded on 7 bits."]
pub use self::_SbgEComClass as SbgEComClass;
#[doc = "< Status general, clock, com aiding, solution, heave"]
pub const _SbgEComLog_SBG_ECOM_LOG_STATUS: _SbgEComLog = 1;
#[doc = "< Provides UTC time reference"]
pub const _SbgEComLog_SBG_ECOM_LOG_UTC_TIME: _SbgEComLog = 2;
#[doc = "< Includes IMU status, acc., gyro, temp delta speeds and delta angles values"]
pub const _SbgEComLog_SBG_ECOM_LOG_IMU_DATA: _SbgEComLog = 3;
#[doc = "< Magnetic data with associated accelerometer on each axis"]
pub const _SbgEComLog_SBG_ECOM_LOG_MAG: _SbgEComLog = 4;
#[doc = "< Magnetometer calibration data (raw buffer)"]
pub const _SbgEComLog_SBG_ECOM_LOG_MAG_CALIB: _SbgEComLog = 5;
#[doc = "< Includes roll, pitch, yaw and their accuracies on each axis"]
pub const _SbgEComLog_SBG_ECOM_LOG_EKF_EULER: _SbgEComLog = 6;
#[doc = "< Includes the 4 quaternions values"]
pub const _SbgEComLog_SBG_ECOM_LOG_EKF_QUAT: _SbgEComLog = 7;
#[doc = "< Position and velocities in NED coordinates with the accuracies on each axis"]
pub const _SbgEComLog_SBG_ECOM_LOG_EKF_NAV: _SbgEComLog = 8;
#[doc = "< Heave, surge and sway and accelerations on each axis."]
pub const _SbgEComLog_SBG_ECOM_LOG_SHIP_MOTION: _SbgEComLog = 9;
#[doc = "< GPS velocities from primary or secondary GPS receiver"]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS1_VEL: _SbgEComLog = 13;
#[doc = "< GPS positions from primary or secondary GPS receiver"]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS1_POS: _SbgEComLog = 14;
#[doc = "< GPS true heading from dual antenna system"]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS1_HDT: _SbgEComLog = 15;
#[doc = "< GPS 1 raw data for post processing."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS1_RAW: _SbgEComLog = 31;
#[doc = "< GPS 1 Satellite data."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS1_SAT: _SbgEComLog = 50;
#[doc = "< GPS 2 velocity log data."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS2_VEL: _SbgEComLog = 16;
#[doc = "< GPS 2 position log data."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS2_POS: _SbgEComLog = 17;
#[doc = "< GPS 2 true heading log data."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS2_HDT: _SbgEComLog = 18;
#[doc = "< GPS 2 raw data for post processing."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS2_RAW: _SbgEComLog = 38;
#[doc = "< GNSS2 Satellite data."]
pub const _SbgEComLog_SBG_ECOM_LOG_GPS2_SAT: _SbgEComLog = 51;
#[doc = "< Provides odometer velocity"]
pub const _SbgEComLog_SBG_ECOM_LOG_ODO_VEL: _SbgEComLog = 19;
#[doc = "< Event markers sent when events are detected on sync in A pin"]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_A: _SbgEComLog = 24;
#[doc = "< Event markers sent when events are detected on sync in B pin"]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_B: _SbgEComLog = 25;
#[doc = "< Event markers sent when events are detected on sync in C pin"]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_C: _SbgEComLog = 26;
#[doc = "< Event markers sent when events are detected on sync in D pin"]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_D: _SbgEComLog = 27;
#[doc = "< Event markers sent when events are detected on sync in E pin"]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_E: _SbgEComLog = 28;
#[doc = "< Doppler Velocity Log for bottom tracking data."]
pub const _SbgEComLog_SBG_ECOM_LOG_DVL_BOTTOM_TRACK: _SbgEComLog = 29;
#[doc = "< Doppler Velocity log for water layer data."]
pub const _SbgEComLog_SBG_ECOM_LOG_DVL_WATER_TRACK: _SbgEComLog = 30;
#[doc = "< Return delayed ship motion such as surge, sway, heave."]
pub const _SbgEComLog_SBG_ECOM_LOG_SHIP_MOTION_HP: _SbgEComLog = 32;
#[doc = "< Air Data aiding such as barometric altimeter and true air speed."]
pub const _SbgEComLog_SBG_ECOM_LOG_AIR_DATA: _SbgEComLog = 36;
#[doc = "< Raw USBL position data for subsea navigation."]
pub const _SbgEComLog_SBG_ECOM_LOG_USBL: _SbgEComLog = 37;
#[doc = "< Short IMU message recommended for post processing usages."]
pub const _SbgEComLog_SBG_ECOM_LOG_IMU_SHORT: _SbgEComLog = 44;
#[doc = "< Event marker used to time stamp each generated Sync Out A signal."]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_OUT_A: _SbgEComLog = 45;
#[doc = "< Event marker used to time stamp each generated Sync Out B signal."]
pub const _SbgEComLog_SBG_ECOM_LOG_EVENT_OUT_B: _SbgEComLog = 46;
#[doc = "< Depth sensor measurement log used for subsea navigation."]
pub const _SbgEComLog_SBG_ECOM_LOG_DEPTH: _SbgEComLog = 47;
#[doc = "< Diagnostic log."]
pub const _SbgEComLog_SBG_ECOM_LOG_DIAG: _SbgEComLog = 48;
#[doc = "< RTCM raw data."]
pub const _SbgEComLog_SBG_ECOM_LOG_RTCM_RAW: _SbgEComLog = 49;
#[doc = "< Helper definition to know the number of ECom messages"]
pub const _SbgEComLog_SBG_ECOM_LOG_ECOM_NUM_MESSAGES: _SbgEComLog = 50;
#[doc = " Enum that defines all the available ECom output logs from the sbgECom library."]
pub type _SbgEComLog = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available ECom output logs from the sbgECom library."]
pub use self::_SbgEComLog as SbgEComLog;
#[doc = "< Provides accelerometers, gyroscopes, time and status at 1KHz rate."]
pub const _SbgEComLog1MsgId_SBG_ECOM_LOG_FAST_IMU_DATA: _SbgEComLog1MsgId = 0;
#[doc = "< Helper definition to know the number of ECom messages"]
pub const _SbgEComLog1MsgId_SBG_ECOM_LOG_ECOM_1_NUM_MESSAGES: _SbgEComLog1MsgId = 1;
#[doc = " Enum that defines all the available ECom output logs in the class SBG_ECOM_CLASS_LOG_ECOM_1"]
pub type _SbgEComLog1MsgId = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available ECom output logs in the class SBG_ECOM_CLASS_LOG_ECOM_1"]
pub use self::_SbgEComLog1MsgId as SbgEComLog1;
#[doc = "< Latitude, Longitude, Altitude, Quality indicator."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_GGA: _SbgEComNmeaLog = 0;
#[doc = "< Latitude, Longitude, velocity, course over ground."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_RMC: _SbgEComNmeaLog = 1;
#[doc = "< UTC Time."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_ZDA: _SbgEComNmeaLog = 2;
#[doc = "< Heading (True)."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_HDT: _SbgEComNmeaLog = 3;
#[doc = "< GPS Pseudorange Noise Statistics."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_GST: _SbgEComNmeaLog = 4;
#[doc = "< Water referenced and ground referenced speed data."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_VBW: _SbgEComNmeaLog = 5;
#[doc = "< Depth sensor output."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_DPT: _SbgEComNmeaLog = 7;
#[doc = "< Track an Speed over the ground."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_VTG: _SbgEComNmeaLog = 8;
#[doc = "< Rate and direction of turn."]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_RTO: _SbgEComNmeaLog = 9;
#[doc = "< GNSS Satellites in View with azimuth, elevation and SNR information"]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_GSV: _SbgEComNmeaLog = 10;
#[doc = "< Helper definition to know the number of NMEA messages"]
pub const _SbgEComNmeaLog_SBG_ECOM_LOG_NMEA_NUM_MESSAGES: _SbgEComNmeaLog = 11;
#[doc = " Enum that defines all the available Nmea output logs from the sbgECom library."]
pub type _SbgEComNmeaLog = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available Nmea output logs from the sbgECom library."]
pub use self::_SbgEComNmeaLog as SbgEComNmeaLog;
#[doc = "< RDI proprietary sentence. Pitch, Roll, Heading"]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PRDID: _SbgEComIdNmea1Log = 0;
#[doc = "< SBG Systems proprietary sentence. Rotation rates, accelerations."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PSBGI: _SbgEComIdNmea1Log = 1;
#[doc = "< Proprietary sentence. Roll, Pitch, Heading, Heave."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PASHR: _SbgEComIdNmea1Log = 2;
#[doc = "< SBG Systems proprietary sentence. Attitude, heading, heave, angular rates, velocity."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PSBGB: _SbgEComIdNmea1Log = 3;
#[doc = "< Ixblue NMEA like log used to output Status information."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PHINF: _SbgEComIdNmea1Log = 5;
#[doc = "< Ixblue NMEA like log used to output Roll and Pitch."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PHTRO: _SbgEComIdNmea1Log = 6;
#[doc = "< Ixblue NMEA like log used to output Surge, Sway and Heave."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PHLIN: _SbgEComIdNmea1Log = 7;
#[doc = "< Ixblue NMEA like log used to output attitude and ship motion."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PHOCT: _SbgEComIdNmea1Log = 8;
#[doc = "< Ixblue NMEA like log used to output position, heading, attitude, attitude rate and speed."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_INDYN: _SbgEComIdNmea1Log = 9;
#[doc = "< Trimble NMEA like log with Time, Latitude, Longitude, Ellipsoidal height"]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_GGK: _SbgEComIdNmea1Log = 10;
#[doc = "< Trimble (Applanix) NMEA like log with UTC and PPS information."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PPS: _SbgEComIdNmea1Log = 11;
#[doc = "< WASSP NMEA like log similar to PASHR one."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_WASSP: _SbgEComIdNmea1Log = 12;
#[doc = "< SBG Systems proprietary sentence that reports EKF attitude and status."]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_PSBGA: _SbgEComIdNmea1Log = 13;
#[doc = "< Helper definition to know the number of NMEA messages"]
pub const _SbgEComIdNmea1Log_SBG_ECOM_LOG_NMEA_1_NUM_MESSAGES: _SbgEComIdNmea1Log = 14;
#[doc = " Enum that defines all the available Proprietary Nmea output logs from the sbgECom library."]
pub type _SbgEComIdNmea1Log = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available Proprietary Nmea output logs from the sbgECom library."]
pub use self::_SbgEComIdNmea1Log as SbgEComIdNmea1Log;
#[doc = "< Roll, Pitch, Heave, heave accelerations"]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_TSS1: _SbgEComIdThirdParty = 0;
#[doc = "< Roll, Pitch, Yaw"]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_KVH: _SbgEComIdThirdParty = 1;
#[doc = "< Teledyne PD0 DVL proprietary frame."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_PD0: _SbgEComIdThirdParty = 2;
#[doc = "< Konsberg SimRad 1000 proprietary frame that outputs Roll, Pitch and Heading."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_SIMRAD_1000: _SbgEComIdThirdParty = 3;
#[doc = "< Konsberg SimRad 3000 proprietary frame that outputs Roll, Pitch and Heading."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_SIMRAD_3000: _SbgEComIdThirdParty = 4;
#[doc = "< Konsberg Seapth Binary Log 26 used for MBES FM mode."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_SEAPATH_B26: _SbgEComIdThirdParty = 5;
#[doc = "< DOLOG Heading, Roll, Pitch proprietary and binary message."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_DOLOG_HRP: _SbgEComIdThirdParty = 6;
#[doc = "< Crossbow AHRS-500 Data Packet output with attitude, rate, acceleration and status."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_AHRS_500: _SbgEComIdThirdParty = 7;
#[doc = "< ADA specific Data Packet with IMU/INS/Status data"]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_ADA_01: _SbgEComIdThirdParty = 8;
#[doc = "< Cobham Aviator UAV 200 navigation (orientation & position) data"]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_AT_ITINS: _SbgEComIdThirdParty = 9;
#[doc = "< Kongsberg multibeam binary log."]
pub const _SbgEComIdThirdParty_SBG_ECOM_THIRD_PARTY_KONGSBERG_MB: _SbgEComIdThirdParty = 10;
#[doc = "< Helper definition to know the number of third party messages"]
pub const _SbgEComIdThirdParty_SBG_ECOM_LOG_THIRD_PARTY_NUM_MESSAGES: _SbgEComIdThirdParty = 11;
#[doc = " Enum that defines all the available Proprietary output logs from the sbgECom library."]
pub type _SbgEComIdThirdParty = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available Proprietary output logs from the sbgECom library."]
pub use self::_SbgEComIdThirdParty as SbgEComIdThirdParty;
#[doc = "< Acknowledge"]
pub const _SbgEComCmd_SBG_ECOM_CMD_ACK: _SbgEComCmd = 0;
#[doc = "< Performs various settings actions"]
pub const _SbgEComCmd_SBG_ECOM_CMD_SETTINGS_ACTION: _SbgEComCmd = 1;
#[doc = "< Imports a new settings structure to the sensor"]
pub const _SbgEComCmd_SBG_ECOM_CMD_IMPORT_SETTINGS: _SbgEComCmd = 2;
#[doc = "< Export the whole configuration from the sensor"]
pub const _SbgEComCmd_SBG_ECOM_CMD_EXPORT_SETTINGS: _SbgEComCmd = 3;
#[doc = "< Get basic device information"]
pub const _SbgEComCmd_SBG_ECOM_CMD_INFO: _SbgEComCmd = 4;
#[doc = "< Initial configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_INIT_PARAMETERS: _SbgEComCmd = 5;
#[doc = "< Set/get motion profile information"]
pub const _SbgEComCmd_SBG_ECOM_CMD_MOTION_PROFILE_ID: _SbgEComCmd = 7;
#[doc = "< Sensor alignment and lever arm on vehicle configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_IMU_ALIGNMENT_LEVER_ARM: _SbgEComCmd = 8;
#[doc = "< Aiding assignments such as RTCM / GPS / Odometer configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_AIDING_ASSIGNMENT: _SbgEComCmd = 9;
#[doc = "< Set/get magnetometer error model information"]
pub const _SbgEComCmd_SBG_ECOM_CMD_MAGNETOMETER_MODEL_ID: _SbgEComCmd = 11;
#[doc = "< Magnetometer aiding rejection mode"]
pub const _SbgEComCmd_SBG_ECOM_CMD_MAGNETOMETER_REJECT_MODE: _SbgEComCmd = 12;
#[doc = "< Set magnetic soft and hard Iron calibration data"]
pub const _SbgEComCmd_SBG_ECOM_CMD_SET_MAG_CALIB: _SbgEComCmd = 13;
#[doc = "< Start / reset internal magnetic field logging for calibration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_START_MAG_CALIB: _SbgEComCmd = 14;
#[doc = "< Compute a magnetic calibration based on previously logged data."]
pub const _SbgEComCmd_SBG_ECOM_CMD_COMPUTE_MAG_CALIB: _SbgEComCmd = 15;
#[doc = "< Set/get GNSS model information"]
pub const _SbgEComCmd_SBG_ECOM_CMD_GNSS_1_MODEL_ID: _SbgEComCmd = 17;
#[doc = "< DEPRECATED: GNSS installation configuration (lever arm, antenna alignments)"]
pub const _SbgEComCmd_SBG_ECOM_CMD_GNSS_1_LEVER_ARM_ALIGNMENT: _SbgEComCmd = 18;
#[doc = "< Define or retrieve the GNSS 1 main and secondary lever arms configuration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_GNSS_1_INSTALLATION: _SbgEComCmd = 46;
#[doc = "< GNSS aiding rejection modes configuration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_GNSS_1_REJECT_MODES: _SbgEComCmd = 19;
#[doc = "< Odometer gain, direction configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_ODO_CONF: _SbgEComCmd = 20;
#[doc = "< Odometer installation configuration (lever arm)"]
pub const _SbgEComCmd_SBG_ECOM_CMD_ODO_LEVER_ARM: _SbgEComCmd = 21;
#[doc = "< Odometer aiding rejection mode configuration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_ODO_REJECT_MODE: _SbgEComCmd = 22;
#[doc = "< UART interfaces configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_UART_CONF: _SbgEComCmd = 23;
#[doc = "< CAN bus interface configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_CAN_BUS_CONF: _SbgEComCmd = 24;
#[doc = "< CAN identifiers configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_CAN_OUTPUT_CONF: _SbgEComCmd = 25;
#[doc = "< Synchronization inputs configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_SYNC_IN_CONF: _SbgEComCmd = 26;
#[doc = "< Synchronization outputs configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_SYNC_OUT_CONF: _SbgEComCmd = 27;
#[doc = "< NMEA talker ID configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_NMEA_TALKER_ID: _SbgEComCmd = 29;
#[doc = "< Output configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_OUTPUT_CONF: _SbgEComCmd = 30;
#[doc = "< Advanced settings configuration"]
pub const _SbgEComCmd_SBG_ECOM_CMD_ADVANCED_CONF: _SbgEComCmd = 32;
#[doc = "< Retrieve device features"]
pub const _SbgEComCmd_SBG_ECOM_CMD_FEATURES: _SbgEComCmd = 33;
#[doc = "< Upload and apply a new license"]
pub const _SbgEComCmd_SBG_ECOM_CMD_LICENSE_APPLY: _SbgEComCmd = 34;
#[doc = "< Enable/disable the output of an entire class"]
pub const _SbgEComCmd_SBG_ECOM_CMD_OUTPUT_CLASS_ENABLE: _SbgEComCmd = 35;
#[doc = "< Set/get Ethernet configuration such as DHCP mode and IP address."]
pub const _SbgEComCmd_SBG_ECOM_CMD_ETHERNET_CONF: _SbgEComCmd = 36;
#[doc = "< Return the current IP used by the device."]
pub const _SbgEComCmd_SBG_ECOM_CMD_ETHERNET_INFO: _SbgEComCmd = 37;
#[doc = "< Set/get Validity flag thresholds for position, velocity, attitude and heading"]
pub const _SbgEComCmd_SBG_ECOM_CMD_VALIDITY_THRESHOLDS: _SbgEComCmd = 38;
#[doc = "< Set/get DVL model id to use"]
pub const _SbgEComCmd_SBG_ECOM_CMD_DVL_MODEL_ID: _SbgEComCmd = 39;
#[doc = "< DVL installation configuration (lever arm, alignments)"]
pub const _SbgEComCmd_SBG_ECOM_CMD_DVL_INSTALLATION: _SbgEComCmd = 40;
#[doc = "< DVL aiding rejection modes configuration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_DVL_REJECT_MODES: _SbgEComCmd = 41;
#[doc = "< Set/get AirData model id and protocol to use."]
pub const _SbgEComCmd_SBG_ECOM_CMD_AIRDATA_MODEL_ID: _SbgEComCmd = 42;
#[doc = "< AirData installation configuration (lever arm, offsets)"]
pub const _SbgEComCmd_SBG_ECOM_CMD_AIRDATA_LEVER_ARM: _SbgEComCmd = 43;
#[doc = "< AirData aiding rejection modes configuration."]
pub const _SbgEComCmd_SBG_ECOM_CMD_AIRDATA_REJECT_MODES: _SbgEComCmd = 44;
#[doc = "< Configuration for CAN based odometer (CAN ID & DBC)"]
pub const _SbgEComCmd_SBG_ECOM_CMD_ODO_CAN_CONF: _SbgEComCmd = 45;
#[doc = "< Command equivalent to the HTTP GET method for a REST API."]
pub const _SbgEComCmd_SBG_ECOM_CMD_API_GET: _SbgEComCmd = 46;
#[doc = "< Command equivalent to the HTTP POST method for a REST API."]
pub const _SbgEComCmd_SBG_ECOM_CMD_API_POST: _SbgEComCmd = 47;
#[doc = "< Helper definition to know the number of commands"]
pub const _SbgEComCmd_SBG_ECOM_LOG_ECOM_NUM_CMDS: _SbgEComCmd = 48;
#[doc = " Enum that defines all the available commands for the sbgECom library."]
pub type _SbgEComCmd = ::core::ffi::c_uint;
#[doc = " Enum that defines all the available commands for the sbgECom library."]
pub use self::_SbgEComCmd as SbgEComCmd;
#[doc = "\tThis type defines any message identifier.\n\tBecause message identifiers enum will be different with each class id, we use a generic uint8_t rather than an enum."]
pub type SbgEComMsgId = u8;
#[doc = " Payload.\n\n This class is used to abstract whether some payload is received from a single\n or multiple frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComProtocolPayload {
    #[doc = "< True if the buffer is allocated with malloc()."]
    pub allocated: bool,
    #[doc = "< Buffer."]
    pub pBuffer: *mut ::core::ffi::c_void,
    #[doc = "< Buffer size, in bytes."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout__SbgEComProtocolPayload() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComProtocolPayload> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComProtocolPayload>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgEComProtocolPayload))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComProtocolPayload>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComProtocolPayload))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocolPayload),
            "::",
            stringify!(allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pBuffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocolPayload),
            "::",
            stringify!(pBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocolPayload),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Payload.\n\n This class is used to abstract whether some payload is received from a single\n or multiple frames."]
pub type SbgEComProtocolPayload = _SbgEComProtocolPayload;
#[doc = " Struct containing all protocol related data.\n\n The member variables related to large transfers are valid if and only if the large buffer is valid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComProtocol {
    #[doc = "< Associated interface used by the protocol to read/write bytes."]
    pub pLinkedInterface: *mut SbgInterface,
    #[doc = "< The reception buffer."]
    pub rxBuffer: [u8; 4096usize],
    #[doc = "< The current reception buffer size in bytes."]
    pub rxBufferSize: usize,
    #[doc = "< Number of bytes to discard on the next receive attempt."]
    pub discardSize: usize,
    #[doc = "< Transfer ID of the next large send."]
    pub nextLargeTxId: u8,
    #[doc = "< Buffer for large transfers, allocated with malloc() if valid."]
    pub pLargeBuffer: *mut u8,
    #[doc = "< Size of the large transfer buffer, in bytes."]
    pub largeBufferSize: usize,
    #[doc = "< Message class for the current large transfer."]
    pub msgClass: u8,
    #[doc = "< Message ID for the current large transfer."]
    pub msgId: u8,
    #[doc = "< ID of the current large transfer."]
    pub transferId: u8,
    #[doc = "< Expected page index of the next frame."]
    pub pageIndex: u16,
    #[doc = "< Number of pages in the current transfer."]
    pub nrPages: u16,
}
#[test]
fn bindgen_test_layout__SbgEComProtocol() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComProtocol> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComProtocol>(),
        4128usize,
        concat!("Size of: ", stringify!(_SbgEComProtocol))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComProtocol))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pLinkedInterface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(pLinkedInterface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxBuffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(rxBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxBufferSize) as usize - ptr as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(rxBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).discardSize) as usize - ptr as usize },
        4104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(discardSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nextLargeTxId) as usize - ptr as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(nextLargeTxId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pLargeBuffer) as usize - ptr as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(pLargeBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).largeBufferSize) as usize - ptr as usize },
        4116usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(largeBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgClass) as usize - ptr as usize },
        4120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(msgClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgId) as usize - ptr as usize },
        4121usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(msgId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transferId) as usize - ptr as usize },
        4122usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(transferId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pageIndex) as usize - ptr as usize },
        4124usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(pageIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrPages) as usize - ptr as usize },
        4126usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComProtocol),
            "::",
            stringify!(nrPages)
        )
    );
}
#[doc = " Struct containing all protocol related data.\n\n The member variables related to large transfers are valid if and only if the large buffer is valid."]
pub type SbgEComProtocol = _SbgEComProtocol;
extern "C" {
    #[doc = " Payload constructor.\n\n \\param[in]\tpPayload\t\t\t\tPayload."]
    pub fn sbgEComProtocolPayloadConstruct(pPayload: *mut SbgEComProtocolPayload);
}
extern "C" {
    #[doc = " Payload destructor.\n\n \\param[in]\tpPayload\t\t\t\tPayload."]
    pub fn sbgEComProtocolPayloadDestroy(pPayload: *mut SbgEComProtocolPayload);
}
extern "C" {
    #[doc = " Get the buffer of a payload.\n\n \\param[in]\tpPayload\t\t\t\tPayload.\n \\return\t\t\t\t\t\t\t\tPayload buffer."]
    pub fn sbgEComProtocolPayloadGetBuffer(
        pPayload: *const SbgEComProtocolPayload,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Get the size of a payload buffer.\n\n \\param[in]\tpPayload\t\t\t\tPayload.\n \\return\t\t\t\t\t\t\t\tSize of the payload buffer, in bytes."]
    pub fn sbgEComProtocolPayloadGetSize(pPayload: *const SbgEComProtocolPayload) -> usize;
}
extern "C" {
    #[doc = " Move the buffer of a payload.\n\n If successful, the ownership of the buffer is passed to the caller. Otherwise, the payload\n is unchanged.\n\n The buffer must be released with free() once unused.\n\n \\param[in]\tpPayload\t\t\t\tPayload.\n \\return\t\t\t\t\t\t\t\tPayload buffer if successful, NULL otherwise."]
    pub fn sbgEComProtocolPayloadMoveBuffer(
        pPayload: *mut SbgEComProtocolPayload,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Initialize the protocol system used to communicate with the product and return the created handle.\n\n \\param[in]\tpProtocol\t\t\t\tPointer on an allocated protocol structure to initialize.\n \\param[in]\tpInterface\t\t\t\tInterface to use for read/write operations.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if we have initialised the protocol system."]
    pub fn sbgEComProtocolInit(
        pProtocol: *mut SbgEComProtocol,
        pInterface: *mut SbgInterface,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Close the protocol system.\n\n \\param[in]\tpProtocol\t\t\t\tA valid protocol handle to close.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if we have closed and released the protocol system."]
    pub fn sbgEComProtocolClose(pProtocol: *mut SbgEComProtocol) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Purge the interface rx buffer as well as the sbgECom rx work buffer.\n\n For example, if the program flow has been interrupted, this method can be helpful to discard all trash received data.\n\n WARNING: This method is blocking for 100ms and actively tries to read incoming data.\n\n \\param[in]\tpProtocol\t\t\t\t\t\tA valid SbgEComProtocol handle.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the incoming data has been purged successfully."]
    pub fn sbgEComProtocolPurgeIncoming(pProtocol: *mut SbgEComProtocol) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Send data.\n\n If the size is SBG_ECOM_MAX_PAYLOAD_SIZE or less, the data is sent in a single frame. Otherwise,\n is it fragmented into multiple extended frames, each sent in order, which may block.\n\n \\param[in]\tpProtocol\t\t\t\tA valid protocol handle.\n \\param[in]\tmsgClass\t\t\t\tMessage class.\n \\param[in]\tmsg\t\t\t\t\t\tMessage ID.\n \\param[in]\tpData\t\t\t\t\tData buffer.\n \\param[in]\tsize\t\t\t\t\tData buffer size, in bytes.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if the frame has been sent."]
    pub fn sbgEComProtocolSend(
        pProtocol: *mut SbgEComProtocol,
        msgClass: u8,
        msg: u8,
        pData: *const ::core::ffi::c_void,
        size: usize,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Receive a frame.\n\n \\param[in]\tpProtocol\t\t\t\tA valid protocol handle.\n \\param[out]\tpMsgClass\t\t\t\tMessage class, may be NULL.\n \\param[out]\tpMsgId\t\t\t\t\tMessage ID, may be NULL.\n \\param[out]\tpData\t\t\t\t\tData buffer.\n \\param[out]\tpSize\t\t\t\t\tNumber of bytes received.\n \\param[in]\tmaxSize\t\t\t\t\tData buffer size, in bytes.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no complete frame has been received,\n\t\t\t\t\t\t\t\t\t\tSBG_BUFFER_OVERFLOW if the payload of the received frame couldn't fit into the data buffer."]
    pub fn sbgEComProtocolReceive(
        pProtocol: *mut SbgEComProtocol,
        pMsgClass: *mut u8,
        pMsgId: *mut u8,
        pData: *mut ::core::ffi::c_void,
        pSize: *mut usize,
        maxSize: usize,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Receive a frame.\n\n This function is equivalent to sbgEComProtocolReceive() with two exceptions :\n  - the use of a payload object allows handling payloads not limited by the size of a user-provided buffer\n  - the payload object allows direct access to the protocol work buffer to avoid an extra copy per call\n\n Any allocated resource associated with the given payload is released when calling this function.\n\n Because the payload buffer may directly refer to the protocol work buffer on return, it is only valid until\n the next attempt to receive a frame, with any of the receive functions.\n\n \\param[in]\tpProtocol\t\t\t\tA valid protocol handle.\n \\param[out]\tpMsgClass\t\t\t\tMessage class, may be NULL.\n \\param[out]\tpMsgId\t\t\t\t\tMessage ID, may be NULL.\n \\param[out]\tpPayload\t\t\t\tPayload.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no complete frame has been received."]
    pub fn sbgEComProtocolReceive2(
        pProtocol: *mut SbgEComProtocol,
        pMsgClass: *mut u8,
        pMsgId: *mut u8,
        pPayload: *mut SbgEComProtocolPayload,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Initialize an output stream for an sbgECom frame generation.\n\n This function is helpful to avoid memory copy compared to sbgEComProtocolSend one.\n\n Only standard frames may be sent with this function.\n\n \\param[in]\tpOutputStream\t\t\tPointer to an allocated and initialized output stream.\n \\param[in]\tmsgClass\t\t\t\tMessage class.\n \\param[in]\tmsg\t\t\t\t\t\tMessage ID.\n \\param[out]\tpStreamCursor\t\t\tThe initial output stream cursor that thus points to the begining of the generated message.\n\t\t\t\t\t\t\t\t\t\tThis value should be passed to sbgEComFinalizeFrameGeneration for correct operations.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR in case of good operation."]
    pub fn sbgEComStartFrameGeneration(
        pOutputStream: *mut SbgStreamBuffer,
        msgClass: u8,
        msg: u8,
        pStreamCursor: *mut usize,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Finalize an output stream that has been initialized with sbgEComStartFrameGeneration.\n\n At return, the output stream buffer should point at the end of the generated message.\n You can thus easily create consecutive SBG_ECOM_LOGS with these methods.\n\n \\param[in]\tpOutputStream\t\t\tPointer to an allocated and initialized output stream.\n \\param[in]\tstreamCursor\t\t\tPosition in the stream buffer of the generated message first byte.\n\t\t\t\t\t\t\t\t\t\tThis value is returned by sbgEComStartFrameGeneration and is mandatory for correct operations.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR in case of good operation."]
    pub fn sbgEComFinalizeFrameGeneration(
        pOutputStream: *mut SbgStreamBuffer,
        streamCursor: usize,
    ) -> SbgErrorCode;
}
#[doc = " Log structure for AirData."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogAirData {
    #[doc = "< Time in us since the sensor power up OR measurement delay in us."]
    pub timeStamp: u32,
    #[doc = "< Airdata sensor status bitmask."]
    pub status: u16,
    #[doc = "< Raw absolute pressure measured by the barometer sensor in Pascals."]
    pub pressureAbs: f32,
    #[doc = "< Altitude computed from barometric altimeter in meters and positive upward."]
    pub altitude: f32,
    #[doc = "< Raw differential pressure measured by the pitot tube in Pascal."]
    pub pressureDiff: f32,
    #[doc = "< True airspeed measured by a pitot tube in m.s^-1 and positive forward."]
    pub trueAirspeed: f32,
    #[doc = "< Outside air temperature in °C that could be used to compute true airspeed from differential pressure."]
    pub airTemperature: f32,
}
#[test]
fn bindgen_test_layout__SbgLogAirData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogAirData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogAirData>(),
        28usize,
        concat!("Size of: ", stringify!(_SbgLogAirData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogAirData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogAirData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressureAbs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(pressureAbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressureDiff) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(pressureDiff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trueAirspeed) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(trueAirspeed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).airTemperature) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogAirData),
            "::",
            stringify!(airTemperature)
        )
    );
}
#[doc = " Log structure for AirData."]
pub type SbgLogAirData = _SbgLogAirData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_AIR_DATA message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseAirData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogAirData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_AIR_DATA message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteAirData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogAirData,
    ) -> SbgErrorCode;
}
#[doc = " Log structure for Depth sensor measurement (subsea)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogDepth {
    #[doc = "< Time in us since the sensor power up OR measurement delay in us."]
    pub timeStamp: u32,
    #[doc = "< Airdata sensor status bitmask."]
    pub status: u16,
    #[doc = "< Raw absolute pressure measured by the depth sensor in Pascals."]
    pub pressureAbs: f32,
    #[doc = "< Altitude computed from depth sensor in meters and positive upward."]
    pub altitude: f32,
}
#[test]
fn bindgen_test_layout__SbgLogDepth() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogDepth> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogDepth>(),
        16usize,
        concat!("Size of: ", stringify!(_SbgLogDepth))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogDepth>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogDepth))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDepth),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDepth),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressureAbs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDepth),
            "::",
            stringify!(pressureAbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDepth),
            "::",
            stringify!(altitude)
        )
    );
}
#[doc = " Log structure for Depth sensor measurement (subsea)."]
pub type SbgLogDepth = _SbgLogDepth;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_DEPTH message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseDepth(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogDepth,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_DEPTH message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteDepth(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogDepth,
    ) -> SbgErrorCode;
}
#[doc = " Diagnostic log structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogDiagData {
    #[doc = "< Timestamp, in microseconds."]
    pub timestamp: u32,
    #[doc = "< Log type."]
    pub type_: SbgDebugLogType,
    #[doc = "< Error code."]
    pub errorCode: SbgErrorCode,
    #[doc = "< Log string, null-terminated."]
    pub string: [::core::ffi::c_char; 4080usize],
}
#[test]
fn bindgen_test_layout__SbgLogDiagData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogDiagData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogDiagData>(),
        4092usize,
        concat!("Size of: ", stringify!(_SbgLogDiagData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogDiagData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogDiagData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDiagData),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDiagData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorCode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDiagData),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDiagData),
            "::",
            stringify!(string)
        )
    );
}
#[doc = " Diagnostic log structure."]
pub type SbgLogDiagData = _SbgLogDiagData;
extern "C" {
    #[doc = "\tParse data for SBG_ECOM_LOG_DIAG messages and fill the corresponding structure.\n\n\t\\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n\t\\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n\t\\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseDiagData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogDiagData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for SBG_ECOM_LOG_DIAG messages to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteDiagData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogDiagData,
    ) -> SbgErrorCode;
}
#[doc = " Log structure for DVL data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogDvlData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< DVL status bitmask."]
    pub status: u16,
    #[doc = "< X, Y, Z velocities in m.s^-1 expressed in the DVL instrument frame."]
    pub velocity: [f32; 3usize],
    #[doc = "< X, Y, Z velocities quality indicators as provided by the DVL sensor and expressed in m.s^-1.\nWARNING: This is typically just a residual information and not a real standard deviation."]
    pub velocityQuality: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgLogDvlData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogDvlData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogDvlData>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogDvlData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogDvlData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogDvlData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDvlData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDvlData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDvlData),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocityQuality) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogDvlData),
            "::",
            stringify!(velocityQuality)
        )
    );
}
#[doc = " Log structure for DVL data."]
pub type SbgLogDvlData = _SbgLogDvlData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_DVL_BOTTOM_TRACK / SBG_ECOM_LOG_DVL_WATER_TRACK message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseDvlData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogDvlData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_DVL_BOTTOM_TRACK / SBG_ECOM_LOG_DVL_WATER_TRACK message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteDvlData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogDvlData,
    ) -> SbgErrorCode;
}
#[doc = "< The Kalman filter is not initialized and the returned data are all invalid."]
pub const _SbgEComSolutionMode_SBG_ECOM_SOL_MODE_UNINITIALIZED: _SbgEComSolutionMode = 0;
#[doc = "< The Kalman filter only rely on a vertical reference to compute roll and pitch angles. Heading and navigation data drift freely."]
pub const _SbgEComSolutionMode_SBG_ECOM_SOL_MODE_VERTICAL_GYRO: _SbgEComSolutionMode = 1;
#[doc = "< A heading reference is available, the Kalman filter provides full orientation but navigation data drift freely."]
pub const _SbgEComSolutionMode_SBG_ECOM_SOL_MODE_AHRS: _SbgEComSolutionMode = 2;
#[doc = "< The Kalman filter computes orientation and velocity. Position is freely integrated from velocity estimation."]
pub const _SbgEComSolutionMode_SBG_ECOM_SOL_MODE_NAV_VELOCITY: _SbgEComSolutionMode = 3;
#[doc = "< Nominal mode, the Kalman filter computes all parameters (attitude, velocity, position). Absolute position is provided."]
pub const _SbgEComSolutionMode_SBG_ECOM_SOL_MODE_NAV_POSITION: _SbgEComSolutionMode = 4;
#[doc = " Solution filter mode enum."]
pub type _SbgEComSolutionMode = ::core::ffi::c_uint;
#[doc = " Solution filter mode enum."]
pub use self::_SbgEComSolutionMode as SbgEComSolutionMode;
#[doc = " EKF computed orientation using euler angles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogEkfEulerData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Roll, Pitch and Yaw angles in rad."]
    pub euler: [f32; 3usize],
    #[doc = "< Roll, Pitch and Yaw angles 1 sigma standard deviation in rad."]
    pub eulerStdDev: [f32; 3usize],
    #[doc = "< EKF solution status bitmask and enum."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout__SbgLogEkfEulerData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogEkfEulerData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogEkfEulerData>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogEkfEulerData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogEkfEulerData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogEkfEulerData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfEulerData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).euler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfEulerData),
            "::",
            stringify!(euler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eulerStdDev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfEulerData),
            "::",
            stringify!(eulerStdDev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfEulerData),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " EKF computed orientation using euler angles."]
pub type SbgLogEkfEulerData = _SbgLogEkfEulerData;
#[doc = " EFK computed orientation using quaternion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogEkfQuatData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Orientation quaternion stored in W, X, Y, Z form."]
    pub quaternion: [f32; 4usize],
    #[doc = "< Roll, Pitch and Yaw angles 1 sigma standard deviation in rad."]
    pub eulerStdDev: [f32; 3usize],
    #[doc = "< EKF solution status bitmask and enum."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout__SbgLogEkfQuatData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogEkfQuatData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogEkfQuatData>(),
        36usize,
        concat!("Size of: ", stringify!(_SbgLogEkfQuatData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogEkfQuatData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogEkfQuatData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfQuatData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quaternion) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfQuatData),
            "::",
            stringify!(quaternion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eulerStdDev) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfQuatData),
            "::",
            stringify!(eulerStdDev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfQuatData),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " EFK computed orientation using quaternion."]
pub type SbgLogEkfQuatData = _SbgLogEkfQuatData;
#[doc = " EFK computed navigation data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogEkfNavData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< North, East, Down velocity in m.s^-1."]
    pub velocity: [f32; 3usize],
    #[doc = "< North, East, Down velocity 1 sigma standard deviation in m.s^-1."]
    pub velocityStdDev: [f32; 3usize],
    #[doc = "< Latitude, Longitude in degrees positive North and East.\nAltitude above Mean Sea Level in meters."]
    pub position: [f64; 3usize],
    #[doc = "< Altitude difference between the geoid and the Ellipsoid in meters (Height above Ellipsoid = altitude + undulation)."]
    pub undulation: f32,
    #[doc = "< Latitude, longitude and altitude 1 sigma standard deviation in meters."]
    pub positionStdDev: [f32; 3usize],
    #[doc = "< EKF solution status bitmask and enum."]
    pub status: u32,
}
#[test]
fn bindgen_test_layout__SbgLogEkfNavData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogEkfNavData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogEkfNavData>(),
        80usize,
        concat!("Size of: ", stringify!(_SbgLogEkfNavData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogEkfNavData>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgLogEkfNavData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocityStdDev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(velocityStdDev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).undulation) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(undulation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positionStdDev) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(positionStdDev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEkfNavData),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " EFK computed navigation data."]
pub type SbgLogEkfNavData = _SbgLogEkfNavData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_EKF_EULER message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseEkfEulerData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogEkfEulerData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_EKF_EULER message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteEkfEulerData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogEkfEulerData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_EKF_QUAT message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseEkfQuatData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogEkfQuatData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_EKF_QUAT message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteEkfQuatData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogEkfQuatData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_EKF_NAV message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseEkfNavData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogEkfNavData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_EKF_NAV message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteEkfNavData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogEkfNavData,
    ) -> SbgErrorCode;
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_EVENT_# message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogEvent {
    #[doc = "< Measurement time since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Events status bitmask."]
    pub status: u16,
    #[doc = "< Time offset for the second received event."]
    pub timeOffset0: u16,
    #[doc = "< Time offset for the third received event."]
    pub timeOffset1: u16,
    #[doc = "< Time offset for the fourth received event."]
    pub timeOffset2: u16,
    #[doc = "< Time offset for the fifth received event."]
    pub timeOffset3: u16,
}
#[test]
fn bindgen_test_layout__SbgLogEvent() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogEvent>(),
        16usize,
        concat!("Size of: ", stringify!(_SbgLogEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOffset0) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(timeOffset0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOffset1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(timeOffset1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOffset2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(timeOffset2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOffset3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogEvent),
            "::",
            stringify!(timeOffset3)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_EVENT_# message."]
pub type SbgLogEvent = _SbgLogEvent;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_EVENT_# message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseEvent(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogEvent,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_EVENT_# message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteEvent(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogEvent,
    ) -> SbgErrorCode;
}
#[doc = " Structure that stores raw data message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogRawData {
    #[doc = "< Buffer that contains raw data."]
    pub rawBuffer: [u8; 4086usize],
    #[doc = "< Raw buffer size in bytes."]
    pub bufferSize: usize,
}
#[test]
fn bindgen_test_layout__SbgLogRawData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogRawData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogRawData>(),
        4092usize,
        concat!("Size of: ", stringify!(_SbgLogRawData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogRawData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogRawData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogRawData),
            "::",
            stringify!(rawBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufferSize) as usize - ptr as usize },
        4088usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogRawData),
            "::",
            stringify!(bufferSize)
        )
    );
}
#[doc = " Structure that stores raw data message."]
pub type SbgLogRawData = _SbgLogRawData;
extern "C" {
    #[doc = " Parse raw data message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseRawData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogRawData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write raw data message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteRawData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogRawData,
    ) -> SbgErrorCode;
}
#[doc = "< A valid solution has been computed."]
pub const _SbgEComGpsVelStatus_SBG_ECOM_VEL_SOL_COMPUTED: _SbgEComGpsVelStatus = 0;
#[doc = "< Not enough valid SV to compute a solution."]
pub const _SbgEComGpsVelStatus_SBG_ECOM_VEL_INSUFFICIENT_OBS: _SbgEComGpsVelStatus = 1;
#[doc = "< An internal error has occurred."]
pub const _SbgEComGpsVelStatus_SBG_ECOM_VEL_INTERNAL_ERROR: _SbgEComGpsVelStatus = 2;
#[doc = "< Velocity limit exceeded."]
pub const _SbgEComGpsVelStatus_SBG_ECOM_VEL_LIMIT: _SbgEComGpsVelStatus = 3;
#[doc = " GPS velocity status definitions."]
pub type _SbgEComGpsVelStatus = ::core::ffi::c_uint;
#[doc = " GPS velocity status definitions."]
pub use self::_SbgEComGpsVelStatus as SbgEComGpsVelStatus;
#[doc = "< No valid velocity solution available."]
pub const _SbgEComGpsVelType_SBG_ECOM_VEL_NO_SOLUTION: _SbgEComGpsVelType = 0;
#[doc = "< An unknown solution type has been computed."]
pub const _SbgEComGpsVelType_SBG_ECOM_VEL_UNKNOWN_TYPE: _SbgEComGpsVelType = 1;
#[doc = "< A Doppler velocity has been computed."]
pub const _SbgEComGpsVelType_SBG_ECOM_VEL_DOPPLER: _SbgEComGpsVelType = 2;
#[doc = "< A differential velocity has been computed between two positions."]
pub const _SbgEComGpsVelType_SBG_ECOM_VEL_DIFFERENTIAL: _SbgEComGpsVelType = 3;
#[doc = " GPS velocity types definitions."]
pub type _SbgEComGpsVelType = ::core::ffi::c_uint;
#[doc = " GPS velocity types definitions."]
pub use self::_SbgEComGpsVelType as SbgEComGpsVelType;
#[doc = "< A valid solution has been computed."]
pub const _SbgEComGpsPosStatus_SBG_ECOM_POS_SOL_COMPUTED: _SbgEComGpsPosStatus = 0;
#[doc = "< Not enough valid SV to compute a solution."]
pub const _SbgEComGpsPosStatus_SBG_ECOM_POS_INSUFFICIENT_OBS: _SbgEComGpsPosStatus = 1;
#[doc = "< An internal error has occurred."]
pub const _SbgEComGpsPosStatus_SBG_ECOM_POS_INTERNAL_ERROR: _SbgEComGpsPosStatus = 2;
#[doc = "< The height limit has been exceeded."]
pub const _SbgEComGpsPosStatus_SBG_ECOM_POS_HEIGHT_LIMIT: _SbgEComGpsPosStatus = 3;
#[doc = " GPS position status definitions."]
pub type _SbgEComGpsPosStatus = ::core::ffi::c_uint;
#[doc = " GPS position status definitions."]
pub use self::_SbgEComGpsPosStatus as SbgEComGpsPosStatus;
#[doc = "< No valid solution available."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_NO_SOLUTION: _SbgEComGpsPosType = 0;
#[doc = "< An unknown solution type has been computed."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_UNKNOWN_TYPE: _SbgEComGpsPosType = 1;
#[doc = "< Single point solution position."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_SINGLE: _SbgEComGpsPosType = 2;
#[doc = "< Standard Pseudorange Differential Solution (DGPS)."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_PSRDIFF: _SbgEComGpsPosType = 3;
#[doc = "< SBAS satellite used for differential corrections."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_SBAS: _SbgEComGpsPosType = 4;
#[doc = "< Omnistar VBS Position (L1 sub-meter)."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_OMNISTAR: _SbgEComGpsPosType = 5;
#[doc = "< Floating RTK ambiguity solution (20 cms RTK)."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_RTK_FLOAT: _SbgEComGpsPosType = 6;
#[doc = "< Integer RTK ambiguity solution (2 cms RTK)."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_RTK_INT: _SbgEComGpsPosType = 7;
#[doc = "< Precise Point Positioning with float ambiguities."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_PPP_FLOAT: _SbgEComGpsPosType = 8;
#[doc = "< Precise Point Positioning with fixed ambiguities."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_PPP_INT: _SbgEComGpsPosType = 9;
#[doc = "< Fixed location solution position."]
pub const _SbgEComGpsPosType_SBG_ECOM_POS_FIXED: _SbgEComGpsPosType = 10;
#[doc = " GPS position types definitions."]
pub type _SbgEComGpsPosType = ::core::ffi::c_uint;
#[doc = " GPS position types definitions."]
pub use self::_SbgEComGpsPosType as SbgEComGpsPosType;
#[doc = "< A valid solution has been computed."]
pub const _SbgEComGpsHdtStatus_SBG_ECOM_HDT_SOL_COMPUTED: _SbgEComGpsHdtStatus = 0;
#[doc = "< Not enough valid SV to compute a solution."]
pub const _SbgEComGpsHdtStatus_SBG_ECOM_HDT_INSUFFICIENT_OBS: _SbgEComGpsHdtStatus = 1;
#[doc = "< An internal error has occurred."]
pub const _SbgEComGpsHdtStatus_SBG_ECOM_HDT_INTERNAL_ERROR: _SbgEComGpsHdtStatus = 2;
#[doc = "< The height limit has been exceeded."]
pub const _SbgEComGpsHdtStatus_SBG_ECOM_HDT_HEIGHT_LIMIT: _SbgEComGpsHdtStatus = 3;
#[doc = " GPS HDT status definitions."]
pub type _SbgEComGpsHdtStatus = ::core::ffi::c_uint;
#[doc = " GPS HDT status definitions."]
pub use self::_SbgEComGpsHdtStatus as SbgEComGpsHdtStatus;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_VEL message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogGpsVel {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< GPS velocity status, type and bitmask."]
    pub status: u32,
    #[doc = "< GPS time of week in ms."]
    pub timeOfWeek: u32,
    #[doc = "< GPS North, East, Down velocity in m.s^-1."]
    pub velocity: [f32; 3usize],
    #[doc = "< GPS North, East, Down velocity 1 sigma accuracy in m.s^-1."]
    pub velocityAcc: [f32; 3usize],
    #[doc = "< Track ground course in degrees."]
    pub course: f32,
    #[doc = "< Course accuracy in degrees."]
    pub courseAcc: f32,
}
#[test]
fn bindgen_test_layout__SbgLogGpsVel() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogGpsVel> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogGpsVel>(),
        44usize,
        concat!("Size of: ", stringify!(_SbgLogGpsVel))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogGpsVel>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogGpsVel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOfWeek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(timeOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocityAcc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(velocityAcc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).course) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(course)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).courseAcc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsVel),
            "::",
            stringify!(courseAcc)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_VEL message."]
pub type SbgLogGpsVel = _SbgLogGpsVel;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_POS message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogGpsPos {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< GPS position status, type and bitmask."]
    pub status: u32,
    #[doc = "< GPS time of week in ms."]
    pub timeOfWeek: u32,
    #[doc = "< Latitude in degrees, positive north."]
    pub latitude: f64,
    #[doc = "< Longitude in degrees, positive east."]
    pub longitude: f64,
    #[doc = "< Altitude above Mean Sea Level in meters."]
    pub altitude: f64,
    #[doc = "< Altitude difference between the geoid and the Ellipsoid in meters (Height above Ellipsoid = altitude + undulation)."]
    pub undulation: f32,
    #[doc = "< 1 sigma latitude accuracy in meters."]
    pub latitudeAccuracy: f32,
    #[doc = "< 1 sigma longitude accuracy in meters."]
    pub longitudeAccuracy: f32,
    #[doc = "< 1 sigma altitude accuracy in meters."]
    pub altitudeAccuracy: f32,
    #[doc = "< Number of space vehicles used to compute the solution (since version 1.4)."]
    pub numSvUsed: u8,
    #[doc = "< Base station id for differential corrections (0-4095). Set to 0xFFFF if differential corrections are not used (since version 1.4)."]
    pub baseStationId: u16,
    #[doc = "< Differential correction age in 0.01 seconds. Set to 0XFFFF if differential corrections are not used (since version 1.4)."]
    pub differentialAge: u16,
}
#[test]
fn bindgen_test_layout__SbgLogGpsPos() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogGpsPos> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogGpsPos>(),
        64usize,
        concat!("Size of: ", stringify!(_SbgLogGpsPos))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogGpsPos>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgLogGpsPos))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOfWeek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(timeOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(longitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).undulation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(undulation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitudeAccuracy) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(latitudeAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitudeAccuracy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(longitudeAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitudeAccuracy) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(altitudeAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numSvUsed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(numSvUsed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baseStationId) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(baseStationId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).differentialAge) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsPos),
            "::",
            stringify!(differentialAge)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_POS message."]
pub type SbgLogGpsPos = _SbgLogGpsPos;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_HDT message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogGpsHdt {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< GPS HDT status, type and bitmask."]
    pub status: u16,
    #[doc = "< GPS time of week in ms."]
    pub timeOfWeek: u32,
    #[doc = "< GPS true heading in degrees."]
    pub heading: f32,
    #[doc = "< 1 sigma GPS true heading accuracy in degrees."]
    pub headingAccuracy: f32,
    #[doc = "< GPS pitch angle measured from the master to the rover in degrees."]
    pub pitch: f32,
    #[doc = "< 1 signa GPS pitch angle accuarcy in degrees."]
    pub pitchAccuracy: f32,
    #[doc = "< The distance between the main and aux antenna in meters."]
    pub baseline: f32,
}
#[test]
fn bindgen_test_layout__SbgLogGpsHdt() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogGpsHdt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogGpsHdt>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogGpsHdt))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogGpsHdt>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogGpsHdt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeOfWeek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(timeOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heading) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(heading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).headingAccuracy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(headingAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitchAccuracy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(pitchAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baseline) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogGpsHdt),
            "::",
            stringify!(baseline)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_GPS#_HDT message."]
pub type SbgLogGpsHdt = _SbgLogGpsHdt;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_GPS#_VEL message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseGpsVelData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogGpsVel,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_GPS#_VEL message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteGpsVelData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogGpsVel,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_GPS#_POS message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseGpsPosData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogGpsPos,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_GPS#_POS message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteGpsPosData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogGpsPos,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_GPS#_HDT message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseGpsHdtData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogGpsHdt,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_GPS#_HDT message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteGpsHdtData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogGpsHdt,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_GPS#_RAW message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseGpsRawData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogRawData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_GPS#_RAW message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteGpsRawData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogRawData,
    ) -> SbgErrorCode;
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_IMU_DATA message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogImuData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< IMU status bitmask."]
    pub status: u16,
    #[doc = "< X, Y, Z accelerometers in m.s^-2."]
    pub accelerometers: [f32; 3usize],
    #[doc = "< X, Y, Z gyroscopes in rad.s^-1."]
    pub gyroscopes: [f32; 3usize],
    #[doc = "< Internal temperature in °C."]
    pub temperature: f32,
    #[doc = "< X, Y, Z delta velocity in m.s^-2."]
    pub deltaVelocity: [f32; 3usize],
    #[doc = "< X, Y, Z delta angle in rad.s^-1."]
    pub deltaAngle: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgLogImuData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogImuData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogImuData>(),
        60usize,
        concat!("Size of: ", stringify!(_SbgLogImuData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogImuData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogImuData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accelerometers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(accelerometers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gyroscopes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(gyroscopes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deltaVelocity) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(deltaVelocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deltaAngle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuData),
            "::",
            stringify!(deltaAngle)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_IMU_DATA message."]
pub type SbgLogImuData = _SbgLogImuData;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_IMU_SHORT message.\n This message is only sent asynchronously and is the preferred log for post processing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogImuShort {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< IMU status bitmask."]
    pub status: u16,
    #[doc = "< X, Y, Z delta velocity. Unit is 1048576 LSB for 1 m.s^-2."]
    pub deltaVelocity: [i32; 3usize],
    #[doc = "< X, Y, Z delta angle. Unit is 67108864 LSB for 1 rad.s^-1."]
    pub deltaAngle: [i32; 3usize],
    #[doc = "< IMU average temperature. Unit is 256 LSB for 1°C."]
    pub temperature: i16,
}
#[test]
fn bindgen_test_layout__SbgLogImuShort() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogImuShort> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogImuShort>(),
        36usize,
        concat!("Size of: ", stringify!(_SbgLogImuShort))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogImuShort>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogImuShort))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuShort),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuShort),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deltaVelocity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuShort),
            "::",
            stringify!(deltaVelocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deltaAngle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuShort),
            "::",
            stringify!(deltaAngle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogImuShort),
            "::",
            stringify!(temperature)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_IMU_SHORT message.\n This message is only sent asynchronously and is the preferred log for post processing."]
pub type SbgLogImuShort = _SbgLogImuShort;
#[doc = " Structure that stores the data for SBG_ECOM_LOG_FAST_IMU_DATA message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogFastImuData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< IMU status bitmask."]
    pub status: u16,
    #[doc = "< X, Y, Z accelerometers in m.s^-2."]
    pub accelerometers: [f32; 3usize],
    #[doc = "< X, Y, Z gyroscopes in rad.s^-1."]
    pub gyroscopes: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgLogFastImuData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogFastImuData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogFastImuData>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogFastImuData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogFastImuData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogFastImuData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogFastImuData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogFastImuData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accelerometers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogFastImuData),
            "::",
            stringify!(accelerometers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gyroscopes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogFastImuData),
            "::",
            stringify!(gyroscopes)
        )
    );
}
#[doc = " Structure that stores the data for SBG_ECOM_LOG_FAST_IMU_DATA message"]
pub type SbgLogFastImuData = _SbgLogFastImuData;
extern "C" {
    #[doc = " Return from an IMU Short log, the X, Y or Z delta angle value in rad.s^-1\n\n \\param[in]\tpImuShort\t\t\t\t\tInput IMU short message instance.\n \\param[in]\tidx\t\t\t\t\t\t\tThe component to return from 0 to 2.\n \\return\t\t\t\t\t\t\t\t\tThe delta angle value converted in rad.s^-1."]
    pub fn sbgLogImuShortGetDeltaAngle(pImuShort: *const SbgLogImuShort, idx: usize) -> f32;
}
extern "C" {
    #[doc = " Return from an IMU Short log, the X, Y or Z delta velocity value in m.s^-2\n\n \\param[in]\tpImuShort\t\t\t\t\tInput IMU short message instance.\n \\param[in]\tidx\t\t\t\t\t\t\tThe component to return from 0 to 2.\n \\return\t\t\t\t\t\t\t\t\tThe delta velocity value converted in m.s^-2."]
    pub fn sbgLogImuShortGetDeltaVelocity(pImuShort: *const SbgLogImuShort, idx: usize) -> f32;
}
extern "C" {
    #[doc = " Return from an IMU Short log, the temperature in °C\n\n \\param[in]\tpImuShort\t\t\t\t\tInput IMU short message instance.\n \\return\t\t\t\t\t\t\t\t\tThe converted temperature in °C"]
    pub fn sbgLogImuShortGetTemperature(pImuShort: *const SbgLogImuShort) -> f32;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_IMU_DATA message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseImuData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogImuData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_IMU_DATA message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteImuData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogImuData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_IMU_SHORT message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseImuShort(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogImuShort,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_IMU_SHORT message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteImuShort(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogImuShort,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_FAST_IMU_DATA message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseFastImuData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogFastImuData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_FAST_IMU_DATA message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteFastImuData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogFastImuData,
    ) -> SbgErrorCode;
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_MAG message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogMag {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Magnetometer status bitmask."]
    pub status: u16,
    #[doc = "< X, Y, Z magnetometer data in A.U."]
    pub magnetometers: [f32; 3usize],
    #[doc = "< X, Y, Z accelerometers in m.s^-2."]
    pub accelerometers: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgLogMag() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogMag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogMag>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogMag))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogMag>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogMag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMag),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMag),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magnetometers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMag),
            "::",
            stringify!(magnetometers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accelerometers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMag),
            "::",
            stringify!(accelerometers)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_MAG message."]
pub type SbgLogMag = _SbgLogMag;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_MAG_CALIB message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogMagCalib {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Reserved for future use."]
    pub reserved: u16,
    #[doc = "< Magnetometers calibration data."]
    pub magData: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__SbgLogMagCalib() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogMagCalib> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogMagCalib>(),
        24usize,
        concat!("Size of: ", stringify!(_SbgLogMagCalib))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogMagCalib>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogMagCalib))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMagCalib),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMagCalib),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magData) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogMagCalib),
            "::",
            stringify!(magData)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_MAG_CALIB message."]
pub type SbgLogMagCalib = _SbgLogMagCalib;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_MAG message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseMagData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogMag,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_MAG message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteMagData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogMag,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_MAG_CALIB message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseMagCalibData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogMagCalib,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_MAG_CALIB message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteMagCalibData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogMagCalib,
    ) -> SbgErrorCode;
}
#[doc = " Log structure for odometer data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogOdometerData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Odometer velocity status bitmask."]
    pub status: u16,
    #[doc = "< Velocity in m.s^-1 in the odometer direction."]
    pub velocity: f32,
}
#[test]
fn bindgen_test_layout__SbgLogOdometerData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogOdometerData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogOdometerData>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgLogOdometerData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogOdometerData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogOdometerData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogOdometerData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogOdometerData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogOdometerData),
            "::",
            stringify!(velocity)
        )
    );
}
#[doc = " Log structure for odometer data."]
pub type SbgLogOdometerData = _SbgLogOdometerData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_ODO_VEL message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseOdometerData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogOdometerData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_ODO_VEL message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteOdometerData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogOdometerData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_RTCM_RAW message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseRtcmRawData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogRawData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_RTCM_RAW message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteRtcmRawData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogRawData,
    ) -> SbgErrorCode;
}
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_UNKNOWN: _SbgEComSignalId = 0;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1C_DP: _SbgEComSignalId = 10;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1C_D: _SbgEComSignalId = 11;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1C_P: _SbgEComSignalId = 12;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1_W: _SbgEComSignalId = 13;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1_CA: _SbgEComSignalId = 14;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1P: _SbgEComSignalId = 15;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1_PY: _SbgEComSignalId = 16;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L1M: _SbgEComSignalId = 17;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2C_ML: _SbgEComSignalId = 18;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2C_L: _SbgEComSignalId = 19;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2_SEMICL: _SbgEComSignalId = 20;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2_W: _SbgEComSignalId = 21;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2_CA: _SbgEComSignalId = 22;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2C_M: _SbgEComSignalId = 23;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2_PY: _SbgEComSignalId = 24;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2M: _SbgEComSignalId = 25;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L2P: _SbgEComSignalId = 26;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L5_IQ: _SbgEComSignalId = 27;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L5_I: _SbgEComSignalId = 28;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GPS_L5_Q: _SbgEComSignalId = 29;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G1_P: _SbgEComSignalId = 40;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G1_CA: _SbgEComSignalId = 41;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G2_P: _SbgEComSignalId = 42;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G2_CA: _SbgEComSignalId = 43;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G3_I: _SbgEComSignalId = 44;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G3_Q: _SbgEComSignalId = 45;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GLONASS_G3_IQ: _SbgEComSignalId = 46;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E1_BC: _SbgEComSignalId = 60;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E1_C: _SbgEComSignalId = 61;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E1_B: _SbgEComSignalId = 62;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E1_A: _SbgEComSignalId = 63;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E1_ABC: _SbgEComSignalId = 64;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5B_IQ: _SbgEComSignalId = 65;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5B_I: _SbgEComSignalId = 66;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5B_Q: _SbgEComSignalId = 67;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5A_IQ: _SbgEComSignalId = 68;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5A_I: _SbgEComSignalId = 69;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5A_Q: _SbgEComSignalId = 70;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5_IQ: _SbgEComSignalId = 71;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5_I: _SbgEComSignalId = 72;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E5_Q: _SbgEComSignalId = 73;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E6_BC: _SbgEComSignalId = 74;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E6_C: _SbgEComSignalId = 75;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E6_B: _SbgEComSignalId = 76;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E6_ABC: _SbgEComSignalId = 77;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_GALILEO_E6_A: _SbgEComSignalId = 78;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1IQ: _SbgEComSignalId = 100;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1I: _SbgEComSignalId = 101;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1Q: _SbgEComSignalId = 102;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1C_P: _SbgEComSignalId = 103;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1C_DP: _SbgEComSignalId = 104;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1C_D: _SbgEComSignalId = 105;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1A_P: _SbgEComSignalId = 106;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1A_DP: _SbgEComSignalId = 107;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B1A_D: _SbgEComSignalId = 108;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2IQ: _SbgEComSignalId = 109;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2I: _SbgEComSignalId = 110;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2A_P: _SbgEComSignalId = 111;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2A_DP: _SbgEComSignalId = 112;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2A_D: _SbgEComSignalId = 113;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2Q: _SbgEComSignalId = 114;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2B_P: _SbgEComSignalId = 115;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2B_DP: _SbgEComSignalId = 116;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2B_D: _SbgEComSignalId = 117;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2AB_P: _SbgEComSignalId = 118;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2AB_DP: _SbgEComSignalId = 119;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B2AB_D: _SbgEComSignalId = 120;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3IQ: _SbgEComSignalId = 121;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3I: _SbgEComSignalId = 122;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3Q: _SbgEComSignalId = 123;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3A_D: _SbgEComSignalId = 124;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3A_P: _SbgEComSignalId = 125;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_BEIDOU_B3A_DP: _SbgEComSignalId = 126;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1C_DP: _SbgEComSignalId = 150;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1C_D: _SbgEComSignalId = 151;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1C_P: _SbgEComSignalId = 152;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1_CA: _SbgEComSignalId = 153;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1_SAIF: _SbgEComSignalId = 154;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L1_SB: _SbgEComSignalId = 155;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L2C_ML: _SbgEComSignalId = 156;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L2C_L: _SbgEComSignalId = 157;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L2C_M: _SbgEComSignalId = 158;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5_IQ: _SbgEComSignalId = 159;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5_I: _SbgEComSignalId = 160;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5_Q: _SbgEComSignalId = 161;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5S_IQ: _SbgEComSignalId = 162;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5S_I: _SbgEComSignalId = 163;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L5S_Q: _SbgEComSignalId = 164;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L6_P: _SbgEComSignalId = 165;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L6_DP: _SbgEComSignalId = 166;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L6_D: _SbgEComSignalId = 167;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L6_E: _SbgEComSignalId = 168;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_QZSS_L6_DE: _SbgEComSignalId = 169;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_SBAS_L1_CA: _SbgEComSignalId = 180;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_SBAS_L5_I: _SbgEComSignalId = 181;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_SBAS_L5_Q: _SbgEComSignalId = 182;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_SBAS_L5_IQ: _SbgEComSignalId = 183;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_L5_A: _SbgEComSignalId = 200;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_L5_B: _SbgEComSignalId = 201;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_L5_C: _SbgEComSignalId = 202;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_L5_BC: _SbgEComSignalId = 203;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_S9_A: _SbgEComSignalId = 204;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_S9_B: _SbgEComSignalId = 205;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_S9_C: _SbgEComSignalId = 206;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_IRNSS_S9_BC: _SbgEComSignalId = 207;
pub const _SbgEComSignalId_SBG_ECOM_SIGNAL_ID_LBAND: _SbgEComSignalId = 220;
#[doc = " Signal IDs.\n\n These are on-the-wire values."]
pub type _SbgEComSignalId = ::core::ffi::c_uint;
#[doc = " Signal IDs.\n\n These are on-the-wire values."]
pub use self::_SbgEComSignalId as SbgEComSignalId;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_UNKNOWN: _SbgEComConstellationId = 0;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_GPS: _SbgEComConstellationId = 1;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_GLONASS: _SbgEComConstellationId = 2;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_GALILEO: _SbgEComConstellationId = 3;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_BEIDOU: _SbgEComConstellationId = 4;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_QZSS: _SbgEComConstellationId = 5;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_SBAS: _SbgEComConstellationId = 6;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_IRNSS: _SbgEComConstellationId = 7;
pub const _SbgEComConstellationId_SBG_ECOM_CONSTELLATION_ID_LBAND: _SbgEComConstellationId = 8;
#[doc = " Constellation IDs.\n\n All values must be strictly lower than 16.\n\n These are on-the-wire values."]
pub type _SbgEComConstellationId = ::core::ffi::c_uint;
#[doc = " Constellation IDs.\n\n All values must be strictly lower than 16.\n\n These are on-the-wire values."]
pub use self::_SbgEComConstellationId as SbgEComConstellationId;
extern "C" {
    #[doc = " Returns a constellation given a signal ID\n\n \\param[in]\tsignalId\t\t\t\t\tSignal ID value.\n \\return\t\t\t\t\t\t\t\t\tConstellation this signal belongs to."]
    pub fn sbgEComGetConstellationFromSignalId(signalId: SbgEComSignalId)
        -> SbgEComConstellationId;
}
extern "C" {
    #[doc = " Check if a value belongs to SbgEComSignalId enum.\n\n WARNING: SBG_ECOM_SIGNAL_ID_UNKNOWN is considered to be a valid enum value.\n\n \\param[in]\tsignalId\t\t\t\t\tSignal ID value.\n \\return\t\t\t\t\t\t\t\t\ttrue if the value is valid"]
    pub fn sbgEComSignalIdIsValid(signalId: u8) -> bool;
}
extern "C" {
    #[doc = " Get a signal ID as a read only C string.\n\n \\param[in]\tsignalId\t\t\t\t\tSignal ID value.\n \\return\t\t\t\t\t\t\t\t\tSignal ID as a read only C string."]
    pub fn sbgEComSignalToStr(signalId: SbgEComSignalId) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Check if a value belongs to SbgEComConstellationId enum.\n\n \\param[in]\tconstellationId\t\t\t\tconstellation ID value.\n \\return\t\t\t\t\t\t\t\t\ttrue if the value is valid"]
    pub fn sbgEComConstellationIdIsValid(constellationId: u8) -> bool;
}
extern "C" {
    #[doc = " Get a constellation ID as a read only C string.\n\n \\param[in]\tconstellationId\t\t\t\tConstellation ID value.\n \\return\t\t\t\t\t\t\t\t\tConstellation ID as a read only C string."]
    pub fn sbgEComConstellationToStr(
        constellationId: SbgEComConstellationId,
    ) -> *const ::core::ffi::c_char;
}
#[doc = "< Unknown tracking status such as no signal / idle."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_UNKNOWN:
    _SbgEComSatTrackingStatus = 0;
#[doc = "< Signal is beeing searched and can't be used yet."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_SEARCHING:
    _SbgEComSatTrackingStatus = 1;
#[doc = "< Signal is tracked but don't know if used or not in the solution."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_TRACKING_UNKNOWN:
    _SbgEComSatTrackingStatus = 2;
#[doc = "< Signal is tracked and is not used in the solution."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_TRACKING_NOT_USED:
    _SbgEComSatTrackingStatus = 3;
#[doc = "< Signal is tracjed and is rejected from the solution."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_TRACKING_REJECTED:
    _SbgEComSatTrackingStatus = 4;
#[doc = "< Signal is tracked and used in the solution."]
pub const _SbgEComSatTrackingStatus_SBG_ECOM_SAT_TRACKING_STATUS_TRACKING_USED:
    _SbgEComSatTrackingStatus = 5;
#[doc = " Tracking status.\n\n The tracking status embeds the solution status when the latter is known.\n\n All values must be strictly lower than 8.\n\n These are on-the-wire values."]
pub type _SbgEComSatTrackingStatus = ::core::ffi::c_uint;
#[doc = " Tracking status.\n\n The tracking status embeds the solution status when the latter is known.\n\n All values must be strictly lower than 8.\n\n These are on-the-wire values."]
pub use self::_SbgEComSatTrackingStatus as SbgEComSatTrackingStatus;
#[doc = "< Don't know the satellite or the signal health status."]
pub const _SbgEComSatHealthStatus_SBG_ECOM_SAT_HEALTH_STATUS_UNKNOWN: _SbgEComSatHealthStatus = 0;
#[doc = "< The satellite or the signal is healthy and can be used."]
pub const _SbgEComSatHealthStatus_SBG_ECOM_SAT_HEALTH_STATUS_HEALTHY: _SbgEComSatHealthStatus = 1;
#[doc = "< The satellite or the signal is not healthy and can't be used."]
pub const _SbgEComSatHealthStatus_SBG_ECOM_SAT_HEALTH_STATUS_UNHEALTHY: _SbgEComSatHealthStatus = 2;
#[doc = " Health status.\n\n All values must be strictly lower than 4.\n\n These are on-the-wire values."]
pub type _SbgEComSatHealthStatus = ::core::ffi::c_uint;
#[doc = " Health status.\n\n All values must be strictly lower than 4.\n\n These are on-the-wire values."]
pub use self::_SbgEComSatHealthStatus as SbgEComSatHealthStatus;
#[doc = "< Don't know if the satellite elevation is setting or rising."]
pub const _SbgEComSatElevationStatus_SBG_ECOM_SAT_ELEVATION_STATUS_UNKNOWN:
    _SbgEComSatElevationStatus = 0;
#[doc = "< The satellite elevation is setting."]
pub const _SbgEComSatElevationStatus_SBG_ECOM_SAT_ELEVATION_STATUS_SETTING:
    _SbgEComSatElevationStatus = 1;
#[doc = "< The satellite elevation is rising"]
pub const _SbgEComSatElevationStatus_SBG_ECOM_SAT_ELEVATION_STATUS_RISING:
    _SbgEComSatElevationStatus = 2;
#[doc = " Elevation status.\n\n All values must be strictly lower than 4.\n\n These are on-the-wire values."]
pub type _SbgEComSatElevationStatus = ::core::ffi::c_uint;
#[doc = " Elevation status.\n\n All values must be strictly lower than 4.\n\n These are on-the-wire values."]
pub use self::_SbgEComSatElevationStatus as SbgEComSatElevationStatus;
#[doc = " Satellite signal data.\n\n The flags include the snr available, health and tracking statuses."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogSatSignalData {
    #[doc = "< Signal ID."]
    pub id: SbgEComSignalId,
    #[doc = "< Flags."]
    pub flags: u8,
    #[doc = "< Signal-to-noise ratio, in dB."]
    pub snr: u8,
}
#[test]
fn bindgen_test_layout__SbgLogSatSignalData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogSatSignalData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogSatSignalData>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgLogSatSignalData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogSatSignalData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogSatSignalData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatSignalData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatSignalData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snr) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatSignalData),
            "::",
            stringify!(snr)
        )
    );
}
#[doc = " Satellite signal data.\n\n The flags include the snr available, health and tracking statuses."]
pub type SbgLogSatSignalData = _SbgLogSatSignalData;
#[doc = " Satellite data.\n\n The flags include the constellation ID, the elevation status, the health status, and the tracking status.\n\n Satellite data and signal data each have their own health and tracking statuses. The statuses of satellite\n data may be a priority-based summary of the statuses of signal data, or they may reflect information that\n is limited to a satellite and unavailable for its signals.\n\n The priority rules are :\n  - health status : unhealthy -> healthy -> unknown\n  - tracking status : tracking and used -> tracking and not used -> tracking (solution status unknown) -> searching -> unknown\n\n For example, if satellite data have an unknown tracking status, and have three signals, one with the\n searching status, another with the tracking and not used status, and the last with the tracking and used status,\n the satellite data tracking status will be tracking and used.\n But if those satellite data are initially set with a healthy health status, and all three signals added have the\n unknown health status, the satellite data health status remains healthy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogSatData {
    #[doc = "< Satellite ID."]
    pub id: u8,
    #[doc = "< Elevation, in degrees [-90; +90], valid if and only if the elevation is known."]
    pub elevation: i8,
    #[doc = "< Azimuth, in degrees [0; 359], valid if and only if the elevation is known."]
    pub azimuth: u16,
    #[doc = "< Flags."]
    pub flags: u16,
    #[doc = "< Number of signals."]
    pub nrSignals: usize,
    #[doc = "< Size of the signal data array."]
    pub signalDataArraySize: usize,
    #[doc = "< Signal data array."]
    pub pSignalData: *mut SbgLogSatSignalData,
}
#[test]
fn bindgen_test_layout__SbgLogSatData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogSatData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogSatData>(),
        20usize,
        concat!("Size of: ", stringify!(_SbgLogSatData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogSatData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogSatData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elevation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(elevation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).azimuth) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(azimuth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrSignals) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(nrSignals)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signalDataArraySize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(signalDataArraySize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSignalData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatData),
            "::",
            stringify!(pSignalData)
        )
    );
}
#[doc = " Satellite data.\n\n The flags include the constellation ID, the elevation status, the health status, and the tracking status.\n\n Satellite data and signal data each have their own health and tracking statuses. The statuses of satellite\n data may be a priority-based summary of the statuses of signal data, or they may reflect information that\n is limited to a satellite and unavailable for its signals.\n\n The priority rules are :\n  - health status : unhealthy -> healthy -> unknown\n  - tracking status : tracking and used -> tracking and not used -> tracking (solution status unknown) -> searching -> unknown\n\n For example, if satellite data have an unknown tracking status, and have three signals, one with the\n searching status, another with the tracking and not used status, and the last with the tracking and used status,\n the satellite data tracking status will be tracking and used.\n But if those satellite data are initially set with a healthy health status, and all three signals added have the\n unknown health status, the satellite data health status remains healthy."]
pub type SbgLogSatData = _SbgLogSatData;
#[doc = " Satellite group data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogSatGroupData {
    #[doc = "< Time since the sensor power up, in us."]
    pub timeStamp: u32,
    #[doc = "< Reserved for future use."]
    pub reserved: u32,
    #[doc = "< Number of satellites."]
    pub nrSatellites: usize,
    #[doc = "< Size of the satellite data array."]
    pub satDataArraySize: usize,
    #[doc = "< Satellite data array."]
    pub pSatData: *mut SbgLogSatData,
}
#[test]
fn bindgen_test_layout__SbgLogSatGroupData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogSatGroupData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogSatGroupData>(),
        20usize,
        concat!("Size of: ", stringify!(_SbgLogSatGroupData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogSatGroupData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogSatGroupData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatGroupData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatGroupData),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nrSatellites) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatGroupData),
            "::",
            stringify!(nrSatellites)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).satDataArraySize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatGroupData),
            "::",
            stringify!(satDataArraySize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSatData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogSatGroupData),
            "::",
            stringify!(pSatData)
        )
    );
}
#[doc = " Satellite group data."]
pub type SbgLogSatGroupData = _SbgLogSatGroupData;
extern "C" {
    #[doc = " Parse satellite group data from a stream buffer.\n\n This function constructs the satellite group data, which must be destroyed once not needed any more.\n\n \\param[in]\tpStreamBuffer\t\t\t\tStream buffer.\n \\param[out]\tpSatGroupData\t\t\t\tSatellite group data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
    pub fn sbgEComBinaryLogParseSatGroupData(
        pStreamBuffer: *mut SbgStreamBuffer,
        pSatGroupData: *mut SbgLogSatGroupData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write satellite group data to a stream buffer.\n\n \\param[out]\tpStreamBuffer\t\t\t\tStream buffer.\n \\param[in]\tpSatGroupData\t\t\t\tSatellite group data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
    pub fn sbgEComBinaryLogWriteSatGroupData(
        pStreamBuffer: *mut SbgStreamBuffer,
        pSatGroupData: *const SbgLogSatGroupData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Satellite group data constructor.\n\n \\param[in]\tpSatGroupData\t\t\t\tSatellite group data.\n \\param[in]\tnrSatellites\t\t\t\tNumber of satellites.\n \\param[in]\ttimeStamp\t\t\t\t\tTime stamp, in us.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
    pub fn sbgLogSatGroupDataConstruct(
        pSatGroupData: *mut SbgLogSatGroupData,
        nrSatellites: usize,
        timeStamp: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Satellite group data destructor.\n\n \\param[in]\tpSatGroupData\t\t\t\tSatellite group data."]
    pub fn sbgLogSatGroupDataDestroy(pSatGroupData: *mut SbgLogSatGroupData);
}
extern "C" {
    #[doc = " Add satellite data to satellite group data.\n\n \\param[in]\tpSatGroupData\t\t\t\tSatellite group data.\n \\param[in]\tnrSignals\t\t\t\t\tNumber of signals.\n \\param[in]\tid\t\t\t\t\t\t\tSatellite ID.\n \\param[in]\televation\t\t\t\t\tElevation, in degrees.\n \\param[in]\tazimuth\t\t\t\t\t\tAzimuth, in degrees.\n \\param[in]\tconstellationId\t\t\t\tConstellation ID.\n \\param[in]\televationStatus\t\t\t\tElevation status.\n \\param[in]\thealthStatus\t\t\t\tHealth status.\n \\param[in]\ttrackingStatus\t\t\t\tTracking status.\n \\return\t\t\t\t\t\t\t\t\tSatellite data, NULL if an error occurs."]
    pub fn sbgLogSatGroupDataAdd(
        pSatGroupData: *mut SbgLogSatGroupData,
        nrSignals: usize,
        id: u8,
        elevation: i8,
        azimuth: u16,
        constellationId: SbgEComConstellationId,
        elevationStatus: SbgEComSatElevationStatus,
        healthStatus: SbgEComSatHealthStatus,
        trackingStatus: SbgEComSatTrackingStatus,
    ) -> *mut SbgLogSatData;
}
extern "C" {
    #[doc = " Get satellite data from satellite group data.\n\n \\param[in]\tpSatGroupData\t\t\t\tSatellite group data.\n \\param[in]\tid\t\t\t\t\t\t\tSatellite ID.\n \\return\t\t\t\t\t\t\t\t\tSatellite data, NULL if not found."]
    pub fn sbgLogSatGroupGet(pSatGroupData: *mut SbgLogSatGroupData, id: u8) -> *mut SbgLogSatData;
}
extern "C" {
    #[doc = " Get the constellation ID of satellite data.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tConstellation ID."]
    pub fn sbgLogSatDataGetConstellationId(
        pSatData: *const SbgLogSatData,
    ) -> SbgEComConstellationId;
}
extern "C" {
    #[doc = " Get the constellation ID of satellite data as a read only C string.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tConstellation ID as a read only C string."]
    pub fn sbgLogSatDataGetConstellationIdAsStr(
        pSatData: *const SbgLogSatData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the elevation status of satellite data.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tElevation status."]
    pub fn sbgLogSatDataGetElevationStatus(
        pSatData: *const SbgLogSatData,
    ) -> SbgEComSatElevationStatus;
}
extern "C" {
    #[doc = " Get the elevation status of satellite data as a read only C string.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tElevation status as a read only C string."]
    pub fn sbgLogSatDataGetElevationStatusAsStr(
        pSatData: *const SbgLogSatData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the health status of satellite data.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tHealth status."]
    pub fn sbgLogSatDataGetHealthStatus(pSatData: *const SbgLogSatData) -> SbgEComSatHealthStatus;
}
extern "C" {
    #[doc = " Get the health status of satellite data as a read only C string.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tHealth status as a read only C string."]
    pub fn sbgLogSatDataGetHealthStatusAsStr(
        pSatData: *const SbgLogSatData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the tracking status of satellite data.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tTracking status."]
    pub fn sbgLogSatDataGetTrackingStatus(
        pSatData: *const SbgLogSatData,
    ) -> SbgEComSatTrackingStatus;
}
extern "C" {
    #[doc = " Get the tracking status of satellite data as a read only C string.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\return\t\t\t\t\t\t\t\t\tTracking status as a read only C string."]
    pub fn sbgLogSatDataGetTrackingStatusAsStr(
        pSatData: *const SbgLogSatData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Add signal data to satellite data.\n\n The health and tracking statuses of the satellite data are updated according to their respective\n priority rules.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\param[in]\tid\t\t\t\t\t\t\tSignal ID.\n \\param[in]\thealthStatus\t\t\t\tHealth status.\n \\param[in]\ttrackingStatus\t\t\t\tTracking status.\n \\param[in]\tsnrValid\t\t\t\t\tSet to true if the SNR value is valid.\n \\param[in]\tsnr\t\t\t\t\t\t\tSignal-to-noise ratio, in dB.\n \\return\t\t\t\t\t\t\t\t\tSignal data, NULL if an error occurs."]
    pub fn sbgLogSatDataAdd(
        pSatData: *mut SbgLogSatData,
        id: SbgEComSignalId,
        healthStatus: SbgEComSatHealthStatus,
        trackingStatus: SbgEComSatTrackingStatus,
        snrValid: bool,
        snr: u8,
    ) -> *mut SbgLogSatSignalData;
}
extern "C" {
    #[doc = " Get signal data from satellite data.\n\n \\param[in]\tpSatData\t\t\t\t\tSatellite data.\n \\param[in]\tid\t\t\t\t\t\t\tSignal ID.\n \\return\t\t\t\t\t\t\t\t\tSignal data, NULL if not found."]
    pub fn sbgLogSatDataGet(
        pSatData: *mut SbgLogSatData,
        id: SbgEComSignalId,
    ) -> *mut SbgLogSatSignalData;
}
extern "C" {
    #[doc = " Get a signal id as a read only C string.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\tSignal id as a read only C string."]
    pub fn sbgLogSatSignalDataGetSignalIdAsStr(
        pSignalData: *const SbgLogSatSignalData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns true if the SNR value is valid.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\ttrue if the SNR value is valid."]
    pub fn sbgLogSatSignalDataSnrIsValid(pSignalData: *const SbgLogSatSignalData) -> bool;
}
extern "C" {
    #[doc = " Get the health status of signal data.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\tHealth status."]
    pub fn sbgLogSatSignalDataGetHealthStatus(
        pSignalData: *const SbgLogSatSignalData,
    ) -> SbgEComSatHealthStatus;
}
extern "C" {
    #[doc = " Get the health status of signal data as a read only C string.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\tHealth status as a read only C string."]
    pub fn sbgLogSatSignalDataGetHealthStatusAsStr(
        pSignalData: *const SbgLogSatSignalData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the tracking status of signal data.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\tTracking status."]
    pub fn sbgLogSatSignalDataGetTrackingStatus(
        pSignalData: *const SbgLogSatSignalData,
    ) -> SbgEComSatTrackingStatus;
}
extern "C" {
    #[doc = " Get the tracking status of signal data as a read only C string.\n\n \\param[in]\tpSignalData\t\t\t\t\tSignal data.\n \\return\t\t\t\t\t\t\t\t\tTracking status as a read only C string."]
    pub fn sbgLogSatSignalDataGetTrackingStatusAsStr(
        pSignalData: *const SbgLogSatSignalData,
    ) -> *const ::core::ffi::c_char;
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_SHIP_MOTION or SBG_ECOM_LOG_SHIP_MOTION_HP message. <br>\n The data are expressed in the standard NED Ekinox coordiante frame.\n Surge is positive forward, sway is positive right and heave is positive down. <br>\n Note that status flag should be read before using the different parameters because it will provide validity information\n about all included outputs. Some frames may not provide the heave period or surge/sway axes for example"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogShipMotionData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< Ship Motion data status bitmask"]
    pub status: u16,
    #[doc = "< Main heave period in seconds."]
    pub mainHeavePeriod: f32,
    #[doc = "< Surge, sway and heave in meters."]
    pub shipMotion: [f32; 3usize],
    #[doc = "< Surge, sway and heave ship Acceleration in m.s^-2."]
    pub shipAccel: [f32; 3usize],
    #[doc = "< Surge, sway and heave velocities"]
    pub shipVel: [f32; 3usize],
}
#[test]
fn bindgen_test_layout__SbgLogShipMotionData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogShipMotionData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogShipMotionData>(),
        48usize,
        concat!("Size of: ", stringify!(_SbgLogShipMotionData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogShipMotionData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogShipMotionData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mainHeavePeriod) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(mainHeavePeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shipMotion) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(shipMotion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shipAccel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(shipAccel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shipVel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogShipMotionData),
            "::",
            stringify!(shipVel)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_SHIP_MOTION or SBG_ECOM_LOG_SHIP_MOTION_HP message. <br>\n The data are expressed in the standard NED Ekinox coordiante frame.\n Surge is positive forward, sway is positive right and heave is positive down. <br>\n Note that status flag should be read before using the different parameters because it will provide validity information\n about all included outputs. Some frames may not provide the heave period or surge/sway axes for example"]
pub type SbgLogShipMotionData = _SbgLogShipMotionData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_SHIP_MOTION or SBG_ECOM_LOG_SHIP_MOTION_HP  message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseShipMotionData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogShipMotionData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_SHIP_MOTION or SBG_ECOM_LOG_SHIP_MOTION_HP message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteShipMotionData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogShipMotionData,
    ) -> SbgErrorCode;
}
#[doc = "< Bus OFF operation due to too much errors."]
pub const _SbgEComCanBusStatus_SBG_ECOM_CAN_BUS_OFF: _SbgEComCanBusStatus = 0;
#[doc = "< Errors on Tx or Rx."]
pub const _SbgEComCanBusStatus_SBG_ECOM_CAN_BUS_TX_RX_ERR: _SbgEComCanBusStatus = 1;
#[doc = "< Bus OK."]
pub const _SbgEComCanBusStatus_SBG_ECOM_CAN_BUS_OK: _SbgEComCanBusStatus = 2;
#[doc = "< Bus error."]
pub const _SbgEComCanBusStatus_SBG_ECOM_CAN_BUS_ERROR: _SbgEComCanBusStatus = 3;
#[doc = " Communication status for the CAN Bus."]
pub type _SbgEComCanBusStatus = ::core::ffi::c_uint;
#[doc = " Communication status for the CAN Bus."]
pub use self::_SbgEComCanBusStatus as SbgEComCanBusStatus;
#[doc = " Stores global status data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogStatusData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< General status bitmask and enums."]
    pub generalStatus: u16,
    #[doc = "< Communication status bitmask and enums."]
    pub comStatus: u32,
    #[doc = "< Second communication status bitmask and enums."]
    pub comStatus2: u16,
    #[doc = "< Aiding equipments status bitmask and enums."]
    pub aidingStatus: u32,
    #[doc = "< Reserved status field for future use."]
    pub reserved2: u32,
    #[doc = "< Reserved status field for future use."]
    pub reserved3: u16,
    #[doc = "< System uptime in seconds."]
    pub uptime: u32,
}
#[test]
fn bindgen_test_layout__SbgLogStatusData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogStatusData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogStatusData>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgLogStatusData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogStatusData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogStatusData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generalStatus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(generalStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(comStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comStatus2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(comStatus2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aidingStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(aidingStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uptime) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogStatusData),
            "::",
            stringify!(uptime)
        )
    );
}
#[doc = " Stores global status data."]
pub type SbgLogStatusData = _SbgLogStatusData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_STATUS message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseStatusData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogStatusData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_STATUS message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteStatusData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogStatusData,
    ) -> SbgErrorCode;
}
#[doc = " Log structure for USBL data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogUsblData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< USBL system status bitmask."]
    pub status: u16,
    #[doc = "< Latitude in degrees, positive north."]
    pub latitude: f64,
    #[doc = "< Longitude in degrees, positive east."]
    pub longitude: f64,
    #[doc = "< Depth in meters below mean sea level (positive down)."]
    pub depth: f32,
    #[doc = "< 1 sigma latitude accuracy in meters."]
    pub latitudeAccuracy: f32,
    #[doc = "< 1 sigma longitude accuracy in meters."]
    pub longitudeAccuracy: f32,
    #[doc = "< 1 sigma depth accuracy in meters."]
    pub depthAccuracy: f32,
}
#[test]
fn bindgen_test_layout__SbgLogUsblData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogUsblData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogUsblData>(),
        40usize,
        concat!("Size of: ", stringify!(_SbgLogUsblData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogUsblData>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgLogUsblData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(longitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitudeAccuracy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(latitudeAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitudeAccuracy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(longitudeAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depthAccuracy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUsblData),
            "::",
            stringify!(depthAccuracy)
        )
    );
}
#[doc = " Log structure for USBL data."]
pub type SbgLogUsblData = _SbgLogUsblData;
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_USBL message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseUsblData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogUsblData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_USBL message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteUsblData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogUsblData,
    ) -> SbgErrorCode;
}
#[doc = "< An error has occurred on the clock estimation."]
pub const _SbgEComClockStatus_SBG_ECOM_CLOCK_ERROR: _SbgEComClockStatus = 0;
#[doc = "< The clock is only based on the internal crystal."]
pub const _SbgEComClockStatus_SBG_ECOM_CLOCK_FREE_RUNNING: _SbgEComClockStatus = 1;
#[doc = "< A PPS has been detected and the clock is converging to it."]
pub const _SbgEComClockStatus_SBG_ECOM_CLOCK_STEERING: _SbgEComClockStatus = 2;
#[doc = "< The clock has converged to the PPS and is within 500ns."]
pub const _SbgEComClockStatus_SBG_ECOM_CLOCK_VALID: _SbgEComClockStatus = 3;
#[doc = " Clock status enum."]
pub type _SbgEComClockStatus = ::core::ffi::c_uint;
#[doc = " Clock status enum."]
pub use self::_SbgEComClockStatus as SbgEComClockStatus;
#[doc = "< The UTC time is not known, we are just propagating the UTC time internally."]
pub const _SbgEComClockUtcStatus_SBG_ECOM_UTC_INVALID: _SbgEComClockUtcStatus = 0;
#[doc = "< We have received valid UTC time information but we don't have the leap seconds information."]
pub const _SbgEComClockUtcStatus_SBG_ECOM_UTC_NO_LEAP_SEC: _SbgEComClockUtcStatus = 1;
#[doc = "< We have received valid UTC time data with valid leap seconds."]
pub const _SbgEComClockUtcStatus_SBG_ECOM_UTC_VALID: _SbgEComClockUtcStatus = 2;
#[doc = " Status for the UTC time data."]
pub type _SbgEComClockUtcStatus = ::core::ffi::c_uint;
#[doc = " Status for the UTC time data."]
pub use self::_SbgEComClockUtcStatus as SbgEComClockUtcStatus;
#[doc = " Structure that stores data for the SBG_ECOM_LOG_UTC_TIME message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgLogUtcData {
    #[doc = "< Time in us since the sensor power up."]
    pub timeStamp: u32,
    #[doc = "< UTC time and clock status information"]
    pub status: u16,
    #[doc = "< Year for example: 2013."]
    pub year: u16,
    #[doc = "< Month in year [1 .. 12]."]
    pub month: i8,
    #[doc = "< Day in month [1 .. 31]."]
    pub day: i8,
    #[doc = "< Hour in day [0 .. 23]."]
    pub hour: i8,
    #[doc = "< Minute in hour [0 .. 59]."]
    pub minute: i8,
    #[doc = "< Second in minute [0 .. 60]. (60 is used only when a leap second is added)"]
    pub second: i8,
    #[doc = "< Nanosecond of current second in ns."]
    pub nanoSecond: i32,
    #[doc = "< GPS time of week in ms."]
    pub gpsTimeOfWeek: u32,
}
#[test]
fn bindgen_test_layout__SbgLogUtcData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgLogUtcData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgLogUtcData>(),
        24usize,
        concat!("Size of: ", stringify!(_SbgLogUtcData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgLogUtcData>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgLogUtcData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nanoSecond) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(nanoSecond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpsTimeOfWeek) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgLogUtcData),
            "::",
            stringify!(gpsTimeOfWeek)
        )
    );
}
#[doc = " Structure that stores data for the SBG_ECOM_LOG_UTC_TIME message."]
pub type SbgLogUtcData = _SbgLogUtcData;
extern "C" {
    #[doc = " Returns the clock status as a NULL terminated C string.\n\n \\param[in]\tpLogUtc\t\t\t\tUTC log instance.\n \\return\t\t\t\t\t\t\tThe clock status as a C string."]
    pub fn sbgEcomLogUtcGetClockStatusAsString(
        pLogUtc: *const SbgLogUtcData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the UTC status as a NULL terminated C string.\n\n \\param[in]\tpLogUtc\t\t\t\tUTC log instance.\n \\return\t\t\t\t\t\t\tThe UTC status as a C string."]
    pub fn sbgEcomLogUtcGetUtcStatusAsString(
        pLogUtc: *const SbgLogUtcData,
    ) -> *const ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Parse data for the SBG_ECOM_LOG_UTC_DATA message and fill the corresponding structure.\n\n \\param[in]\tpInputStream\t\t\t\tInput stream buffer to read the payload from.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output structure that stores parsed data.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the payload has been parsed."]
    pub fn sbgEComBinaryLogParseUtcData(
        pInputStream: *mut SbgStreamBuffer,
        pOutputData: *mut SbgLogUtcData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Write data for the SBG_ECOM_LOG_UTC_DATA message to the output stream buffer from the provided structure.\n\n \\param[out]\tpOutputStream\t\t\t\tOutput stream buffer to write the payload to.\n \\param[in]\tpInputData\t\t\t\t\tPointer on the input structure that stores data to write.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the message has been generated in the provided buffer."]
    pub fn sbgEComBinaryLogWriteUtcData(
        pOutputStream: *mut SbgStreamBuffer,
        pInputData: *const SbgLogUtcData,
    ) -> SbgErrorCode;
}
#[doc = "\tUnion used to store received logs data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SbgBinaryLogData {
    #[doc = "< Stores data for the SBG_ECOM_LOG_STATUS message."]
    pub statusData: SbgLogStatusData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_IMU_DATA message."]
    pub imuData: SbgLogImuData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_IMU_SHORT message."]
    pub imuShort: SbgLogImuShort,
    #[doc = "< Stores data for the SBG_ECOM_LOG_EKF_EULER message."]
    pub ekfEulerData: SbgLogEkfEulerData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_EKF_QUAT message."]
    pub ekfQuatData: SbgLogEkfQuatData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_EKF_NAV message."]
    pub ekfNavData: SbgLogEkfNavData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_SHIP_MOTION or SBG_ECOM_LOG_SHIP_MOTION_HP message."]
    pub shipMotionData: SbgLogShipMotionData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_ODO_VEL message."]
    pub odometerData: SbgLogOdometerData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_UTC_TIME message."]
    pub utcData: SbgLogUtcData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_GPS_POS message."]
    pub gpsPosData: SbgLogGpsPos,
    #[doc = "< Stores data for the SBG_ECOM_LOG_GPS#_VEL message."]
    pub gpsVelData: SbgLogGpsVel,
    #[doc = "< Stores data for the SBG_ECOM_LOG_GPS#_HDT message."]
    pub gpsHdtData: SbgLogGpsHdt,
    #[doc = "< Stores data for the SBG_ECOM_LOG_GPS#_RAW message."]
    pub gpsRawData: SbgLogRawData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_RTCM_RAW message."]
    pub rtcmRawData: SbgLogRawData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_MAG message."]
    pub magData: SbgLogMag,
    #[doc = "< Stores data for the SBG_ECOM_LOG_MAG_CALIB message."]
    pub magCalibData: SbgLogMagCalib,
    #[doc = "< Stores data for the SBG_ECOM_LOG_DVL_BOTTOM_TRACK message."]
    pub dvlData: SbgLogDvlData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_AIR_DATA message."]
    pub airData: SbgLogAirData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_USBL message."]
    pub usblData: SbgLogUsblData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_DEPTH message"]
    pub depthData: SbgLogDepth,
    #[doc = "< Stores data for the SBG_ECOM_LOG_EVENT_# message."]
    pub eventMarker: SbgLogEvent,
    #[doc = "< Stores data for the SBG_ECOM_LOG_DIAG message."]
    pub diagData: SbgLogDiagData,
    #[doc = "< Stores data for the SBG_ECOM_LOG_SAT message."]
    pub satGroupData: SbgLogSatGroupData,
    #[doc = "< Stores Fast Imu Data for 1KHz output"]
    pub fastImuData: SbgLogFastImuData,
}
#[test]
fn bindgen_test_layout__SbgBinaryLogData() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgBinaryLogData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgBinaryLogData>(),
        4096usize,
        concat!("Size of: ", stringify!(_SbgBinaryLogData))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgBinaryLogData>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgBinaryLogData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statusData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(statusData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imuData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(imuData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imuShort) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(imuShort)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ekfEulerData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(ekfEulerData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ekfQuatData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(ekfQuatData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ekfNavData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(ekfNavData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shipMotionData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(shipMotionData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).odometerData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(odometerData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).utcData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(utcData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpsPosData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(gpsPosData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpsVelData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(gpsVelData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpsHdtData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(gpsHdtData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpsRawData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(gpsRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtcmRawData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(rtcmRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(magData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magCalibData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(magCalibData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dvlData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(dvlData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).airData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(airData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usblData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(usblData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depthData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(depthData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventMarker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(eventMarker)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).diagData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(diagData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).satGroupData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(satGroupData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastImuData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgBinaryLogData),
            "::",
            stringify!(fastImuData)
        )
    );
}
#[doc = "\tUnion used to store received logs data."]
pub type SbgBinaryLogData = _SbgBinaryLogData;
extern "C" {
    #[doc = " Parse an incoming log and fill the output union.\n\n \\param[in]\tmsgClass\t\t\t\t\tReceived message class\n \\param[in]\tmsg\t\t\t\t\t\t\tReceived message ID\n \\param[in]\tpPayload\t\t\t\t\tRead only pointer on the payload buffer.\n \\param[in]\tpayloadSize\t\t\t\t\tPayload size in bytes.\n \\param[out]\tpOutputData\t\t\t\t\tPointer on the output union that stores parsed data."]
    pub fn sbgEComBinaryLogParse(
        msgClass: SbgEComClass,
        msg: SbgEComMsgId,
        pPayload: *const ::core::ffi::c_void,
        payloadSize: usize,
        pOutputData: *mut SbgBinaryLogData,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Clean up resources allocated during parsing, if any.\n\n \\param[in]\tpLogData\t\t\t\t\tLog data.\n \\param[in]\tmsgClass\t\t\t\t\tMessage class.\n \\param[in]\tmsgId\t\t\t\t\t\tMessage ID."]
    pub fn sbgEComBinaryLogCleanup(
        pLogData: *mut SbgBinaryLogData,
        msgClass: SbgEComClass,
        msgId: SbgEComMsgId,
    );
}
#[doc = " Interface definition that stores methods used to communicate on the interface."]
pub type SbgEComHandle = _SbgEComHandle;
#[doc = " Callback definition called each time a new log is received.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\t\t\tValid handle on the sbgECom instance that has called this callback.\n \\param[in]\tmsgClass\t\t\t\t\t\t\t\tClass of the message we have received\n \\param[in]\tmsg\t\t\t\t\t\t\t\t\t\tMessage ID of the log received.\n \\param[in]\tpLogData\t\t\t\t\t\t\t\tContains the received log data as an union.\n \\param[in]\tpUserArg\t\t\t\t\t\t\t\tOptional user supplied argument.\n \\return\t\t\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the received log has been used successfully."]
pub type SbgEComReceiveLogFunc = ::core::option::Option<
    unsafe extern "C" fn(
        pHandle: *mut SbgEComHandle,
        msgClass: SbgEComClass,
        msg: SbgEComMsgId,
        pLogData: *const SbgBinaryLogData,
        pUserArg: *mut ::core::ffi::c_void,
    ) -> SbgErrorCode,
>;
#[doc = " Interface definition that stores methods used to communicate on the interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComHandle {
    #[doc = "< Handle on the protocol system."]
    pub protocolHandle: SbgEComProtocol,
    #[doc = "< Pointer on the method called each time a new binary log is received."]
    pub pReceiveLogCallback: SbgEComReceiveLogFunc,
    #[doc = "< Optional user supplied argument for callbacks."]
    pub pUserArg: *mut ::core::ffi::c_void,
    #[doc = "< Number of trials when a command is sent (default is 3)."]
    pub numTrials: u32,
    #[doc = "< Default time out in ms to get an answer from the device (default 500 ms)."]
    pub cmdDefaultTimeOut: u32,
}
#[test]
fn bindgen_test_layout__SbgEComHandle() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComHandle> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComHandle>(),
        4144usize,
        concat!("Size of: ", stringify!(_SbgEComHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocolHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComHandle),
            "::",
            stringify!(protocolHandle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pReceiveLogCallback) as usize - ptr as usize },
        4128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComHandle),
            "::",
            stringify!(pReceiveLogCallback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pUserArg) as usize - ptr as usize },
        4132usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComHandle),
            "::",
            stringify!(pUserArg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numTrials) as usize - ptr as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComHandle),
            "::",
            stringify!(numTrials)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmdDefaultTimeOut) as usize - ptr as usize },
        4140usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComHandle),
            "::",
            stringify!(cmdDefaultTimeOut)
        )
    );
}
extern "C" {
    #[doc = " Initialize the protocol system used to communicate with the product and return the created handle.\n\n \\param[out]\tpHandle\t\t\t\t\t\t\tPointer used to store the allocated and initialized sbgECom handle.\n \\param[in]\tpInterface\t\t\t\t\t\tInterface to use for read/write operations.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if we have initialized the protocol system."]
    pub fn sbgEComInit(pHandle: *mut SbgEComHandle, pInterface: *mut SbgInterface) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Close the protocol system and release associated memory.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle to close.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if we have closed and released the sbgECom system."]
    pub fn sbgEComClose(pHandle: *mut SbgEComHandle) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Try to parse one log from the input interface and then return.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if no error occurs during incoming log parsing."]
    pub fn sbgEComHandleOneLog(pHandle: *mut SbgEComHandle) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Handle all incoming logs until no more log are available in the input interface.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if no error occurs during incoming logs parsing."]
    pub fn sbgEComHandle(pHandle: *mut SbgEComHandle) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Purge the interface rx buffer as well as the sbgECom rx work buffer.\n\n For example, if the program flow has been interrupted, this method can be helpful to discard all trash received data.\n\n WARNING: This method is blocking for 100ms and actively tries to read incoming data.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle.\n \\return\t\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the incoming data has been purged successfully."]
    pub fn sbgEComPurgeIncoming(pHandle: *mut SbgEComHandle) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Define the callback that should be called each time a new binary log is received.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpReceiveLogCallback\t\t\t\tPointer on the callback to call when a new log is received.\n \\param[in]\tpUserArg\t\t\t\t\t\tOptional user argument that will be passed to the callback method."]
    pub fn sbgEComSetReceiveLogCallback(
        pHandle: *mut SbgEComHandle,
        pReceiveLogCallback: SbgEComReceiveLogFunc,
        pUserArg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Define the default number of trials that should be done when a command is send to the device as well as the time out.\n\n \\param[in]\tpHandle\t\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tnumTrials\t\t\t\t\t\tNumber of trials when a command is sent (starting at 1).\n \\param[in]\tcmdDefaultTimeOut\t\t\t\tDefault time out in milliseconds to wait to receive an answer from the device."]
    pub fn sbgEComSetCmdTrialsAndTimeOut(
        pHandle: *mut SbgEComHandle,
        numTrials: u32,
        cmdDefaultTimeOut: u32,
    );
}
extern "C" {
    #[doc = "\tConvert an error code into a human readable string.\n\n\t\\param[in]\terrorCode\t\t\t\t\t\tThe errorCode to convert into a string.\n\t\\param[out]\terrorMsg\t\t\t\t\t\tString buffer used to hold the error string."]
    pub fn sbgEComErrorToString(errorCode: SbgErrorCode, errorMsg: *mut ::core::ffi::c_char);
}
#[doc = "< The device is running it's internal clock without any time reference."]
pub const _SbgEComTimeReferenceSrc_SBG_ECOM_TIME_REF_DISABLED: _SbgEComTimeReferenceSrc = 0;
#[doc = "< The main port sync in A is used as a time reference."]
pub const _SbgEComTimeReferenceSrc_SBG_ECOM_TIME_REF_SYNC_IN_A: _SbgEComTimeReferenceSrc = 1;
#[doc = "< The GPS 1 module is used to provide both time reference and UTC data."]
pub const _SbgEComTimeReferenceSrc_SBG_ECOM_TIME_REF_UTC_GPS_1: _SbgEComTimeReferenceSrc = 2;
#[doc = " List of available time reference source."]
pub type _SbgEComTimeReferenceSrc = ::core::ffi::c_uint;
#[doc = " List of available time reference source."]
pub use self::_SbgEComTimeReferenceSrc as SbgEComTimeReferenceSrc;
#[doc = " Structure containing all the info for advanced configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComAdvancedConf {
    #[doc = "< Time reference source for clock alignment."]
    pub timeReference: SbgEComTimeReferenceSrc,
    #[doc = "< Advanced GNSS options - contact SBG Systems."]
    pub gnssOptions: u32,
    #[doc = "< Advanced NMEA output options."]
    pub nmeaOptions: u32,
}
#[test]
fn bindgen_test_layout__SbgEComAdvancedConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComAdvancedConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComAdvancedConf>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgEComAdvancedConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComAdvancedConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComAdvancedConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAdvancedConf),
            "::",
            stringify!(timeReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssOptions) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAdvancedConf),
            "::",
            stringify!(gnssOptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nmeaOptions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAdvancedConf),
            "::",
            stringify!(nmeaOptions)
        )
    );
}
#[doc = " Structure containing all the info for advanced configuration."]
pub type SbgEComAdvancedConf = _SbgEComAdvancedConf;
#[doc = " Structure containing all validity thresholds (status outputs)\n Setting these thresholds to 0.0 will keep default configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComValidityThresholds {
    #[doc = "< Norm of the position standard deviation threshold to raise position valid flag (m)"]
    pub positionThreshold: f32,
    #[doc = "< Norm of the velocity standard deviation threshold to raise velocity valid flag  (m/s)"]
    pub velocityThreshold: f32,
    #[doc = "< Max of the roll/pitch standard deviations threshold to raise attitude valid flag (rad)"]
    pub attitudeThreshold: f32,
    #[doc = "< Heading standard deviations threshold to raise heading valid flag (rad)"]
    pub headingThreshold: f32,
}
#[test]
fn bindgen_test_layout__SbgEComValidityThresholds() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComValidityThresholds> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComValidityThresholds>(),
        16usize,
        concat!("Size of: ", stringify!(_SbgEComValidityThresholds))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComValidityThresholds>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComValidityThresholds))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positionThreshold) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComValidityThresholds),
            "::",
            stringify!(positionThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocityThreshold) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComValidityThresholds),
            "::",
            stringify!(velocityThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attitudeThreshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComValidityThresholds),
            "::",
            stringify!(attitudeThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).headingThreshold) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComValidityThresholds),
            "::",
            stringify!(headingThreshold)
        )
    );
}
#[doc = " Structure containing all validity thresholds (status outputs)\n Setting these thresholds to 0.0 will keep default configuration"]
pub type SbgEComValidityThresholds = _SbgEComValidityThresholds;
extern "C" {
    #[doc = " Retrieve the advanced configurations.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComAdvancedConf to contain the current configuration.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAdvancedGetConf(
        pHandle: *mut SbgEComHandle,
        pConf: *mut SbgEComAdvancedConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the advanced configurations.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComAdvancedConf that contains the new configuration.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAdvancedSetConf(
        pHandle: *mut SbgEComHandle,
        pConf: *const SbgEComAdvancedConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the current validity thresholds\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComValidityThresholds to contain the current configuration.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAdvancedGetThresholds(
        pHandle: *mut SbgEComHandle,
        pConf: *mut SbgEComValidityThresholds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the validity thresholds\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComValidityThresholds that contains the new configuration.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAdvancedSetThresholds(
        pHandle: *mut SbgEComHandle,
        pConf: *const SbgEComValidityThresholds,
    ) -> SbgErrorCode;
}
#[doc = "< Measurement is not taken into account."]
pub const _SbgEComRejectionMode_SBG_ECOM_NEVER_ACCEPT_MODE: _SbgEComRejectionMode = 0;
#[doc = "< Measurement is accepted and rejected automatically depending on consistency checks"]
pub const _SbgEComRejectionMode_SBG_ECOM_AUTOMATIC_MODE: _SbgEComRejectionMode = 1;
#[doc = "< Measurement is always accepted. Should be used with caution"]
pub const _SbgEComRejectionMode_SBG_ECOM_ALWAYS_ACCEPT_MODE: _SbgEComRejectionMode = 2;
#[doc = " List of all rejection modes for aiding inputs."]
pub type _SbgEComRejectionMode = ::core::ffi::c_uint;
#[doc = " List of all rejection modes for aiding inputs."]
pub use self::_SbgEComRejectionMode as SbgEComRejectionMode;
#[doc = "< IMU/module Axis is turned in vehicle's forward direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_FORWARD: _SbgEComAxisDirection = 0;
#[doc = "< IMU/module Axis is turned in vehicle's backward direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_BACKWARD: _SbgEComAxisDirection = 1;
#[doc = "< IMU/module Axis is turned in vehicle's left direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_LEFT: _SbgEComAxisDirection = 2;
#[doc = "< IMU/module Axis is turned in vehicle's right direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_RIGHT: _SbgEComAxisDirection = 3;
#[doc = "< IMU/module Axis is turned in vehicle's up direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_UP: _SbgEComAxisDirection = 4;
#[doc = "< IMU/module Axis is turned in vehicle's down direction."]
pub const _SbgEComAxisDirection_SBG_ECOM_ALIGNMENT_DOWN: _SbgEComAxisDirection = 5;
#[doc = " List of all axis directions for modules/sensor alignment."]
pub type _SbgEComAxisDirection = ::core::ffi::c_uint;
#[doc = " List of all axis directions for modules/sensor alignment."]
pub use self::_SbgEComAxisDirection as SbgEComAxisDirection;
extern "C" {
    #[doc = " Receive a command message.\n\n All binary logs received are handled trough the standard callback system.\n\n \\param[in]\tpHandle\t\t\t\t\tSbgECom handle.\n \\param[out]\tpMsgClass\t\t\t\tMessage class.\n \\param[out]\tpMsgId\t\t\t\t\tMessage ID.\n \\param[out]\tpData\t\t\t\t\tData buffer, may be NULL.\n \\param[out]\tpSize\t\t\t\t\tNumber of bytes received, in bytes, may be NULL.\n \\param[in]\tmaxSize\t\t\t\t\tData buffer size, in bytes.\n \\param[in]\ttimeOut\t\t\t\t\tTime-out, in ms.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no command message has been received,\n\t\t\t\t\t\t\t\t\t\tSBG_BUFFER_OVERFLOW if the payload of the received frame couldn't fit into the buffer,\n\t\t\t\t\t\t\t\t\t\tSBG_TIME_OUT if no command message was received within the specified time out."]
    pub fn sbgEComReceiveAnyCmd(
        pHandle: *mut SbgEComHandle,
        pMsgClass: *mut u8,
        pMsgId: *mut u8,
        pData: *mut ::core::ffi::c_void,
        pSize: *mut usize,
        maxSize: usize,
        timeOut: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Receive a command message.\n\n All binary logs received are handled trough the standard callback system.\n\n This function is equivalent to sbgEComReceiveAnyCmd() with two exceptions :\n  - the use of a payload object allows handling payloads not limited by the size of a user-provided buffer\n  - the payload object allows direct access to the protocol work buffer to avoid an extra copy per call\n\n Any allocated resource associated with the given payload is released when calling this function.\n\n Because the payload buffer may directly refer to the protocol work buffer on return, it is only valid until\n the next attempt to receive a frame, with any of the receive functions.\n\n \\param[in]\tpHandle\t\t\t\t\tSbgECom handle.\n \\param[out]\tpMsgClass\t\t\t\tMessage class.\n \\param[out]\tpMsgId\t\t\t\t\tMessage ID.\n \\param[out]\tpPayload\t\t\t\tPayload.\n \\param[in]\ttimeOut\t\t\t\t\tTime-out, in ms.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no command message has been received,\n\t\t\t\t\t\t\t\t\t\tSBG_TIME_OUT if no command message was received within the specified time out."]
    pub fn sbgEComReceiveAnyCmd2(
        pHandle: *mut SbgEComHandle,
        pMsgClass: *mut u8,
        pMsgId: *mut u8,
        pPayload: *mut SbgEComProtocolPayload,
        timeOut: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Receive a specific command message.\n\n This function also processes ACK messages for the given class and ID.\n\n All binary logs received during this time are handled trough the standard callback system.\n\n \\param[in]\tpHandle\t\t\t\t\tSbgECom handle.\n \\param[in]\tmsgClass\t\t\t\tMessage class.\n \\param[in]\tmsgId\t\t\t\t\tMessage ID.\n \\param[out]\tpData\t\t\t\t\tData buffer.\n \\param[out]\tpSize\t\t\t\t\tNumber of bytes received, in bytes.\n \\param[in]\tmaxSize\t\t\t\t\tData buffer size, in bytes.\n \\param[in]\ttimeOut\t\t\t\t\tTime-out, in ms.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no command message has been received,\n\t\t\t\t\t\t\t\t\t\tSBG_BUFFER_OVERFLOW if the payload of the received frame couldn't fit into the buffer,\n\t\t\t\t\t\t\t\t\t\tSBG_TIME_OUT if no command message was received within the specified time out,\n\t\t\t\t\t\t\t\t\t\tany error code reported by an ACK message for the given class and ID."]
    pub fn sbgEComReceiveCmd(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msgId: u8,
        pData: *mut ::core::ffi::c_void,
        pSize: *mut usize,
        maxSize: usize,
        timeOut: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Receive a specific command message.\n\n This function also processes ACK messages for the given class and ID.\n\n All binary logs received during this time are handled trough the standard callback system.\n\n This function is equivalent to sbgEComReceiveCmd() with two exceptions :\n  - the use of a payload object allows handling payloads not limited by the size of a user-provided buffer\n  - the payload object allows direct access to the protocol work buffer to avoid an extra copy per call\n\n Any allocated resource associated with the given payload is released when calling this function.\n\n Because the payload buffer may directly refer to the protocol work buffer on return, it is only valid until\n the next attempt to receive a frame, with any of the receive functions.\n\n \\param[in]\tpHandle\t\t\t\t\tSbgECom handle.\n \\param[in]\tmsgClass\t\t\t\tMessage class.\n \\param[in]\tmsgId\t\t\t\t\tMessage ID.\n \\param[out]\tpPayload\t\t\t\tPayload.\n \\param[in]\ttimeOut\t\t\t\t\tTime-out, in ms.\n \\return\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful,\n\t\t\t\t\t\t\t\t\t\tSBG_NOT_READY if no command message has been received,\n\t\t\t\t\t\t\t\t\t\tSBG_TIME_OUT if no command message was received within the specified time out,\n\t\t\t\t\t\t\t\t\t\tany error code reported by an ACK message for the given class and ID."]
    pub fn sbgEComReceiveCmd2(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msgId: u8,
        pPayload: *mut SbgEComProtocolPayload,
        timeOut: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Wait for an ACK for a specified amount of time.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmsgClass\t\t\t\t\tThe message class that we want to check\n \\param[in]\tmsg\t\t\t\t\t\t\tThe message ID that we want to check\n \\param[in]\ttimeOut\t\t\t\t\t\tTime out in ms during which we can receive the ACK.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the ACK has been received."]
    pub fn sbgEComWaitForAck(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msg: u8,
        timeOut: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Send an ACK for a specific command with an associated error code.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmsgClass\t\t\t\t\tThe message class that we want to send\n \\param[in]\tmsg\t\t\t\t\t\t\tThe message ID that we want to send.\n \\param[in]\tcmdError\t\t\t\t\tThe associated error code.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the ACK has been sent."]
    pub fn sbgEComSendAck(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msg: u8,
        cmdError: SbgErrorCode,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Generic function to set an error model ID\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmsgClass\t\t\t\t\tOriginal message class\n \\param[in]\tmsg\t\t\t\t\t\t\tOriginal message ID\n \\param[in]\tmodelId\t\t\t\t\t\tModel ID to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGenericSetModelId(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msg: u8,
        modelId: u32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Generic function to get an error model ID\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmsgClass\t\t\t\t\tOriginal message class\n \\param[in]\tmsg\t\t\t\t\t\t\tOriginal message ID\n \\param[out]\tpModelId\t\t\t\t\tReturns the currently used model ID.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGenericGetModelId(
        pHandle: *mut SbgEComHandle,
        msgClass: u8,
        msg: u8,
        pModelId: *mut u32,
    ) -> SbgErrorCode;
}
#[doc = "< Use the internal barometer sensor if available."]
pub const _SbgEComAirDataModelsIds_SBG_ECOM_AIR_DATA_MODEL_INTERNAL: _SbgEComAirDataModelsIds = 1;
#[doc = "< Generic AirData model using sbgECom input protocol format."]
pub const _SbgEComAirDataModelsIds_SBG_ECOM_AIR_DATA_MODEL_GENERIC_ECOM: _SbgEComAirDataModelsIds =
    2;
#[doc = "< Crossbow AHRS-500 compatible input for barometric altitude and airspeed."]
pub const _SbgEComAirDataModelsIds_SBG_ECOM_AIR_DATA_MODEL_AHRS_500: _SbgEComAirDataModelsIds = 3;
#[doc = " This enum defines the different AirData model IDs available in standard"]
pub type _SbgEComAirDataModelsIds = ::core::ffi::c_uint;
#[doc = " This enum defines the different AirData model IDs available in standard"]
pub use self::_SbgEComAirDataModelsIds as SbgEComAirDataModelsIds;
#[doc = " Holds all necessary information for AirData module data rejection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComAirDataRejectionConf {
    #[doc = "< Rejection mode for the true air speed measurement."]
    pub airspeed: SbgEComRejectionMode,
    #[doc = "< Rejection mode for the barometric altitude measurement."]
    pub altitude: SbgEComRejectionMode,
}
#[test]
fn bindgen_test_layout__SbgEComAirDataRejectionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComAirDataRejectionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComAirDataRejectionConf>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgEComAirDataRejectionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComAirDataRejectionConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComAirDataRejectionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).airspeed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAirDataRejectionConf),
            "::",
            stringify!(airspeed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAirDataRejectionConf),
            "::",
            stringify!(altitude)
        )
    );
}
#[doc = " Holds all necessary information for AirData module data rejection."]
pub type SbgEComAirDataRejectionConf = _SbgEComAirDataRejectionConf;
extern "C" {
    #[doc = " Set the AirData model to use that both defines the protocol as well as the associated error model.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmodelId\t\t\t\t\t\tAirData model ID to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataSetModelId(
        pHandle: *mut SbgEComHandle,
        modelId: SbgEComAirDataModelsIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the AirData model id currently in use by the device.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpModelId\t\t\t\t\tReturns the AirData model ID currently in use by the device.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataGetModelId(
        pHandle: *mut SbgEComHandle,
        pModelId: *mut SbgEComAirDataModelsIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the lever arm configuration of the AirData module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpLeverArm\t\t\t\t\tThe X, Y, Z airspeed sensor lever arm in meters from the pitot sensor to the IMU.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataSetLeverArm(
        pHandle: *mut SbgEComHandle,
        pLeverArm: *const f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the lever arm configuration of the AirData module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpLeverArm\t\t\t\t\tReturns the airspeed sensor X,Y,Z lever arm in meters from the pitot sensor to the IMU.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataGetLeverArm(
        pHandle: *mut SbgEComHandle,
        pLeverArm: *mut f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the rejection configuration of the AirData module (this command doesn't need a reboot to be applied)\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tThe new rejection configuration to set.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataSetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *const SbgEComAirDataRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the current rejection configuration of the AirData module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tReturn the rejection configuration currently in use.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdAirDataGetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *mut SbgEComAirDataRejectionConf,
    ) -> SbgErrorCode;
}
#[doc = " Reply to REST API commands.\n\n The reply content is a null-terminated string, normally in JSON format.\n\n The content directly refers to data inside the payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComCmdApiReply {
    #[doc = "< Payload."]
    pub payload: SbgEComProtocolPayload,
    #[doc = "< Status code."]
    pub statusCode: u16,
    #[doc = "< Content."]
    pub pContent: *const ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout__SbgEComCmdApiReply() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComCmdApiReply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComCmdApiReply>(),
        20usize,
        concat!("Size of: ", stringify!(_SbgEComCmdApiReply))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComCmdApiReply>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComCmdApiReply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdApiReply),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statusCode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdApiReply),
            "::",
            stringify!(statusCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pContent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdApiReply),
            "::",
            stringify!(pContent)
        )
    );
}
#[doc = " Reply to REST API commands.\n\n The reply content is a null-terminated string, normally in JSON format.\n\n The content directly refers to data inside the payload."]
pub type SbgEComCmdApiReply = _SbgEComCmdApiReply;
extern "C" {
    #[doc = " REST API reply constructor.\n\n \\param[in]\tpReply\t\t\t\t\t\tREST API reply."]
    pub fn sbgEComCmdApiReplyConstruct(pReply: *mut SbgEComCmdApiReply);
}
extern "C" {
    #[doc = " REST API reply destructor.\n\n \\param[in]\tpReply\t\t\t\t\t\tREST API reply."]
    pub fn sbgEComCmdApiReplyDestroy(pReply: *mut SbgEComCmdApiReply);
}
extern "C" {
    #[doc = " Check if a reply indicates successful command execution.\n\n \\param[in]\tpReply\t\t\t\t\t\tREST API reply.\n \\return\t\t\t\t\t\t\t\t\tTrue if the reply indicates successful command execution."]
    pub fn sbgEComCmdApiReplySuccessful(pReply: *const SbgEComCmdApiReply) -> bool;
}
extern "C" {
    #[doc = " Send a GET command.\n\n The reply must be destroyed before the next attempt to receive data, either logs or command replies.\n\n \\param[in]\tpHandle\t\t\t\t\t\tECom handle.\n \\param[in]\tpPath\t\t\t\t\t\tURI path component.\n \\param[in]\tpQuery\t\t\t\t\t\tQuery string, may be NULL.\n \\param[out]\tpReply\t\t\t\t\t\tReply.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
    pub fn sbgEComCmdApiGet(
        pHandle: *mut SbgEComHandle,
        pPath: *const ::core::ffi::c_char,
        pQuery: *const ::core::ffi::c_char,
        pReply: *mut SbgEComCmdApiReply,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Send a POST command.\n\n The reply must be destroyed before the next attempt to receive data, either logs or command replies.\n\n \\param[in]\tpHandle\t\t\t\t\t\tECom handle.\n \\param[in]\tpPath\t\t\t\t\t\tURI path component.\n \\param[in]\tpQuery\t\t\t\t\t\tQuery string, may be NULL.\n \\param[in]\tpBody\t\t\t\t\t\tBody, may be NULL.\n \\param[out]\tpReply\t\t\t\t\t\tReply.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if successful."]
    pub fn sbgEComCmdApiPost(
        pHandle: *mut SbgEComHandle,
        pPath: *const ::core::ffi::c_char,
        pQuery: *const ::core::ffi::c_char,
        pBody: *const ::core::ffi::c_char,
        pReply: *mut SbgEComCmdApiReply,
    ) -> SbgErrorCode;
}
#[doc = "< Generic DVL using PD6 protocol format."]
pub const _SbgEComDvlModelsIds_SBG_ECOM_DVL_MODEL_GENERIC_PD6: _SbgEComDvlModelsIds = 202;
#[doc = "< Teledyne Wayfinder DVL using proprietary protocol."]
pub const _SbgEComDvlModelsIds_SBG_ECOM_DVL_MODEL_WAYFINDER: _SbgEComDvlModelsIds = 203;
#[doc = " This enum defines the different DVL model IDs available in standard"]
pub type _SbgEComDvlModelsIds = ::core::ffi::c_uint;
#[doc = " This enum defines the different DVL model IDs available in standard"]
pub use self::_SbgEComDvlModelsIds as SbgEComDvlModelsIds;
#[doc = " DVL mechanical installation parameters such as lever arm and alignment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComDvlInstallation {
    #[doc = "< X, Y, Z DVL lever arm in meters expressed from the DVL to the IMU."]
    pub leverArm: [f32; 3usize],
    #[doc = "< Roll, pitch, yaw DVL alignment expressed in radians."]
    pub alignment: [f32; 3usize],
    #[doc = "< Set to true if both the DVL lever arm and DVL alignment are precise and don't require in-run estimation."]
    pub preciseInstallation: bool,
}
#[test]
fn bindgen_test_layout__SbgEComDvlInstallation() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComDvlInstallation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComDvlInstallation>(),
        28usize,
        concat!("Size of: ", stringify!(_SbgEComDvlInstallation))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComDvlInstallation>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComDvlInstallation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leverArm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDvlInstallation),
            "::",
            stringify!(leverArm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDvlInstallation),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preciseInstallation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDvlInstallation),
            "::",
            stringify!(preciseInstallation)
        )
    );
}
#[doc = " DVL mechanical installation parameters such as lever arm and alignment"]
pub type SbgEComDvlInstallation = _SbgEComDvlInstallation;
#[doc = " Holds all necessary information for DVL module data rejection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComDvlRejectionConf {
    #[doc = "< Rejection mode for the bottom tracking (ie when the velocity  measurement is in respect to the seabed)."]
    pub bottomLayer: SbgEComRejectionMode,
    #[doc = "< Rejection mode for the water tracking (ie when the velocity measurement is relative to a water layer)."]
    pub waterLayer: SbgEComRejectionMode,
}
#[test]
fn bindgen_test_layout__SbgEComDvlRejectionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComDvlRejectionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComDvlRejectionConf>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgEComDvlRejectionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComDvlRejectionConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComDvlRejectionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottomLayer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDvlRejectionConf),
            "::",
            stringify!(bottomLayer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waterLayer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDvlRejectionConf),
            "::",
            stringify!(waterLayer)
        )
    );
}
#[doc = " Holds all necessary information for DVL module data rejection."]
pub type SbgEComDvlRejectionConf = _SbgEComDvlRejectionConf;
extern "C" {
    #[doc = " Set the DVL model to use that both defines the protocol as well as the associated error model.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmodelId\t\t\t\t\t\tDVL model ID to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlSetModelId(
        pHandle: *mut SbgEComHandle,
        modelId: SbgEComDvlModelsIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the DVL model id currently in use by the device.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpModelId\t\t\t\t\tReturns the DVL model ID currently in use by the device.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlGetModelId(
        pHandle: *mut SbgEComHandle,
        pModelId: *mut SbgEComDvlModelsIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the lever arm and alignment configuration of the DVL module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpDvlInstallation\t\t\tThe DVL lever arm and alignment configuration to apply.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlInstallationSet(
        pHandle: *mut SbgEComHandle,
        pDvlInstallation: *const SbgEComDvlInstallation,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the lever arm and alignment configuration of the DVL module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpDvlInstallation\t\t\tReturns the DVL lever arm and alignment configuration currently in use.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlInstallationGet(
        pHandle: *mut SbgEComHandle,
        pDvlInstallation: *mut SbgEComDvlInstallation,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the rejection configuration of the DVL module (this command doesn't need a reboot to be applied)\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tThe new DVL rejection configuration to set.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlSetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *const SbgEComDvlRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the current rejection configuration of the DVL module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tReturn the DVL rejection configuration currently in use.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdDvlGetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *mut SbgEComDvlRejectionConf,
    ) -> SbgErrorCode;
}
#[doc = "< The TCP/IP configuration should be acquired from a DHCP server."]
pub const _SbgEComEthernetMode_SBG_ECOM_ETHERNET_DHCP: _SbgEComEthernetMode = 0;
#[doc = "< The TCP/IP configuration is manually defined."]
pub const _SbgEComEthernetMode_SBG_ECOM_ETHERNET_STATIC: _SbgEComEthernetMode = 1;
#[doc = " Enum that defines the different type of IP acquisition method."]
pub type _SbgEComEthernetMode = ::core::ffi::c_uint;
#[doc = " Enum that defines the different type of IP acquisition method."]
pub use self::_SbgEComEthernetMode as SbgEComEthernetMode;
#[doc = " Structure that contains all Ethernet configuration or settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComEthernetConf {
    #[doc = "< Define how the device will acquiere its IP address, either DHCP or Static."]
    pub mode: SbgEComEthernetMode,
    #[doc = "< For static mode, defines the device IP address."]
    pub ipAddress: sbgIpAddress,
    #[doc = "< For static mode, defines the device net mask."]
    pub netmask: sbgIpAddress,
    #[doc = "< For static mode, defines the gateway to use."]
    pub gateway: sbgIpAddress,
    #[doc = "< For static mode, defines the primary DNS to use."]
    pub dns1: sbgIpAddress,
    #[doc = "< For static mode, defines the secondary DNS to use."]
    pub dns2: sbgIpAddress,
}
#[test]
fn bindgen_test_layout__SbgEComEthernetConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComEthernetConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComEthernetConf>(),
        24usize,
        concat!("Size of: ", stringify!(_SbgEComEthernetConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComEthernetConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComEthernetConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(ipAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gateway) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(gateway)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dns1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(dns1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dns2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComEthernetConf),
            "::",
            stringify!(dns2)
        )
    );
}
#[doc = " Structure that contains all Ethernet configuration or settings."]
pub type SbgEComEthernetConf = _SbgEComEthernetConf;
extern "C" {
    #[doc = " Get the configuration for the Ethernet interface.\n\n Warning: this method only returns the Ethernet configuration and NOT the ip address currently used by the device.\n You should rather use sbgEComEthernetInfo to retreive the current assigned IP.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpEthernetConf\t\t\t\tPoiner to a SbgEComEthernetConf struct that holds the read configuration from the device.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComEthernetGetConf(
        pHandle: *mut SbgEComHandle,
        pEthernetConf: *mut SbgEComEthernetConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the configuration for the Ethernet interface.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpEthernetConf\t\t\t\tPoiner to a SbgEComEthernetConf struct that holds the new configuration to apply.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComEthernetSetConf(
        pHandle: *mut SbgEComHandle,
        pEthernetConf: *const SbgEComEthernetConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Get the current assigned and used IP address as well as network inforamtion.\n\n In opposition to sbgEComEthernetGetConf, this method will not return the Ethernet configuration.\n It will rather return the IP address currently used by the device.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpEthernetConf\t\t\t\tPoiner to a SbgEComEthernetConf struct that holds the read IP settings from the device.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComEthernetInfo(
        pHandle: *mut SbgEComHandle,
        pEthernetConf: *mut SbgEComEthernetConf,
    ) -> SbgErrorCode;
}
#[doc = "< Sync IN A"]
pub const _SbgEComSyncInId_SBG_ECOM_SYNC_IN_A: _SbgEComSyncInId = 0;
#[doc = "< Sync IN B"]
pub const _SbgEComSyncInId_SBG_ECOM_SYNC_IN_B: _SbgEComSyncInId = 1;
#[doc = "< Sync IN C"]
pub const _SbgEComSyncInId_SBG_ECOM_SYNC_IN_C: _SbgEComSyncInId = 2;
#[doc = "< Sync IN D"]
pub const _SbgEComSyncInId_SBG_ECOM_SYNC_IN_D: _SbgEComSyncInId = 3;
#[doc = " List of sync in signals available."]
pub type _SbgEComSyncInId = ::core::ffi::c_uint;
#[doc = " List of sync in signals available."]
pub use self::_SbgEComSyncInId as SbgEComSyncInId;
#[doc = "< This trigger is turned OFF."]
pub const _SbgEComSyncInSensitivity_SBG_ECOM_SYNC_IN_DISABLED: _SbgEComSyncInSensitivity = 0;
#[doc = "< The trigger will be activated by a falling edge."]
pub const _SbgEComSyncInSensitivity_SBG_ECOM_SYNC_IN_FALLING_EDGE: _SbgEComSyncInSensitivity = 1;
#[doc = "< The trigger will be activated by a rising edge."]
pub const _SbgEComSyncInSensitivity_SBG_ECOM_SYNC_IN_RISING_EDGE: _SbgEComSyncInSensitivity = 2;
#[doc = "< The trigger is activated by a level change (rising or falling edge)."]
pub const _SbgEComSyncInSensitivity_SBG_ECOM_SYNC_IN_BOTH_EDGES: _SbgEComSyncInSensitivity = 3;
#[doc = " List of available sensitivities for sync in signals."]
pub type _SbgEComSyncInSensitivity = ::core::ffi::c_uint;
#[doc = " List of available sensitivities for sync in signals."]
pub use self::_SbgEComSyncInSensitivity as SbgEComSyncInSensitivity;
#[doc = "< Synchronization output A"]
pub const _SbgEComSyncOutId_SBG_ECOM_SYNC_OUT_A: _SbgEComSyncOutId = 0;
#[doc = "< Synchronization output B"]
pub const _SbgEComSyncOutId_SBG_ECOM_SYNC_OUT_B: _SbgEComSyncOutId = 1;
#[doc = " List of sync out signals available."]
pub type _SbgEComSyncOutId = ::core::ffi::c_uint;
#[doc = " List of sync out signals available."]
pub use self::_SbgEComSyncOutId as SbgEComSyncOutId;
#[doc = "< Output is disabled."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DISABLED: _SbgEComSyncOutFunction = 0;
#[doc = "< Output is generated at 200Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_MAIN_LOOP: _SbgEComSyncOutFunction = 1;
#[doc = "< Output is generated at 100Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_2: _SbgEComSyncOutFunction = 2;
#[doc = "< Output is generated at 50Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_4: _SbgEComSyncOutFunction = 4;
#[doc = "< Output is generated at 25Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_8: _SbgEComSyncOutFunction = 8;
#[doc = "< Output is generated at 20Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_10: _SbgEComSyncOutFunction = 10;
#[doc = "< Output is generated at 10Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_20: _SbgEComSyncOutFunction = 20;
#[doc = "< Output is generated at 5Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_40: _SbgEComSyncOutFunction = 40;
#[doc = "< Output is generated at 1Hz."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIV_200: _SbgEComSyncOutFunction = 200;
#[doc = "< Pulse Per Second. Same mode as above."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_PPS: _SbgEComSyncOutFunction = 10000;
#[doc = "< Output is generated on a Sync In A event."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_EVENT_IN_A: _SbgEComSyncOutFunction =
    10003;
#[doc = "< Output is generated on a Sync In B event."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_EVENT_IN_B: _SbgEComSyncOutFunction =
    10004;
#[doc = "< Output is generated on a Sync In C event."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_EVENT_IN_C: _SbgEComSyncOutFunction =
    10005;
#[doc = "< Output is generated on a Sync In D event."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_EVENT_IN_D: _SbgEComSyncOutFunction =
    10006;
#[doc = "< The internal GNSS PPS signal is directly routed to the Sync Out.\nThis mode is only valid for ELLIPSE-N with hardware revisions above 1.2.1.0.\nPolarity and duration parameters are ignored with this specific mode."]
pub const _SbgEComSyncOutFunction_SBG_ECOM_SYNC_OUT_MODE_DIRECT_PPS: _SbgEComSyncOutFunction =
    10100;
#[doc = " Logic and synchronization output types"]
pub type _SbgEComSyncOutFunction = ::core::ffi::c_uint;
#[doc = " Logic and synchronization output types"]
pub use self::_SbgEComSyncOutFunction as SbgEComSyncOutFunction;
#[doc = "< The output pin will generate a falling edge"]
pub const _SbgEComSyncOutPolarity_SBG_ECOM_SYNC_OUT_FALLING_EDGE: _SbgEComSyncOutPolarity = 0;
#[doc = "< The output pin will generate a rising edge"]
pub const _SbgEComSyncOutPolarity_SBG_ECOM_SYNC_OUT_RISING_EDGE: _SbgEComSyncOutPolarity = 1;
#[doc = "< The pulse is a level change"]
pub const _SbgEComSyncOutPolarity_SBG_ECOM_SYNC_OUT_TOGGLE: _SbgEComSyncOutPolarity = 2;
#[doc = " Logic output polarity"]
pub type _SbgEComSyncOutPolarity = ::core::ffi::c_uint;
#[doc = " Logic output polarity"]
pub use self::_SbgEComSyncOutPolarity as SbgEComSyncOutPolarity;
#[doc = " Helper structure for sync in configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComSyncInConf {
    #[doc = "< Sensitivity of the sync in."]
    pub sensitivity: SbgEComSyncInSensitivity,
    #[doc = "< Delay to take into account for the sync in. (in us)"]
    pub delay: i32,
}
#[test]
fn bindgen_test_layout__SbgEComSyncInConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComSyncInConf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComSyncInConf>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgEComSyncInConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComSyncInConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComSyncInConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensitivity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSyncInConf),
            "::",
            stringify!(sensitivity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSyncInConf),
            "::",
            stringify!(delay)
        )
    );
}
#[doc = " Helper structure for sync in configuration."]
pub type SbgEComSyncInConf = _SbgEComSyncInConf;
#[doc = " Helper structure for sync out configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComSyncOutConf {
    #[doc = "< Output function of the sync out pin"]
    pub outputFunction: SbgEComSyncOutFunction,
    #[doc = "< Polarity of the sync out."]
    pub polarity: SbgEComSyncOutPolarity,
    #[doc = "< Pulse width for the sync out (in ns)."]
    pub duration: u32,
}
#[test]
fn bindgen_test_layout__SbgEComSyncOutConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComSyncOutConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComSyncOutConf>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgEComSyncOutConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComSyncOutConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComSyncOutConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSyncOutConf),
            "::",
            stringify!(outputFunction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).polarity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSyncOutConf),
            "::",
            stringify!(polarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSyncOutConf),
            "::",
            stringify!(duration)
        )
    );
}
#[doc = " Helper structure for sync out configuration."]
pub type SbgEComSyncOutConf = _SbgEComSyncOutConf;
extern "C" {
    #[doc = "\tRetrieve the configuration of a Sync In.\n\n\t\\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n\t\\param[in]\tsyncInId\t\t\t\t\tThe id of the sync whose configuration is to be retrieved.\n\t\\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComSyncInConf to contain the current configuration of the sync in.\n\t\\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSyncInGetConf(
        pHandle: *mut SbgEComHandle,
        syncInId: SbgEComSyncInId,
        pConf: *mut SbgEComSyncInConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tSet the configuration of a Sync In.\n\n\t\\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n\t\\param[in]\tsyncInId\t\t\t\t\tThe id of the sync whose configuration is to be set.\n\t\\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComSyncInConf that contains the new configuration for the sync in.\n\t\\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSyncInSetConf(
        pHandle: *mut SbgEComHandle,
        syncInId: SbgEComSyncInId,
        pConf: *const SbgEComSyncInConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tRetrieve the configuration of a Sync Out.\n\n\t\\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n\t\\param[in]\tsyncOutId\t\t\t\t\tThe id of the sync whose configuration is to be retrieved.\n\t\\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComSyncOutConf to contain the current configuration of the sync out.\n\t\\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSyncOutGetConf(
        pHandle: *mut SbgEComHandle,
        syncOutId: SbgEComSyncOutId,
        pConf: *mut SbgEComSyncOutConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = "\tSet the configuration of a Sync Out.\n\n\t\\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n\t\\param[in]\tsyncOutId\t\t\t\t\tThe id of the sync whose configuration is to be set.\n\t\\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComSyncOutConf that contains the new configuration for the sync Out.\n\t\\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSyncOutSetConf(
        pHandle: *mut SbgEComHandle,
        syncOutId: SbgEComSyncOutId,
        pConf: *const SbgEComSyncOutConf,
    ) -> SbgErrorCode;
}
#[doc = "< GNSS module disabled"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_DISABLED: _SbgEComGnssType = 0;
#[doc = "< External GNSS module (all features are unknown)"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_EXTERNAL: _SbgEComGnssType = 1;
#[doc = "< Ublox MAX-M8 module"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_UBX_MAX_M8: _SbgEComGnssType = 2;
#[doc = "< Novatel OEM615 device"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_NOV_OEM615: _SbgEComGnssType = 3;
#[doc = "< Two Novatel OEM615 devices for dual antenna"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_NOV_OEM615_DUAL: _SbgEComGnssType = 4;
#[doc = "< Novatel OEM617D device"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_NOV_OEM617D: _SbgEComGnssType = 5;
#[doc = "< Septentrio Asterx m4"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_SEP_AX4: _SbgEComGnssType = 6;
#[doc = "< Septentrio Asterx m2a"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_SEP_AXM2A: _SbgEComGnssType = 7;
#[doc = "< Ublox ZED-F9P module"]
pub const _SbgEComGnssType_SBG_ECOM_GNSS_TYPE_UBX_F9P: _SbgEComGnssType = 8;
#[doc = " This enum defines the different types of internal GNSS receiver that can provide specific features.\n Note External type is considered as not handled by the feature system"]
pub type _SbgEComGnssType = ::core::ffi::c_uint;
#[doc = " This enum defines the different types of internal GNSS receiver that can provide specific features.\n Note External type is considered as not handled by the feature system"]
pub use self::_SbgEComGnssType as SbgEComGnssType;
#[doc = " This structure contains all the information provided by the SBG_ECOM_CMD_GET_FEATURES command"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComFeatures {
    #[doc = "< The different measurement capabilities of this unit"]
    pub sensorFeaturesMask: u32,
    #[doc = "< The type of GNSS receiver used (brand and model)"]
    pub gnssType: SbgEComGnssType,
    #[doc = "< The actual GNSS update rate"]
    pub gnssUpdateRate: u8,
    #[doc = "< GNSS receiver signals tracking"]
    pub gnssSignalsMask: u32,
    #[doc = "< GNSS receiver computation and output features"]
    pub gnssFeaturesMask: u32,
    #[doc = "< String containing the GNSS receiver product code (\"\\0\" if unknown)"]
    pub gnssProductCode: [::core::ffi::c_char; 32usize],
    #[doc = "< String containing the GNSS receiver serial number (\"\\0\" if unknown)"]
    pub gnssSerialNumber: [::core::ffi::c_char; 32usize],
    #[doc = "< String containing the GNSS receiver firmware version (\"\\0\" if unknown)"]
    pub gnssFirmwareVersion: [::core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout__SbgEComFeatures() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComFeatures> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComFeatures>(),
        116usize,
        concat!("Size of: ", stringify!(_SbgEComFeatures))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComFeatures))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensorFeaturesMask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(sensorFeaturesMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssUpdateRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssUpdateRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssSignalsMask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssSignalsMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssFeaturesMask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssFeaturesMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssProductCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssProductCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssSerialNumber) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gnssFirmwareVersion) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComFeatures),
            "::",
            stringify!(gnssFirmwareVersion)
        )
    );
}
#[doc = " This structure contains all the information provided by the SBG_ECOM_CMD_GET_FEATURES command"]
pub type SbgEComFeatures = _SbgEComFeatures;
extern "C" {
    #[doc = " Retrieve the device and embedded GPS receiver features.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpFeatures\t\t\t\t\tA pointer to a structure to hold features.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGetFeatures(
        pHandle: *mut SbgEComHandle,
        pFeatures: *mut SbgEComFeatures,
    ) -> SbgErrorCode;
}
#[doc = "< Default internal GNSS for ELLIPSE-N and ELLIPSE-D"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_INTERNAL: _SbgEComGnssModelsStdIds = 101;
#[doc = "< ELLIPSE-E to accept an external GNSS using NMEA protocol"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_NMEA: _SbgEComGnssModelsStdIds = 102;
#[doc = "< Only for ELLIPSE-N hardware 1 & 2 to select GPS+BEIDOU instead of the default GPS+GLONASS"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_UBLOX_GPS_BEIDOU: _SbgEComGnssModelsStdIds =
    103;
#[doc = "< ELLIPSE-E to accept an external Ublox GNSS (receive only - passive)"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_UBLOX_EXTERNAL: _SbgEComGnssModelsStdIds =
    104;
#[doc = "< Reserved, do not use"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_RESERVED_01: _SbgEComGnssModelsStdIds = 105;
#[doc = "< ELLIPSE-E to accept an external Novatel GNSS (receive only - passive)"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_NOVATEL_EXTERNAL: _SbgEComGnssModelsStdIds =
    106;
#[doc = "< Reserved, do not use"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_RESERVED_02: _SbgEComGnssModelsStdIds = 107;
#[doc = "< Reserved, do not use"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_RESERVED_03: _SbgEComGnssModelsStdIds = 108;
#[doc = "< ELLIPSE-E to accept an external Septentrio GNSS(receive only - passive)"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_SEPTENTRIO_EXTERNAL:
    _SbgEComGnssModelsStdIds = 109;
#[doc = "< Reserved, do not use"]
pub const _SbgEComGnssModelsStdIds_SBG_ECOM_GNSS_MODEL_RESERVED_04: _SbgEComGnssModelsStdIds = 110;
#[doc = " This enum defines the different GNSS model IDs available in standard"]
pub type _SbgEComGnssModelsStdIds = ::core::ffi::c_uint;
#[doc = " This enum defines the different GNSS model IDs available in standard"]
pub use self::_SbgEComGnssModelsStdIds as SbgEComGnssModelsStdIds;
#[doc = "< The GNSS will be used in single antenna mode only and the secondary lever arm is not used."]
pub const _SbgEComGnssInstallationMode_SBG_ECOM_GNSS_INSTALLATION_MODE_SINGLE:
    _SbgEComGnssInstallationMode = 1;
#[doc = "< [Reserved] The GNSS dual antenna information will be used but the secondary lever arm is not known."]
pub const _SbgEComGnssInstallationMode_SBG_ECOM_GNSS_INSTALLATION_MODE_DUAL_AUTO:
    _SbgEComGnssInstallationMode = 2;
#[doc = "< The GNSS dual antenna information will be used and we have a rough guess for the secondary lever arm."]
pub const _SbgEComGnssInstallationMode_SBG_ECOM_GNSS_INSTALLATION_MODE_DUAL_ROUGH:
    _SbgEComGnssInstallationMode = 3;
#[doc = "< The GNSS dual antenna information will be used and the secondary lever arm is accurately entered and doesn't need online re-estimation."]
pub const _SbgEComGnssInstallationMode_SBG_ECOM_GNSS_INSTALLATION_MODE_DUAL_PRECISE:
    _SbgEComGnssInstallationMode = 4;
#[doc = " GNSS mechanical installation modes for the dual antenna mode."]
pub type _SbgEComGnssInstallationMode = ::core::ffi::c_uint;
#[doc = " GNSS mechanical installation modes for the dual antenna mode."]
pub use self::_SbgEComGnssInstallationMode as SbgEComGnssInstallationMode;
#[doc = " GNSS mechanical installation parameters to be used with command SBG_ECOM_CMD_GNSS_#_INSTALLATION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComGnssInstallation {
    #[doc = "< GNSS primary antenna lever arm in IMU X, Y, Z axis in meters"]
    pub leverArmPrimary: [f32; 3usize],
    #[doc = "< If set to true, the primary lever arm has been accurately entered and doesn't need online re-estimation."]
    pub leverArmPrimaryPrecise: bool,
    #[doc = "< GNSS secondary antenna lever arm in IMU X, Y, Z axis in meters"]
    pub leverArmSecondary: [f32; 3usize],
    #[doc = "< Define the secondary antenna (dual antenna) operating mode."]
    pub leverArmSecondaryMode: SbgEComGnssInstallationMode,
}
#[test]
fn bindgen_test_layout__SbgEComGnssInstallation() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComGnssInstallation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComGnssInstallation>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgEComGnssInstallation))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComGnssInstallation>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComGnssInstallation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leverArmPrimary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssInstallation),
            "::",
            stringify!(leverArmPrimary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leverArmPrimaryPrecise) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssInstallation),
            "::",
            stringify!(leverArmPrimaryPrecise)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leverArmSecondary) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssInstallation),
            "::",
            stringify!(leverArmSecondary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leverArmSecondaryMode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssInstallation),
            "::",
            stringify!(leverArmSecondaryMode)
        )
    );
}
#[doc = " GNSS mechanical installation parameters to be used with command SBG_ECOM_CMD_GNSS_#_INSTALLATION"]
pub type SbgEComGnssInstallation = _SbgEComGnssInstallation;
#[doc = " Holds all necessary information for GNSS module data rejection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComGnssRejectionConf {
    #[doc = "< Rejection mode for position."]
    pub position: SbgEComRejectionMode,
    #[doc = "< Rejection mode for velocity."]
    pub velocity: SbgEComRejectionMode,
    #[doc = "< Rejection mode for true heading."]
    pub hdt: SbgEComRejectionMode,
}
#[test]
fn bindgen_test_layout__SbgEComGnssRejectionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComGnssRejectionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComGnssRejectionConf>(),
        12usize,
        concat!("Size of: ", stringify!(_SbgEComGnssRejectionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComGnssRejectionConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComGnssRejectionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssRejectionConf),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssRejectionConf),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComGnssRejectionConf),
            "::",
            stringify!(hdt)
        )
    );
}
#[doc = " Holds all necessary information for GNSS module data rejection."]
pub type SbgEComGnssRejectionConf = _SbgEComGnssRejectionConf;
extern "C" {
    #[doc = " Set GNSS error model id.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmodelId\t\t\t\t\t\tModel ID to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1SetModelId(
        pHandle: *mut SbgEComHandle,
        modelId: SbgEComGnssModelsStdIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve GNSS error model id.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpModelId\t\t\t\t\tRetrieved model id.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1GetModelId(
        pHandle: *mut SbgEComHandle,
        pModelId: *mut SbgEComGnssModelsStdIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the mechanical installation parameters for the GNSS 1 module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpGnssInstallation\t\t\tUsed to store the retrieved the GNSS installation parameters.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1InstallationGet(
        pHandle: *mut SbgEComHandle,
        pGnssInstallation: *mut SbgEComGnssInstallation,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the mechanical installation parameters for the GNSS 1 module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpGnssInstallation\t\t\t\tThe GNSS installation parameters to set.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1InstallationSet(
        pHandle: *mut SbgEComHandle,
        pGnssInstallation: *const SbgEComGnssInstallation,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the rejection configuration of the gnss module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tPointer to a SbgEComGnssRejectionConf struct to hold rejection configuration of the gnss module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1GetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *mut SbgEComGnssRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the rejection configuration of the gnss module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tPointer to a SbgEComGnssRejectionConf struct holding rejection configuration for the gnss module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGnss1SetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *const SbgEComGnssRejectionConf,
    ) -> SbgErrorCode;
}
#[doc = " Helper structure to retrieve device info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComDeviceInfo {
    #[doc = "< Human readable Product Code."]
    pub productCode: [u8; 32usize],
    #[doc = "< Device serial number"]
    pub serialNumber: u32,
    #[doc = "< Calibration data revision"]
    pub calibationRev: u32,
    #[doc = "< Device Calibration Year"]
    pub calibrationYear: u16,
    #[doc = "< Device Calibration Month"]
    pub calibrationMonth: u8,
    #[doc = "< Device Calibration Day"]
    pub calibrationDay: u8,
    #[doc = "< Device hardware revision"]
    pub hardwareRev: u32,
    #[doc = "< Firmware revision"]
    pub firmwareRev: u32,
}
#[test]
fn bindgen_test_layout__SbgEComDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComDeviceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComDeviceInfo>(),
        52usize,
        concat!("Size of: ", stringify!(_SbgEComDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).productCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(productCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serialNumber) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibationRev) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(calibationRev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibrationYear) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(calibrationYear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibrationMonth) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(calibrationMonth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calibrationDay) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(calibrationDay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardwareRev) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(hardwareRev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmwareRev) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComDeviceInfo),
            "::",
            stringify!(firmwareRev)
        )
    );
}
#[doc = " Helper structure to retrieve device info."]
pub type SbgEComDeviceInfo = _SbgEComDeviceInfo;
extern "C" {
    #[doc = " Retrieve the device information.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpInfo\t\t\t\t\t\tA pointer to a structure to hold device information.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdGetInfo(
        pHandle: *mut SbgEComHandle,
        pInfo: *mut SbgEComDeviceInfo,
    ) -> SbgErrorCode;
}
#[doc = "< Main communication interface. Full duplex."]
pub const _SbgEComPortId_SBG_ECOM_IF_COM_A: _SbgEComPortId = 0;
#[doc = "< Auxiliary input interface for RTCM."]
pub const _SbgEComPortId_SBG_ECOM_IF_COM_B: _SbgEComPortId = 1;
#[doc = "< Auxiliary communication interface. Full duplex."]
pub const _SbgEComPortId_SBG_ECOM_IF_COM_C: _SbgEComPortId = 2;
#[doc = "< Auxiliary input interface."]
pub const _SbgEComPortId_SBG_ECOM_IF_COM_D: _SbgEComPortId = 3;
#[doc = "< Auxiliary output interface."]
pub const _SbgEComPortId_SBG_ECOM_IF_COM_E: _SbgEComPortId = 4;
#[doc = "< Ethernet interface 0."]
pub const _SbgEComPortId_SBG_ECOM_IF_ETH_0: _SbgEComPortId = 10;
#[doc = "< Ethernet interface 1."]
pub const _SbgEComPortId_SBG_ECOM_IF_ETH_1: _SbgEComPortId = 11;
#[doc = "< Ethernet interface 2."]
pub const _SbgEComPortId_SBG_ECOM_IF_ETH_2: _SbgEComPortId = 12;
#[doc = "< Ethernet interface 3."]
pub const _SbgEComPortId_SBG_ECOM_IF_ETH_3: _SbgEComPortId = 13;
#[doc = "< Ethernet interface 4."]
pub const _SbgEComPortId_SBG_ECOM_IF_ETH_4: _SbgEComPortId = 14;
#[doc = "< Data logger interface."]
pub const _SbgEComPortId_SBG_ECOM_IF_DATA_LOGGER: _SbgEComPortId = 20;
#[doc = " List of serial interfaces available."]
pub type _SbgEComPortId = ::core::ffi::c_uint;
#[doc = " List of serial interfaces available."]
pub use self::_SbgEComPortId as SbgEComPortId;
#[doc = "< This interface is turned OFF."]
pub const _SbgEComPortMode_SBG_ECOM_UART_MODE_OFF: _SbgEComPortMode = 0;
#[doc = "< This interface is using RS-232 communications."]
pub const _SbgEComPortMode_SBG_ECOM_UART_MODE_232: _SbgEComPortMode = 1;
#[doc = "< This interface is using RS-422 communications."]
pub const _SbgEComPortMode_SBG_ECOM_UART_MODE_422: _SbgEComPortMode = 2;
#[doc = " List of serial modes available."]
pub type _SbgEComPortMode = ::core::ffi::c_uint;
#[doc = " List of serial modes available."]
pub use self::_SbgEComPortMode as SbgEComPortMode;
#[doc = " Helper structure to configure a serial interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComInterfaceConf {
    #[doc = "< The baud rate of the interface."]
    pub baudRate: u32,
    #[doc = "< The mode of the interface."]
    pub mode: SbgEComPortMode,
}
#[test]
fn bindgen_test_layout__SbgEComInterfaceConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComInterfaceConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComInterfaceConf>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgEComInterfaceConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComInterfaceConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComInterfaceConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baudRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInterfaceConf),
            "::",
            stringify!(baudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInterfaceConf),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = " Helper structure to configure a serial interface"]
pub type SbgEComInterfaceConf = _SbgEComInterfaceConf;
#[doc = "< The CAN interface is disabled."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_DISABLED: _SbgEComCanBitRate = 0;
#[doc = "< 10Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_10: _SbgEComCanBitRate = 10;
#[doc = "< 20Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_20: _SbgEComCanBitRate = 20;
#[doc = "< 25Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_25: _SbgEComCanBitRate = 25;
#[doc = "< 50Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_50: _SbgEComCanBitRate = 50;
#[doc = "< 100Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_100: _SbgEComCanBitRate = 100;
#[doc = "< 125Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_125: _SbgEComCanBitRate = 125;
#[doc = "< 250Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_250: _SbgEComCanBitRate = 250;
#[doc = "< 500Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_500: _SbgEComCanBitRate = 500;
#[doc = "< 750Kb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_750: _SbgEComCanBitRate = 750;
#[doc = "< 1Mb/s."]
pub const _SbgEComCanBitRate_SBG_ECOM_CAN_BITRATE_1000: _SbgEComCanBitRate = 1000;
#[doc = " Enum containing the list of all available bit rates (in KB/s)."]
pub type _SbgEComCanBitRate = ::core::ffi::c_uint;
#[doc = " Enum containing the list of all available bit rates (in KB/s)."]
pub use self::_SbgEComCanBitRate as SbgEComCanBitRate;
#[doc = "< CAN Mode undefined."]
pub const _SbgEComCanMode_SBG_ECOM_CAN_MODE_UNDEFINED: _SbgEComCanMode = 0;
#[doc = "< Only listening on the CAN bus and doesn't sent anything (even RX ACK bit)."]
pub const _SbgEComCanMode_SBG_ECOM_CAN_MODE_SPY: _SbgEComCanMode = 1;
#[doc = "< The device is allowed to both send and receive over the CAN bus."]
pub const _SbgEComCanMode_SBG_ECOM_CAN_MODE_NORMAL: _SbgEComCanMode = 2;
pub const _SbgEComCanMode_SBG_ECOM_CAN_NR_MODE: _SbgEComCanMode = 3;
#[doc = " Enum containing the list of different CAN modes"]
pub type _SbgEComCanMode = ::core::ffi::c_uint;
#[doc = " Enum containing the list of different CAN modes"]
pub use self::_SbgEComCanMode as SbgEComCanMode;
extern "C" {
    #[doc = " Retrieve the configuration of one of the interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tinterfaceId\t\t\t\t\tThe interface from which the configuration is to be retrieved.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComInterfaceConf struct to hold configuration of the interface.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdInterfaceGetUartConf(
        pHandle: *mut SbgEComHandle,
        interfaceId: SbgEComPortId,
        pConf: *mut SbgEComInterfaceConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the configuration of one of the interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tinterfaceId\t\t\t\t\tThe interface from which the configuration is to be retrieved.\n \\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComInterfaceConf struct that holds the new configuration for the interface.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdInterfaceSetUartConf(
        pHandle: *mut SbgEComHandle,
        interfaceId: SbgEComPortId,
        pConf: *const SbgEComInterfaceConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the configuration of the CAN interface.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpBitrate\t\t\t\t\tThe bitrate of the CAN interface.\n \\param[out]\tpMode\t                    Mode of the CAN interface.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdInterfaceGetCanConf(
        pHandle: *mut SbgEComHandle,
        pBitrate: *mut SbgEComCanBitRate,
        pMode: *mut SbgEComCanMode,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the configuration of the CAN interface.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tbitRate\t\t\t\t\t\tThe bitrate of the CAN interface.\n \\param[in]\tmode\t                    Mode of the CAN interface.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdInterfaceSetCanConf(
        pHandle: *mut SbgEComHandle,
        bitRate: SbgEComCanBitRate,
        mode: SbgEComCanMode,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Upload and apply a new license to a device.\n\n The device will reboot automatically to use the new license.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpBuffer\t\t\t\t\t\tRead only buffer containing the license.\n \\param[in]\tsize\t\t\t\t\t\tSize of the buffer.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdLicenseApply(
        pHandle: *mut SbgEComHandle,
        pBuffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> SbgErrorCode;
}
#[doc = "< Tell the device that the magnetic calibration will be performed with limited motions.\nThis calibration mode is only designed to be used when roll and pitch motions are less than ± 5°.\nTo work correctly, the device should be rotated through at least a full circle."]
pub const _SbgEComMagCalibMode_SBG_ECOM_MAG_CALIB_MODE_2D: _SbgEComMagCalibMode = 1;
#[doc = "< Tell the device to start a full 3D magnetic calibration procedure.\nThe 3D magnetic calibration offers the best accuracy but needs at least motion of ± 30° on the roll and pitch angles."]
pub const _SbgEComMagCalibMode_SBG_ECOM_MAG_CALIB_MODE_3D: _SbgEComMagCalibMode = 2;
#[doc = "\tDefine if the onboard magnetic calibration should acquiere points for a 3D or 2D calibration."]
pub type _SbgEComMagCalibMode = ::core::ffi::c_uint;
#[doc = "\tDefine if the onboard magnetic calibration should acquiere points for a 3D or 2D calibration."]
pub use self::_SbgEComMagCalibMode as SbgEComMagCalibMode;
#[doc = "< Tell the device that low dynamics will be observed during the magnetic calibration process."]
pub const _SbgEComMagCalibBandwidth_SBG_ECOM_MAG_CALIB_LOW_BW: _SbgEComMagCalibBandwidth = 0;
#[doc = "< Tell the device that normal dynamics will be observed during the magnetic calibration process."]
pub const _SbgEComMagCalibBandwidth_SBG_ECOM_MAG_CALIB_MEDIUM_BW: _SbgEComMagCalibBandwidth = 1;
#[doc = "< Tell the device that high dynamics will be observed during the magnetic calibration process."]
pub const _SbgEComMagCalibBandwidth_SBG_ECOM_MAG_CALIB_HIGH_BW: _SbgEComMagCalibBandwidth = 2;
#[doc = "\tUsed to select the expected dynamics during the magnetic calibration."]
pub type _SbgEComMagCalibBandwidth = ::core::ffi::c_uint;
#[doc = "\tUsed to select the expected dynamics during the magnetic calibration."]
pub use self::_SbgEComMagCalibBandwidth as SbgEComMagCalibBandwidth;
#[doc = "< All acquired points fit very well on a unit sphere after the calibration."]
pub const _SbgEComMagCalibQuality_SBG_ECOM_MAG_CALIB_QUAL_OPTIMAL: _SbgEComMagCalibQuality = 0;
#[doc = "< Small deviations of the magnetic field norm have been detected. The magnetic calibration should although provide accurate heading."]
pub const _SbgEComMagCalibQuality_SBG_ECOM_MAG_CALIB_QUAL_GOOD: _SbgEComMagCalibQuality = 1;
#[doc = "< Large deviations of the magnetic field norm have been detected. It may come from external magnetic distortions during the calibration."]
pub const _SbgEComMagCalibQuality_SBG_ECOM_MAG_CALIB_QUAL_POOR: _SbgEComMagCalibQuality = 2;
#[doc = "< No valid magnetic calibration has been computed. It could comes from too much magnetic disturbances, insufficient or invalid motions."]
pub const _SbgEComMagCalibQuality_SBG_ECOM_MAG_CALIB_QUAL_INVALID: _SbgEComMagCalibQuality = 3;
#[doc = "\tGeneral quality indicator of an onboard magnetic calibration."]
pub type _SbgEComMagCalibQuality = ::core::ffi::c_uint;
#[doc = "\tGeneral quality indicator of an onboard magnetic calibration."]
pub use self::_SbgEComMagCalibQuality as SbgEComMagCalibQuality;
#[doc = "< Reported quality indicator can be trusted as enough remarkable magnetic field points have been acquired."]
pub const _SbgEComMagCalibConfidence_SBG_ECOM_MAG_CALIB_TRUST_HIGH: _SbgEComMagCalibConfidence = 0;
#[doc = "< Few remarkable magnetic field points have been used to compute the magnetic calibration leading to a medium confidence in reported quality indicators."]
pub const _SbgEComMagCalibConfidence_SBG_ECOM_MAG_CALIB_TRUST_MEDIUM: _SbgEComMagCalibConfidence =
    1;
#[doc = "< Even if the quality indicator could report an excellent calibration,\nThe data set used to compute the magnetic calibration was not meaningful enough to compute meaningful quality indicators.\nThis calibration should be used carefully."]
pub const _SbgEComMagCalibConfidence_SBG_ECOM_MAG_CALIB_TRUST_LOW: _SbgEComMagCalibConfidence = 2;
#[doc = "\tConfidence indicator on results of an onbard magnetic calibration."]
pub type _SbgEComMagCalibConfidence = ::core::ffi::c_uint;
#[doc = "\tConfidence indicator on results of an onbard magnetic calibration."]
pub use self::_SbgEComMagCalibConfidence as SbgEComMagCalibConfidence;
#[doc = "< Should be used in most applications"]
pub const _SbgEComMagModelsStdIds_SBG_ECOM_MAG_MODEL_NORMAL: _SbgEComMagModelsStdIds = 201;
#[doc = "< Should be used in disturbed magnetic environment"]
pub const _SbgEComMagModelsStdIds_SBG_ECOM_MAG_MODEL_NOISY_MAG_TOLERANT: _SbgEComMagModelsStdIds =
    202;
#[doc = " This enum defines the different magnetometer model IDs available in standard"]
pub type _SbgEComMagModelsStdIds = ::core::ffi::c_uint;
#[doc = " This enum defines the different magnetometer model IDs available in standard"]
pub use self::_SbgEComMagModelsStdIds as SbgEComMagModelsStdId;
#[doc = " Holds all necessary information for Magnetometer module data rejection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComMagRejectionConf {
    #[doc = "< Rejection mode for magnetic field."]
    pub magneticField: SbgEComRejectionMode,
}
#[test]
fn bindgen_test_layout__SbgEComMagRejectionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComMagRejectionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComMagRejectionConf>(),
        4usize,
        concat!("Size of: ", stringify!(_SbgEComMagRejectionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComMagRejectionConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComMagRejectionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magneticField) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagRejectionConf),
            "::",
            stringify!(magneticField)
        )
    );
}
#[doc = " Holds all necessary information for Magnetometer module data rejection."]
pub type SbgEComMagRejectionConf = _SbgEComMagRejectionConf;
#[doc = " Helper structure to retrieve onboard magnetic calibration results."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComMagCalibResults {
    #[doc = "< General magnetic calibration quality indicator."]
    pub quality: SbgEComMagCalibQuality,
    #[doc = "< Confidence indicator that should be read to interpret the quality indicator."]
    pub confidence: SbgEComMagCalibConfidence,
    #[doc = "< Set of bit masks used to report advanced information on the magnetic calibration status."]
    pub advancedStatus: u16,
    #[doc = "< Mean magnetic field norm error observed before calibration."]
    pub beforeMeanError: f32,
    #[doc = "< Standard deviation of the magnetic field norm error observed before calibration."]
    pub beforeStdError: f32,
    #[doc = "< Maximum magnetic field norm error observed before calibration."]
    pub beforeMaxError: f32,
    #[doc = "< Mean magnetic field norm error observed after calibration."]
    pub afterMeanError: f32,
    #[doc = "< Standard deviation of the magnetic field norm error observed after calibration."]
    pub afterStdError: f32,
    #[doc = "< Maximum magnetic field norm error observed after calibration."]
    pub afterMaxError: f32,
    #[doc = "< Mean expected heading accuracy in radians."]
    pub meanAccuracy: f32,
    #[doc = "< Standard deviation of the expected heading accuracy in radians."]
    pub stdAccuracy: f32,
    #[doc = "< Maximum expected heading accuracy in radians."]
    pub maxAccuracy: f32,
    #[doc = "< Number of magnetic field points stored internally and used to compute the magnetic calibration."]
    pub numPoints: u16,
    #[doc = "< Maximum number of magnetic field points that can be stored internally."]
    pub maxNumPoints: u16,
    #[doc = "< Computed Hard Iron correction vector offset."]
    pub offset: [f32; 3usize],
    #[doc = "< Computed Hard & Soft Iron correction matrix."]
    pub matrix: [f32; 9usize],
}
#[test]
fn bindgen_test_layout__SbgEComMagCalibResults() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComMagCalibResults> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComMagCalibResults>(),
        100usize,
        concat!("Size of: ", stringify!(_SbgEComMagCalibResults))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComMagCalibResults>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComMagCalibResults))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).confidence) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).advancedStatus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(advancedStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beforeMeanError) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(beforeMeanError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beforeStdError) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(beforeStdError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beforeMaxError) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(beforeMaxError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).afterMeanError) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(afterMeanError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).afterStdError) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(afterStdError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).afterMaxError) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(afterMaxError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).meanAccuracy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(meanAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stdAccuracy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(stdAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxAccuracy) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(maxAccuracy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numPoints) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(numPoints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxNumPoints) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(maxNumPoints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComMagCalibResults),
            "::",
            stringify!(matrix)
        )
    );
}
#[doc = " Helper structure to retrieve onboard magnetic calibration results."]
pub type SbgEComMagCalibResults = _SbgEComMagCalibResults;
extern "C" {
    #[doc = " Set magnetometer error model id.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle\n \\param[in]\tmodelId\t\t\t\t\t\tMagnetometer model id to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully"]
    pub fn sbgEComCmdMagSetModelId(
        pHandle: *mut SbgEComHandle,
        modelId: SbgEComMagModelsStdId,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve magnetometer error model id\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle\n \\param[out]\tpModelId\t\t\t\t\tRetrieved magnetometer model id\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully"]
    pub fn sbgEComCmdMagGetModelId(
        pHandle: *mut SbgEComHandle,
        pModelId: *mut SbgEComMagModelsStdId,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the rejection configuration of the magnetometer module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tPointer to a SbgEComMagRejectionConf struct to hold rejection configuration of the magnetometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdMagGetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *mut SbgEComMagRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the rejection configuration of the magnetometer module.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpRejectConf\t\t\t\t\tPointer to a SbgEComMagRejectionConf struct holding rejection configuration for the magnetometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdMagSetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *const SbgEComMagRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Send a command that set the magnetometers calibration parameters.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpOffset\t\t\t\t\t\tMagnetometers calibration offset vector.\n \\param[in]\tpMatrix\t\t\t\t\t\tMagnetometers calibration 3x3 matrix.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdMagSetCalibData(
        pHandle: *mut SbgEComHandle,
        pOffset: *const f32,
        pMatrix: *const f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Start the magnetic calibration process.\n\n As soon as this command is sent, the device will start logging magnetic field data internally.\n This set of data will be used later by the magnetic calibration algorithms to map the surrounding magnetic field.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmode\t\t\t\t\t\tDefine which magnetic calibration type to perform. It could be 3D or 2D.\n \\param[in]\tbandwidth\t\t\t\t\tTell the device that we should have low, medium or high dynamics during the magnetic calibration process.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdMagStartCalib(
        pHandle: *mut SbgEComHandle,
        mode: SbgEComMagCalibMode,
        bandwidth: SbgEComMagCalibBandwidth,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " This command computes a magnetic calibration solution based on the magnetic field logged since the last call to the command SBG_ECOM_CMD_START_MAG_CALIB (15).\n\n As soon as the computations are done, the device will answer with quality indicators, status flags and if possible a valid magnetic calibration matrix and offset.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpCalibResults\t\t\t\tPointer on a SbgEComMagCalibResults structure that can hold onboard magnetic calibration results and status.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdMagComputeCalib(
        pHandle: *mut SbgEComHandle,
        pCalibResults: *mut SbgEComMagCalibResults,
    ) -> SbgErrorCode;
}
#[doc = " Holds all necessary information for Odometer module parameter configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComOdoConf {
    #[doc = "< Odometer's gain in pulses / meter."]
    pub gain: f32,
    #[doc = "< User gain average error in %"]
    pub gainError: u8,
    #[doc = "< Whether the odometer is in reverse mode or not."]
    pub reverseMode: bool,
}
#[test]
fn bindgen_test_layout__SbgEComOdoConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComOdoConf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComOdoConf>(),
        8usize,
        concat!("Size of: ", stringify!(_SbgEComOdoConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComOdoConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComOdoConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComOdoConf),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gainError) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComOdoConf),
            "::",
            stringify!(gainError)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reverseMode) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComOdoConf),
            "::",
            stringify!(reverseMode)
        )
    );
}
#[doc = " Holds all necessary information for Odometer module parameter configuration."]
pub type SbgEComOdoConf = _SbgEComOdoConf;
#[doc = " Holds all necessary information for Odometer module data rejection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComOdoRejectionConf {
    #[doc = "< Rejection mode for velocity."]
    pub velocity: SbgEComRejectionMode,
}
#[test]
fn bindgen_test_layout__SbgEComOdoRejectionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComOdoRejectionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComOdoRejectionConf>(),
        4usize,
        concat!("Size of: ", stringify!(_SbgEComOdoRejectionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComOdoRejectionConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComOdoRejectionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).velocity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComOdoRejectionConf),
            "::",
            stringify!(velocity)
        )
    );
}
#[doc = " Holds all necessary information for Odometer module data rejection."]
pub type SbgEComOdoRejectionConf = _SbgEComOdoRejectionConf;
#[doc = "< Channel used to decode the vehicle velocity information"]
pub const _SbgEComCmdOdoCanChannel_SBG_ECOM_CMD_ODO_CAN_CH_VELOCITY: _SbgEComCmdOdoCanChannel = 0;
#[doc = "< Channel used to decode the vehicle velocity reverse info (if available)."]
pub const _SbgEComCmdOdoCanChannel_SBG_ECOM_CMD_ODO_CAN_CH_REVERSE: _SbgEComCmdOdoCanChannel = 1;
#[doc = " CAN odometer channels definition\n A channel is an inforamtion that can be decoded / used by the device."]
pub type _SbgEComCmdOdoCanChannel = ::core::ffi::c_uint;
#[doc = " CAN odometer channels definition\n A channel is an inforamtion that can be decoded / used by the device."]
pub use self::_SbgEComCmdOdoCanChannel as SbgEComCmdOdoCanChannel;
#[doc = " Holds all necessary information for CAN Odometer parameter configuration.\n This format is very similar to info contained in a DBC file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComCmdOdoCanConf {
    #[doc = "< Set of options bit masks such as CAN extended."]
    pub options: u16,
    #[doc = "< CAN message ID from which the odometer velocity will be parsed."]
    pub canId: u32,
    #[doc = "< Index of field MSB in big endian or LSB in little endian within the payload (any value from 0 to 63)."]
    pub startBit: usize,
    #[doc = "< Length in bits of the odometer velocity field (any value from 1 to 64 minus dataOffset)."]
    pub dataSize: usize,
    #[doc = "< Value to multiply the parsed field with to get physical unit^in m.s-1."]
    pub scale: f32,
    #[doc = "< Offset to add on the scaled velocity information in m.s-1 (after applying scale factor)."]
    pub offset: f32,
    #[doc = "< The minimum velocity to consider the message valid in m.s-1"]
    pub minValue: f32,
    #[doc = "< The maximum velocity to consider the message valid in m.s-1"]
    pub maxValue: f32,
}
#[test]
fn bindgen_test_layout__SbgEComCmdOdoCanConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComCmdOdoCanConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComCmdOdoCanConf>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgEComCmdOdoCanConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComCmdOdoCanConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComCmdOdoCanConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(canId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).startBit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(startBit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minValue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(minValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxValue) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComCmdOdoCanConf),
            "::",
            stringify!(maxValue)
        )
    );
}
#[doc = " Holds all necessary information for CAN Odometer parameter configuration.\n This format is very similar to info contained in a DBC file."]
pub type SbgEComCmdOdoCanConf = _SbgEComCmdOdoCanConf;
extern "C" {
    #[doc = " For quadrature and/or pulse based odometer, retrieve the configuration.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpOdometerConf\t\t\t\tPointer to a SbgEComOdoConf struct to hold configuration of the odometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoGetConf(
        pHandle: *mut SbgEComHandle,
        pOdometerConf: *mut SbgEComOdoConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " For quadrature and/or pulse base odometer, define the configuration.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpOdometerConf\t\t\t\tPointer to a SbgEComOdoConf struct holding configuration for the odometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoSetConf(
        pHandle: *mut SbgEComHandle,
        pOdometerConf: *const SbgEComOdoConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the lever arm applicable for both quadrature or CAN based odometer.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpLeverArm\t\t\t\t\tArray of three values, one for each axis.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoGetLeverArm(
        pHandle: *mut SbgEComHandle,
        pLeverArm: *mut f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the lever arm applicable for both quadrature or CAN based odometer.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpLeverArm\t\t\t\t\tArray of three values, one for each axis.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoSetLeverArm(
        pHandle: *mut SbgEComHandle,
        pLeverArm: *const f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the velocity rejection configuration for both quadrature or CAN based odometer.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpRejectConf\t\t\t\t\tPointer to a SbgEComOdoRejectionConf struct to hold rejection configuration of the odometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoGetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *mut SbgEComOdoRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the velocity rejection configuration for both quadrature or CAN based odometer.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpRejectConf\t\t\t\t\tPointer to a SbgEComOdoRejectionConf struct holding rejection configuration for the odometer module.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoSetRejection(
        pHandle: *mut SbgEComHandle,
        pRejectConf: *const SbgEComOdoRejectionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the CAN odometer configuration for a specific CAN information channel\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tcanChannel\t\t\t\t\tThe CAN channel to retreive associated DBC configuration.\n \\param[out]\tpOdoCanConf\t\t\t\t\tStruct to hold configuration of the CAN odometer.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoCanGetConf(
        pHandle: *mut SbgEComHandle,
        canChannel: SbgEComCmdOdoCanChannel,
        pOdoCanConf: *mut SbgEComCmdOdoCanConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the CAN odometer configuration for a specific CAN information channel\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tcanChannel\t\t\t\t\tThe CAN channel to define associated DBC configuration.\n \\param[in]\tpOdoCanConf\t\t\t\t\tStruct holding configuration for the CAN odometer.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOdoCanSetConf(
        pHandle: *mut SbgEComHandle,
        canChannel: SbgEComCmdOdoCanChannel,
        pOdoCanConf: *const SbgEComCmdOdoCanConf,
    ) -> SbgErrorCode;
}
#[doc = "< Main output port."]
pub const _SbgEComOutputPort_SBG_ECOM_OUTPUT_PORT_A: _SbgEComOutputPort = 0;
#[doc = "< Secondary output port only available on Ellipse-E devices"]
pub const _SbgEComOutputPort_SBG_ECOM_OUTPUT_PORT_C: _SbgEComOutputPort = 2;
#[doc = "< Secondary output port only available on B1 devices"]
pub const _SbgEComOutputPort_SBG_ECOM_OUTPUT_PORT_E: _SbgEComOutputPort = 4;
#[doc = " List of ouput ports available."]
pub type _SbgEComOutputPort = ::core::ffi::c_uint;
#[doc = " List of ouput ports available."]
pub use self::_SbgEComOutputPort as SbgEComOutputPort;
#[doc = "< This output is disabled."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DISABLED: _SbgEComOutputMode = 0;
#[doc = "< Output the message every main loop (ie 200 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_MAIN_LOOP: _SbgEComOutputMode = 1;
#[doc = "< Output the message every 2 main loops (ie 100 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_2: _SbgEComOutputMode = 2;
#[doc = "< Output the message every 4 main loops (ie 50 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_4: _SbgEComOutputMode = 4;
#[doc = "< Output the message every 4 main loops (ie 40 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_5: _SbgEComOutputMode = 5;
#[doc = "< Output the message every 8 main loops (ie 25 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_8: _SbgEComOutputMode = 8;
#[doc = "< Output the message every 10 main loops (ie 20 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_10: _SbgEComOutputMode = 10;
#[doc = "< Output the message every 20 main loops (ie 10 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_20: _SbgEComOutputMode = 20;
#[doc = "< Output the message every 40 main loops (ie 5 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_40: _SbgEComOutputMode = 40;
#[doc = "< Output the message every 200 main loops (ie 1 Hz)."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_DIV_200: _SbgEComOutputMode = 200;
#[doc = "< Output the message on a Pulse Per Second event."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_PPS: _SbgEComOutputMode = 10000;
#[doc = "< Output sent when a new data is available."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_NEW_DATA: _SbgEComOutputMode = 10001;
#[doc = "< Output the message when a Sync A is received."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_EVENT_IN_A: _SbgEComOutputMode = 10003;
#[doc = "< Output the message when a Sync B is received."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_EVENT_IN_B: _SbgEComOutputMode = 10004;
#[doc = "< Output the message when a Sync C is received."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_EVENT_IN_C: _SbgEComOutputMode = 10005;
#[doc = "< Output the message when a Sync D is received."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_EVENT_IN_D: _SbgEComOutputMode = 10006;
#[doc = "< Output the message when a Sync E is received."]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_EVENT_IN_E: _SbgEComOutputMode = 10007;
#[doc = "< Output the message in the 1KHz IMU loop"]
pub const _SbgEComOutputMode_SBG_ECOM_OUTPUT_MODE_HIGH_FREQ_LOOP: _SbgEComOutputMode = 20001;
#[doc = " List of output modes available."]
pub type _SbgEComOutputMode = ::core::ffi::c_uint;
#[doc = " List of output modes available."]
pub use self::_SbgEComOutputMode as SbgEComOutputMode;
#[doc = "< Output measurements at the IMU location."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_POINT_IMU:
    _SbgEComOutputMonitoringPoint = 0;
#[doc = "< Output measurements at the center of rotation."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_POINT_COG:
    _SbgEComOutputMonitoringPoint = 1;
#[doc = "< Output measurements at the user deported location 1 (only for Ekinox and Apogee)."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_POINT_1:
    _SbgEComOutputMonitoringPoint = 2;
#[doc = "< Output measurements at the user deported location 2 (only for Ekinox and Apogee)."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_POINT_2:
    _SbgEComOutputMonitoringPoint = 3;
#[doc = "< Output measurements at the user deported location 3 (only for Ekinox and Apogee)."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_POINT_3:
    _SbgEComOutputMonitoringPoint = 4;
#[doc = "< Number of output monitoring points."]
pub const _SbgEComOutputMonitoringPoint_SBG_ECOM_OUTPUT_MONITORING_NUM:
    _SbgEComOutputMonitoringPoint = 5;
#[doc = " Defines which monitoring point to use for an output port.\n This feature enabled deporting measurements at a specific monitoring point."]
pub type _SbgEComOutputMonitoringPoint = ::core::ffi::c_uint;
#[doc = " Defines which monitoring point to use for an output port.\n This feature enabled deporting measurements at a specific monitoring point."]
pub use self::_SbgEComOutputMonitoringPoint as SbgEComOutputMonitoringPoint;
extern "C" {
    #[doc = " Retrieve the configuration of one the message on one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port of the device for the log concerned.\n \\param[in]\tclassId\t\t\t\t\t\tThe class of the concerned log.\n \\param[in]\tmsgId\t\t\t\t\t\tThe id of the concerned log.\n \\param[out]\tpMode\t\t\t\t\t\tPointer to a SbgEComOutputMode to contain the current output mode of the message.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputGetConf(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        classId: SbgEComClass,
        msgId: SbgEComMsgId,
        pMode: *mut SbgEComOutputMode,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the configuration of one the message on one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port of the device for the log concerned.\n \\param[in]\tclassId\t\t\t\t\t\tThe class of the concerned log.\n \\param[in]\tmsgId\t\t\t\t\t\tThe id of the concerned log.\n \\param[in]\tmode\t\t\t\t\t\tNew output mode to set.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputSetConf(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        classId: SbgEComClass,
        msgId: SbgEComMsgId,
        mode: SbgEComOutputMode,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the enable of one of the output class message on one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port.\n \\param[in]\tclassId\t\t\t\t\t\tThe class to enable or disable.\n \\param[out]\tpEnable\t\t\t\t\t\tTRUE to enable message output of this class, FALSE to disable it.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputClassGetEnable(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        classId: SbgEComClass,
        pEnable: *mut bool,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the enable of one of the output class message on one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port.\n \\param[in]\tclassId\t\t\t\t\t\tThe class to enable or disable.\n \\param[in]\tenable\t\t\t\t\t\tTRUE to enable message output of this class, FALSE to disable it.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputClassSetEnable(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        classId: SbgEComClass,
        enable: bool,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the configuration of one the message on the CAN interface.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tinternalId\t\t\t\t\tThe internal message id.\n \\param[out]\tpMode\t\t\t\t\t\tPointer to a SbgEComOutputMode to contain the current output mode of the message.\n \\param[out]\tpUserId\t\t\t\t\t\tThe user defined message id.\n \\param[out]\tpExtended\t\t\t\t\tTRUE if the user id uses the extended format.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdCanOutputGetConf(
        pHandle: *mut SbgEComHandle,
        internalId: SbgECanMessageId,
        pMode: *mut SbgEComOutputMode,
        pUserId: *mut u32,
        pExtended: *mut bool,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the configuration of one the message on the CAN interface\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tinternalId\t\t\t\t\tThe internal message id.\n \\param[in]\tmode\t\t\t\t\t\tPointer to a SbgEComOutputMode containing the new output mode of the message.\n \\param[in]\tuserId\t\t\t\t\t\tThe user defined message id.\n \\param[in]\textended\t\t\t\t\tTRUE if the user id uses the extended format.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdCanOutputSetConf(
        pHandle: *mut SbgEComHandle,
        internalId: SbgECanMessageId,
        mode: SbgEComOutputMode,
        userId: u32,
        extended: bool,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the NMEA talker id of one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port of the device for the log concerned.\n \\param[out]\tpNmeaTalkerId\t\t\t\tA 2-char array to contain the nmea talker id.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputGetNmeaTalkerId(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        pNmeaTalkerId: *mut ::core::ffi::c_char,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the NMEA talker id of one of the output interfaces.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\toutputPort\t\t\t\t\tThe output port of the device for the log concerned.\n \\param[out]\tpNmeaTalkerId\t\t\t\tA 2-char array containint the new nmea talker id.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdOutputSetNmeaTalkerId(
        pHandle: *mut SbgEComHandle,
        outputPort: SbgEComOutputPort,
        pNmeaTalkerId: *const ::core::ffi::c_char,
    ) -> SbgErrorCode;
}
#[doc = "< Module connected on PORT_A."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_PORT_A: _SbgEComModulePortAssignment = 0;
#[doc = "< Module connected on PORT_B."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_PORT_B: _SbgEComModulePortAssignment = 1;
#[doc = "< Module connected on PORT_C."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_PORT_C: _SbgEComModulePortAssignment = 2;
#[doc = "< Module connected on PORT_D."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_PORT_D: _SbgEComModulePortAssignment = 3;
#[doc = "< Module connected on PORT_E."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_PORT_E: _SbgEComModulePortAssignment = 4;
#[doc = "< Module is connected internally."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_INTERNAL: _SbgEComModulePortAssignment = 5;
#[doc = "< Module is disabled."]
pub const _SbgEComModulePortAssignment_SBG_ECOM_MODULE_DISABLED: _SbgEComModulePortAssignment = 255;
#[doc = " Ports available for the modules."]
pub type _SbgEComModulePortAssignment = ::core::ffi::c_uint;
#[doc = " Ports available for the modules."]
pub use self::_SbgEComModulePortAssignment as SbgEComModulePortAssignment;
#[doc = "< Module is disabled."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_DISABLED: _SbgEComModuleSyncAssignment =
    0;
#[doc = "< Synchronization is done using SYNC_IN_A pin."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_IN_A: _SbgEComModuleSyncAssignment = 1;
#[doc = "< Synchronization is done using SYNC_IN_B pin."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_IN_B: _SbgEComModuleSyncAssignment = 2;
#[doc = "< Synchronization is done using SYNC_IN_C pin."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_IN_C: _SbgEComModuleSyncAssignment = 3;
#[doc = "< Synchronization is done using SYNC_IN_D pin."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_IN_D: _SbgEComModuleSyncAssignment = 4;
#[doc = "< Synchronization is internal."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_INTERNAL: _SbgEComModuleSyncAssignment =
    5;
#[doc = "< Synchronization signal is output on SYNC_OUT_A."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_OUT_A: _SbgEComModuleSyncAssignment = 6;
#[doc = "< Synchronization signal is output on SYNC_OUT_B."]
pub const _SbgEComModuleSyncAssignment_SBG_ECOM_MODULE_SYNC_OUT_B: _SbgEComModuleSyncAssignment = 7;
#[doc = " Synchronization signals available for the modules."]
pub type _SbgEComModuleSyncAssignment = ::core::ffi::c_uint;
#[doc = " Synchronization signals available for the modules."]
pub use self::_SbgEComModuleSyncAssignment as SbgEComModuleSyncAssignment;
#[doc = "< Odometer is disabled."]
pub const _SbgEComOdometerPinAssignment_SBG_ECOM_MODULE_ODO_DISABLED:
    _SbgEComOdometerPinAssignment = 0;
#[doc = "< Odometer connected only to ODO_A (unidirectional).."]
pub const _SbgEComOdometerPinAssignment_SBG_ECOM_MODULE_ODO_A: _SbgEComOdometerPinAssignment = 1;
#[doc = "< Odometer connected to both ODO_A (signal A) and ODO_B (Signal B or direction) for bidirectional odometer.."]
pub const _SbgEComOdometerPinAssignment_SBG_ECOM_MODULE_ODO_A_B: _SbgEComOdometerPinAssignment = 2;
#[doc = "< Vehicle odometer using CAN (OBD-II)."]
pub const _SbgEComOdometerPinAssignment_SBG_ECOM_MODULE_ODO_CAN: _SbgEComOdometerPinAssignment = 3;
#[doc = " List of configurations available for the odometer."]
pub type _SbgEComOdometerPinAssignment = ::core::ffi::c_uint;
#[doc = " List of configurations available for the odometer."]
pub use self::_SbgEComOdometerPinAssignment as SbgEComOdometerPinAssignment;
#[doc = "< Should be used as a default when other profiles do not apply"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_GENERAL_PURPOSE:
    _SbgEComMotionProfileStdIds = 1;
#[doc = "< Dedicated to car applications with strict lateral velocity constraints."]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_AUTOMOTIVE:
    _SbgEComMotionProfileStdIds = 2;
#[doc = "< Used in marine and underwater applications"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_MARINE: _SbgEComMotionProfileStdIds =
    3;
#[doc = "< For fixed wings aircraft"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_AIRPLANE:
    _SbgEComMotionProfileStdIds = 4;
#[doc = "< For rotary wing aircraft"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_HELICOPTER:
    _SbgEComMotionProfileStdIds = 5;
#[doc = "< Pedestrian applications using foot odometry"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_PEDESTRIAN:
    _SbgEComMotionProfileStdIds = 6;
#[doc = "< For rotary wing UAVs that have low dynamics"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_UAV_ROTARY_WING:
    _SbgEComMotionProfileStdIds = 7;
#[doc = "< For vibrating applications with low dynamics and no specific travel direction"]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_HEAVY_MACHINERY:
    _SbgEComMotionProfileStdIds = 8;
#[doc = "< Static motion profile that delivers stable results for 27/7 operations."]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_STATIC: _SbgEComMotionProfileStdIds =
    9;
#[doc = "< Truck applications with medium lateral velocity constraints."]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_TRUCK: _SbgEComMotionProfileStdIds =
    10;
#[doc = "< Train applications with relaxed lateral velocity constraints."]
pub const _SbgEComMotionProfileStdIds_SBG_ECOM_MOTION_PROFILE_RAILWAY: _SbgEComMotionProfileStdIds =
    11;
#[doc = " This enum defines the different motion profile IDs available in standard"]
pub type _SbgEComMotionProfileStdIds = ::core::ffi::c_uint;
#[doc = " This enum defines the different motion profile IDs available in standard"]
pub use self::_SbgEComMotionProfileStdIds as SbgEComMotionProfileStdIds;
#[doc = " Helper structure for module assignments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComAidingAssignConf {
    #[doc = "< GNSS module port assignment."]
    pub gps1Port: SbgEComModulePortAssignment,
    #[doc = "< GNSS module sync assignment."]
    pub gps1Sync: SbgEComModuleSyncAssignment,
    #[doc = "< Port on which the DVL is connected"]
    pub dvlPort: SbgEComModulePortAssignment,
    #[doc = "< Optional sync signal that could be used to time stamp the DVL data."]
    pub dvlSync: SbgEComModuleSyncAssignment,
    #[doc = "< RTCM input port assignment for IGNG-N DGPS."]
    pub rtcmPort: SbgEComModulePortAssignment,
    #[doc = "< Port on which Air Data aiding is connected."]
    pub airDataPort: SbgEComModulePortAssignment,
    #[doc = "< Odometer module pin assignment."]
    pub odometerPinsConf: SbgEComOdometerPinAssignment,
}
#[test]
fn bindgen_test_layout__SbgEComAidingAssignConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComAidingAssignConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComAidingAssignConf>(),
        28usize,
        concat!("Size of: ", stringify!(_SbgEComAidingAssignConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComAidingAssignConf>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComAidingAssignConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gps1Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(gps1Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gps1Sync) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(gps1Sync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dvlPort) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(dvlPort)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dvlSync) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(dvlSync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtcmPort) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(rtcmPort)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).airDataPort) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(airDataPort)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).odometerPinsConf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComAidingAssignConf),
            "::",
            stringify!(odometerPinsConf)
        )
    );
}
#[doc = " Helper structure for module assignments"]
pub type SbgEComAidingAssignConf = _SbgEComAidingAssignConf;
#[doc = " Helper structure for sensor alignment details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComSensorAlignmentInfo {
    #[doc = "< Sensor X axis direction in vehicle"]
    pub axisDirectionX: SbgEComAxisDirection,
    #[doc = "< Sensor Y axis direction in vehicle"]
    pub axisDirectionY: SbgEComAxisDirection,
    #[doc = "< Roll angle fine misalignment in rad"]
    pub misRoll: f32,
    #[doc = "< Pitch angle fine misalignment in rad"]
    pub misPitch: f32,
    #[doc = "< Yaw angle fine misalignment in rad"]
    pub misYaw: f32,
}
#[test]
fn bindgen_test_layout__SbgEComSensorAlignmentInfo() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComSensorAlignmentInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComSensorAlignmentInfo>(),
        20usize,
        concat!("Size of: ", stringify!(_SbgEComSensorAlignmentInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComSensorAlignmentInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_SbgEComSensorAlignmentInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axisDirectionX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSensorAlignmentInfo),
            "::",
            stringify!(axisDirectionX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axisDirectionY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSensorAlignmentInfo),
            "::",
            stringify!(axisDirectionY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).misRoll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSensorAlignmentInfo),
            "::",
            stringify!(misRoll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).misPitch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSensorAlignmentInfo),
            "::",
            stringify!(misPitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).misYaw) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComSensorAlignmentInfo),
            "::",
            stringify!(misYaw)
        )
    );
}
#[doc = " Helper structure for sensor alignment details"]
pub type SbgEComSensorAlignmentInfo = _SbgEComSensorAlignmentInfo;
#[doc = " Helper structure for sensor Initial condition details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SbgEComInitConditionConf {
    #[doc = "< Initial latitude in °"]
    pub latitude: f64,
    #[doc = "< Initial longitude in °"]
    pub longitude: f64,
    #[doc = "< Initial altitude above MSL in meters"]
    pub altitude: f64,
    #[doc = "< Initial Year"]
    pub year: u16,
    #[doc = "< Initial month"]
    pub month: u8,
    #[doc = "< Initial day"]
    pub day: u8,
}
#[test]
fn bindgen_test_layout__SbgEComInitConditionConf() {
    const UNINIT: ::core::mem::MaybeUninit<_SbgEComInitConditionConf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SbgEComInitConditionConf>(),
        32usize,
        concat!("Size of: ", stringify!(_SbgEComInitConditionConf))
    );
    assert_eq!(
        ::core::mem::align_of::<_SbgEComInitConditionConf>(),
        8usize,
        concat!("Alignment of ", stringify!(_SbgEComInitConditionConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(longitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altitude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_SbgEComInitConditionConf),
            "::",
            stringify!(day)
        )
    );
}
#[doc = " Helper structure for sensor Initial condition details"]
pub type SbgEComInitConditionConf = _SbgEComInitConditionConf;
extern "C" {
    #[doc = " Set the motion profile id used to tune the Kalman Filter to a specific application\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tmodelId\t\t\t\t\t\tMotion profile id to set\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorSetMotionProfileId(
        pHandle: *mut SbgEComHandle,
        modelId: SbgEComMotionProfileStdIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the motion profile id.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpModelId\t\t\t\t\tRetrieved motion profile id\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorGetMotionProfileId(
        pHandle: *mut SbgEComHandle,
        pModelId: *mut SbgEComMotionProfileStdIds,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the initial conditions settings.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComInitConditionConf to contain the current initial conditions settings.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorGetInitCondition(
        pHandle: *mut SbgEComHandle,
        pConf: *mut SbgEComInitConditionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the initial condition configuration.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpConf\t\t\t\t\t\tPointer to a SbgEComInitConditionConf containing the new initial condition configuration.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorSetInitCondition(
        pHandle: *mut SbgEComHandle,
        pConf: *const SbgEComInitConditionConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the assignment of the aiding sensors.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComAidingAssignConf to contain the current assignment of the aiding sensors.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorGetAidingAssignment(
        pHandle: *mut SbgEComHandle,
        pConf: *mut SbgEComAidingAssignConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the assignment of the aiding sensors.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpConf\t\t\t\t\t\tPointer to a SbgEComAidingAssignConf containing the new assignment of the aiding sensors.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorSetAidingAssignment(
        pHandle: *mut SbgEComHandle,
        pConf: *const SbgEComAidingAssignConf,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve the alignment and lever arm configuration of the sensor.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[out]\tpAlignConf\t\t\t\t\tPointer to a SbgEComSensorAlignmentInfo struct to hold alignment configuration of the sensor.\n \\param[out]\tpLeverArm\t\t\t\t\tPointer to a table to contain lever arm X, Y, Z components in meters.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorGetAlignmentAndLeverArm(
        pHandle: *mut SbgEComHandle,
        pAlignConf: *mut SbgEComSensorAlignmentInfo,
        pLeverArm: *mut f32,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Set the alignment and lever arm configuration of the sensor.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpAlignConf\t\t\t\t\tPointer to a SbgEComSensorAlignmentInfo struct holding alignment configuration for the sensor.\n \\param[in]\tpLeverArm\t\t\t\t\tPointer to a table containing lever arm X, Y, Z components in meters.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSensorSetAlignmentAndLeverArm(
        pHandle: *mut SbgEComHandle,
        pAlignConf: *const SbgEComSensorAlignmentInfo,
        pLeverArm: *const f32,
    ) -> SbgErrorCode;
}
#[doc = "< Only reboot the device."]
pub const _SbgEComSettingsAction_SBG_ECOM_REBOOT_ONLY: _SbgEComSettingsAction = 0;
#[doc = "< Save the settings to non-volatile memory and then reboot the device."]
pub const _SbgEComSettingsAction_SBG_ECOM_SAVE_SETTINGS: _SbgEComSettingsAction = 1;
#[doc = "< Restore default settings, save them to non-volatile memory and reboot the device."]
pub const _SbgEComSettingsAction_SBG_ECOM_RESTORE_DEFAULT_SETTINGS: _SbgEComSettingsAction = 2;
#[doc = " Defintion of all the settings actions available."]
pub type _SbgEComSettingsAction = ::core::ffi::c_uint;
#[doc = " Defintion of all the settings actions available."]
pub use self::_SbgEComSettingsAction as SbgEComSettingsAction;
extern "C" {
    #[doc = " Send a command to execute a specific system action to reboot/save/restore default settings.\n\n Execute one of the available settings action:\n\t- SBG_ECOM_REBOOT_ONLY : Only reboot the device.\n\t- SBG_ECOM_SAVE_SETTINGS : Save the settings to non-volatile memory and then reboot the device.\n\t- SBG_ECOM_RESTORE_DEFAULT_SETTINGS : Restore default settings, save them to non-volatile memory and reboot the device.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\taction\t\t\t\t\t\tOne of the available SbgEComSettingsAction.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdSettingsAction(
        pHandle: *mut SbgEComHandle,
        action: SbgEComSettingsAction,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Send a complete set of settings to the device and store them into the FLASH memory.\n\n The device will reboot automatically to use the new settings.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpBuffer\t\t\t\t\t\tRead only buffer containing the settings.\n \\param[in]\tsize\t\t\t\t\t\tSize of the buffer.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdImportSettings(
        pHandle: *mut SbgEComHandle,
        pBuffer: *const ::core::ffi::c_void,
        size: usize,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Retrieve a complete set of settings from the device as a buffer.\n\n \\param[in]\tpHandle\t\t\t\t\t\tA valid sbgECom handle.\n \\param[in]\tpBuffer\t\t\t\t\t\tAllocated buffer that can hold the received settings.\n \\param[out]\tpSize\t\t\t\t\t\tThe number of bytes that have been stored into pBuffer.\n \\param[in]\tmaxSize\t\t\t\t\t\tThe maximum buffer size in bytes that can be stored into pBuffer.\n \\return\t\t\t\t\t\t\t\t\tSBG_NO_ERROR if the command has been executed successfully."]
    pub fn sbgEComCmdExportSettings(
        pHandle: *mut SbgEComHandle,
        pBuffer: *mut ::core::ffi::c_void,
        pSize: *mut usize,
        maxSize: usize,
    ) -> SbgErrorCode;
}
extern "C" {
    #[doc = " Returns an integer representing the version of the sbgECom library.\n\n \\return\t\t\t\t\t\t\t\t\t\tAn integer representing the version of the sbgECom library.<br>"]
    pub fn sbgEComGetVersion() -> u32;
}
extern "C" {
    #[doc = " Retrieve the sbgECom library version as a string (1.0.443-stable).\n\n \\return\t\t\t\t\t\t\t\t\t\tNull terminated string that contains the sbgECom library version."]
    pub fn sbgEComGetVersionAsString() -> *const ::core::ffi::c_char;
}
